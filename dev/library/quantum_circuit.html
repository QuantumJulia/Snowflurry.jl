<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Circuits · Snowflurry</title><meta name="title" content="Quantum Circuits · Snowflurry"/><meta property="og:title" content="Quantum Circuits · Snowflurry"/><meta property="twitter:title" content="Quantum Circuits · Snowflurry"/><meta name="description" content="Documentation for Snowflurry."/><meta property="og:description" content="Documentation for Snowflurry."/><meta property="twitter:description" content="Documentation for Snowflurry."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Snowflurry logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Snowflurry</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../getting_started.html">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/basics.html">Basics</a></li><li><a class="tocitem" href="../tutorials/virtual_qpu.html">Virtual QPU</a></li><li><a class="tocitem" href="../tutorials/anyon_qpu.html">Real hardware</a></li></ul></li><li><span class="tocitem">Advanced Examples</span><ul><li><a class="tocitem" href="../tutorials/advanced/async_jobs.html">Asynchronous Jobs</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="quantum_toolkit.html">Quantum Toolkit</a></li><li><a class="tocitem" href="quantum_gates.html">Quantum Gates</a></li><li class="is-active"><a class="tocitem" href="quantum_circuit.html">Quantum Circuits</a></li><li><a class="tocitem" href="qpu.html">QPU</a></li><li><a class="tocitem" href="pauli_sim.html">Pauli Simulator</a></li><li><a class="tocitem" href="viz.html">Visualization</a></li></ul></li><li><a class="tocitem" href="../development.html">Developing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="quantum_circuit.html">Quantum Circuits</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="quantum_circuit.html">Quantum Circuits</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/main/docs/src/library/quantum_circuit.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantum-Circuit"><a class="docs-heading-anchor" href="#Quantum-Circuit">Quantum Circuit</a><a id="Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuit" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.QuantumCircuit" href="#Snowflurry.QuantumCircuit"><code>Snowflurry.QuantumCircuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuantumCircuit(qubit_count)</code></pre><p>A data structure to represent a <em>quantum circuit</em>.  </p><p><strong>Fields</strong></p><ul><li><code>qubit_count::Int</code> – number of qubits (i.e., quantum register size).</li><li><code>gates::Vector{AbstractGateSymbol}</code> – the sequence of gates to operate on qubits.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push!(circuit::QuantumCircuit, gates::AbstractGateSymbol...)</code></pre><p>Inserts one or more <code>gates</code> at the end of a <code>circuit</code>.</p><p>A <code>Vector</code> of <code>AbstractGateSymbol</code> objects can be passed to this function by using splatting. More details about splatting are provided <a href="https://docs.julialang.org/en/v1/manual/faq/#What-does-the-...-operator-do?">here</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; gate_list = [sigma_x(1), hadamard(2)];

julia&gt; push!(c, gate_list...)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*────X───────
                 |            
q[2]:───────X────X─────────H──
                              


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L47-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pop!(circuit::QuantumCircuit)</code></pre><p>Removes the last instruction from <code>circuit.instructions</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; pop!(c)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L559-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">append!(base_circuit::QuantumCircuit, circuits_to_append::QuantumCircuit...)</code></pre><p>Appends one or more <code>circuits_to_append</code> to the <code>base_circuit</code>.</p><p>The <code>circuits_to_append</code> cannot contain more qubits than the <code>base_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; base = QuantumCircuit(qubit_count=2, instructions=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; append_1 = QuantumCircuit(qubit_count=1, instructions=[sigma_z(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──Z──
          



julia&gt; append_2 = QuantumCircuit(qubit_count=2, instructions=[control_x(1,2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──*──
       |  
q[2]:──X──
          



julia&gt; append!(base, append_1, append_2)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X────Z────*──
                 |  
q[2]:────────────X──
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L109-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prepend!(base_circuit::QuantumCircuit, circuits_to_prepend::QuantumCircuit...)</code></pre><p>Prepends one or more <code>circuits_to_prepend</code> to the <code>base_circuit</code>.</p><p>The order of the <code>circuits_to_prepend</code> is maintained (i.e., <code>circuits_to_prepend[1]</code> will appear leftmost in <code>base_circuit</code>). The <code>circuits_to_prepend</code> cannot contain more qubits than the <code>base_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; base = QuantumCircuit(qubit_count=2, instructions=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; prepend_1 = QuantumCircuit(qubit_count=1, instructions=[sigma_z(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──Z──
          



julia&gt; prepend_2 = QuantumCircuit(qubit_count=2, instructions=[control_x(1,2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──*──
       |  
q[2]:──X──
          



julia&gt; prepend!(base, prepend_1, prepend_2)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────*────X──
            |       
q[2]:───────X───────
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L174-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.simulate" href="#Snowflurry.simulate"><code>Snowflurry.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(circuit::QuantumCircuit)</code></pre><p>Simulates and returns the wavefunction of the quantum device after running <code>circuit</code>,  assuming an initial state Ket ψ corresponding to the 0th Fock basis, i.e.:  <code>ψ=fock(0,2^get_num_qubits(circuit))</code>. </p><p>Employs the approach described in Listing 5 of <a href="https://doi.org/10.22331/q-2021-10-06-559">Suzuki <em>et. al.</em> (2021)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; ket = simulate(c)
4-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L821-L862">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.simulate_shots" href="#Snowflurry.simulate_shots"><code>Snowflurry.simulate_shots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_shots(c::QuantumCircuit, shots_count::Int = 100)</code></pre><p>Emulates a quantum computer by running a circuit for a given number of shots and returning measurement results.  The distribution of measured states corresponds to the coefficients in the resulting state Ket. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; simulate_shots(c, 99)
99-element Vector{String}:
 &quot;11&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 ⋮
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L873-L924">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_measurement_probabilities-Tuple{QuantumCircuit}" href="#Snowflurry.get_measurement_probabilities-Tuple{QuantumCircuit}"><code>Snowflurry.get_measurement_probabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_measurement_probabilities(circuit::QuantumCircuit,
    [target_qubits::Vector{&lt;:Integer}])::AbstractVector{&lt;:Real}</code></pre><p>Returns a vector listing the measurement probabilities for the <code>target_qubits</code> in the <code>circuit</code>.</p><p>If no <code>target_qubits</code> are provided, the probabilities are computed for all the qubits.</p><p>The measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit <code>QuantumCircuit</code>, the probabilities are listed for 00, 01, 10, and 11.</p><p><strong>Examples</strong></p><p>The following example constructs a <code>QuantumCircuit</code> where the probability of measuring 01 is 50% and the probability of measuring 11 is also 50%.</p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count=2);

julia&gt; push!(circuit, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; get_measurement_probabilities(circuit)
4-element Vector{Float64}:
 0.0
 0.4999999999999999
 0.0
 0.4999999999999999
</code></pre><p>For the same <code>circuit</code>, the probability of measuring qubit 2 and finding 1 is 100%.</p><pre><code class="language-julia-repl hljs">julia&gt; target_qubit = [2];

julia&gt; get_measurement_probabilities(circuit, target_qubit)
2-element Vector{Float64}:
 0.0
 0.9999999999999998
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L947-L993">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{QuantumCircuit}" href="#Base.inv-Tuple{QuantumCircuit}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(circuit::QuantumCircuit)</code></pre><p>Return a <code>QuantumCircuit</code> which is the inverse of the input <code>circuit</code>.  Each gate is replaced by its corresponding inverse, and the order of gates is reversed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, rotation_y(1, pi/4));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Ry(0.7854)────*──
                     |  
q[2]:────────────────X──
                        



julia&gt; inv(c)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──*────Ry(-0.7854)──
       |                 
q[2]:──X─────────────────
                         


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L1008-L1041">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_gates_per_type" href="#Snowflurry.get_num_gates_per_type"><code>Snowflurry.get_num_gates_per_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_gates_per_type(circuit::QuantumCircuit)::AbstractDict{&lt;: AbstractString, &lt;:Integer}</code></pre><p>Returns a dictionary listing the number of gates of each type found in the <code>circuit</code>.</p><p>The dictionary keys are the instruction_symbol of the gates while the values are the number of gates found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, hadamard(1), hadamard(2));

julia&gt; push!(c, control_x(1, 2));

julia&gt; push!(c, hadamard(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*───────
                 |       
q[2]:───────H────X────H──
                         



julia&gt; get_num_gates_per_type(c)
Dict{String, Int64} with 2 entries:
  &quot;h&quot;  =&gt; 3
  &quot;cx&quot; =&gt; 1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L1054-L1085">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_gates" href="#Snowflurry.get_num_gates"><code>Snowflurry.get_num_gates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_gates(circuit::QuantumCircuit)::Integer</code></pre><p>Returns the number of gates in the <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, hadamard(1), hadamard(2));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────H────X──
                    



julia&gt; get_num_gates(c)
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L1101-L1126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.serialize_job" href="#Snowflurry.serialize_job"><code>Snowflurry.serialize_job</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">serialize_job(circuit::QuantumCircuit,shot_count::Integer)</code></pre><p>Creates a JSON-formatted String containing the circuit configuration to be sent  to a <code>QPU</code> service, along with the number of shots requested.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2,instructions=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; serialize_job(c,10)
&quot;{\&quot;qubit_count\&quot;:2,\&quot;shot_count\&quot;:10,\&quot;circuit\&quot;:{\&quot;operations\&quot;:[{\&quot;parameters\&quot;:{},\&quot;type\&quot;:\&quot;x\&quot;,\&quot;qubits\&quot;:[0]}]}}&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/anyon/qpu_interface.jl#L111-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.transpile" href="#Snowflurry.transpile"><code>Snowflurry.transpile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transpile(::CompressSingleQubitGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CompressSingleQubitGatesTranspiler</code> transpiler stage  which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single <code>Universal</code> gates in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CompressSingleQubitGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X────Y──
               
q[2]:──────────
               



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 3, instructions=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y─────────Rz(1.0472)──
                                  
q[2]:────────────*────────────────
                 |                
q[3]:────────────X────────────────
                                  



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────
                                            
q[2]:────────────────────────────────────*──
                                         |  
q[3]:────────────────────────────────────X──
                                            




julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L319-L385">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastSwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastSwapToCZGateTranspiler</code> transpiler stage which expands all Swap gates into <code>CZ</code> gates and single-qubit gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastSwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[swap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──☒──
       |
q[2]:──☒──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────
                |                     |                     |          
q[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──
                                              
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L421-L449">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastCXToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastCXToCZGateTranspiler</code> transpiler stage which expands all <code>CX</code> gates into <code>CZ</code> and <code>Hadamard</code> gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastCXToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──*──
       |
q[2]:──X──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2
q[1]:───────*───────
            |
q[2]:──H────Z────H──</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L478-L504">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastISwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastISwapToCZGateTranspiler</code> transpiler stage which expands all <code>ISwap</code> gates into <code>CZ</code> gates and single-qubit gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastISwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[iswap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──x──
       |
q[2]:──x──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────
                         |                     |                  
q[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──
                                                                  
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L542-L570">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastToffoliToCXGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastToffoliToCXGateTranspiler</code> transpiler stage which expands all Toffoli gates into <code>CX</code> gates and single-qubit gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastToffoliToCXGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 3, instructions=[toffoli(1, 2, 3)])
Quantum Circuit Object:
   qubit_count: 3
q[1]:──*──
       |
q[2]:──*──
       |
q[3]:──X──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──────────────────*────────────────────*──────────────*─────────T──────────*──
                       |                    |              |                    |  
q[2]:───────*──────────|─────────*──────────|────T─────────X──────────────T†────X──
            |          |         |          |                                      
q[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──────────────────
                                                                                   
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L621-L653">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastToPhaseShiftAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastToPhaseShiftAndHalfRotationXTranspiler</code> transpiler stage  which converts all single-qubit gates in an input circuit and converts them  into combinations of <code>PhaseShift</code> and <code>RotationX</code> with angle π/2 in an output  circuit. For any gate in the input circuit, the number of gates in the  output varies between zero and 5. The result of the input and output  circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastToPhaseShiftAndHalfRotationXTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────X_90────Z────X_m90──
                                                 
q[2]:───────────────────────────
                                                 



julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Y──
          
q[2]:─────
          



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z_90────X_90────Z────X_m90────Z_90──
                                           
q[2]:──────────────────────────────────────
                                           



julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[universal(1,0.,0.,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L762-L843">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastUniversalToRzRxRzTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastUniversalToRzRxRzTranspiler</code> transpiler stage  which finds <code>Universal</code> gates in an input circuit and casts  them into a sequence of <code>PhaseShift</code> (Rz), <code>RotationX</code> (Rx) and  <code>PhaseShift</code> (Rz) gates in a new circuit. The result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastUniversalToRzRxRzTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[universal(1,π/2,π/4,π/8)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=1.5708,ϕ=0.7854,λ=0.3927)──
                                      
q[2]:─────────────────────────────────
                                      

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rz(-1.1781)────Rx(1.5708)────Rz(2.3562)──
                                                
q[2]:───────────────────────────────────────────
                                                

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[universal(1,0,π/4,0)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.7854,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rz(-1.5708)────Rx(0.0000)────Rz(2.3562)──
                                                
q[2]:───────────────────────────────────────────
                                                

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L902-L955">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastRxToRzAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastRxToRzAndHalfRotationXTranspiler</code> transpiler stage  which finds <code>RotationX(θ)</code> gates in an input circuit and converts (casts)  them into a sequence of gates: <code>Z90</code>,<code>X90</code>,<code>PhaseShift(θ)</code>,<code>XM90</code>,<code>ZM90</code> in a new circuit. The result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastRxToRzAndHalfRotationXTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[rotation_x(1,π/8)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(0.3927)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z_90────X_90────Rz(0.3927)────X_m90────Z_m90──
                                                     
q[2]:────────────────────────────────────────────────
                                                     

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L1008-L1041">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::SimplifyRxGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyRxGatesTranspiler</code> transpiler stage  which finds <code>RotationX</code> gates in an input circuit and according to its  angle theta, casts them to one of the right-angle <code>RotationX</code> gates,  e.g., <code>SigmaX</code>, <code>X90</code>, or <code>XM90</code>. In the case where <code>theta≈0.</code>, the gate is removed. The result of the input and output circuit on any arbitrary state <code>Ket</code> is  unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=SimplifyRxGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[rotation_x(1,pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(1.5708)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[rotation_x(1,pi)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(3.1416)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[rotation_x(1,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(0.0000)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L1072-L1148">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::SwapQubitsForAdjacencyTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SwapQubitsForAdjacencyTranspiler</code> transpiler stage  which adds <code>Swap</code> gates around multi-qubit gates so that the  final <code>Operator</code> acts on adjacent qubits. The result of the input  and output circuit on any arbitrary state <code>Ket</code> is unchanged  (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=SwapQubitsForAdjacencyTranspiler(LineConnectivity(6));

julia&gt; circuit = QuantumCircuit(qubit_count = 6, instructions=[toffoli(4,6,1)])
Quantum Circuit Object:
   qubit_count: 6 
q[1]:──X──
       |  
q[2]:──|──
       |  
q[3]:──|──
       |  
q[4]:──*──
       |  
q[5]:──|──
       |  
q[6]:──*──
          




julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 6 
q[1]:───────────────────────────X───────────────────────────
                                |                           
q[2]:───────☒───────────────────*───────────────────☒───────
            |                   |                   |       
q[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──
       |                   |         |                   |  
q[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──
                      |                   |                 
q[5]:────────────☒────☒───────────────────☒────☒────────────
                 |                             |            
q[6]:────────────☒─────────────────────────────☒────────────
                                                            



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L1239-L1293">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::SimplifyRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyRzGatesTranspiler</code> transpiler stage  which finds <code>PhaseShift</code> gates in an input circuit and according to its  phase angle phi, casts them to one of the right-angle <code>RotationZ</code> gates,  e.g., <code>SigmaZ</code>, <code>Z90</code>, <code>ZM90</code>, <code>Pi8</code> or <code>Pi8Dagger</code>. In the case where <code>phi≈0.</code>, the  gate is removed. The result of the input and output circuit on any  arbitrary state <code>Ket</code> is unchanged (up to a global phase). The tolerance  used for <code>Base.isapprox()</code> in each case can be set by passing an optional  argument to the <code>Transpiler</code>, e.g: <code>transpiler=SimplifyRzGatesTranspiler(1.0e-10)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=SimplifyRzGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[phase_shift(1,pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rz(1.5708)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[phase_shift(1,pi)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rz(3.1416)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[phase_shift(1,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rz(0.0000)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L1348-L1425">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CompressRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CompressRzGatesTranspiler</code> transpiler stage  which gathers all Rz-type gates sharing a common target in an input  circuit and combines them into single PhaseShift gate in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CompressRzGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[sigma_z(1),z_90(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────Z_90──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rz(-1.5708)──
                    
q[2]:───────────────
                    

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 3, instructions=[sigma_z(1),pi_8(1),control_x(2,3),z_minus_90(1)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──Z────T─────────Z_m90──
                             
q[2]:────────────*───────────
                 |           
q[3]:────────────X───────────
                             

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──Rz(2.3562)───────
                        
q[2]:────────────────*──
                     |  
q[3]:────────────────X──
                        

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L1489-L1546">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::RemoveSwapBySwappingGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Removes the <code>Swap</code> gates from the <code>circuit</code> assuming all-to-all connectivity.</p><div class="admonition is-warning"><header class="admonition-header">The initial state must be the ground state!</header><div class="admonition-body"><p>This transpiler stage assumes that the input state is <span>$|0\rangle^{\otimes N}$</span> where <span>$N$</span> is the number of qubits. The stage should not be used on sub-circuits where the input state is not <span>$|0\rangle^{\otimes N}$</span>.</p></div></div><p>This transpiler stage eliminates <code>Swap</code> gates by moving the gates preceding each <code>Swap</code> gate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = RemoveSwapBySwappingGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions=[hadamard(1), swap(1,2), sigma_x(2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────☒───────
            |       
q[2]:───────☒────X──
                    



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──────────
               
q[2]:──H────X──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L1567-L1605">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::SimplifyTrivialGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyTrivialGatesTranspiler</code> transpiler stage  which finds gates which have no effect on the state Ket, such as Identity, and  parameterized gates with null parameters such as rotation_x(target, 0.). The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyTrivialGatesTranspiler(1.0e-10)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=SimplifyTrivialGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[identity_gate(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──I──
          
q[2]:─────
          
julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit,transpiled_circuit)
true


julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[phase_shift(1,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rz(0.0000)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions=[universal(1,0.,0.,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                             
julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/transpile.jl#L1688-L1758">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.compare_circuits" href="#Snowflurry.compare_circuits"><code>Snowflurry.compare_circuits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_circuits(c0::QuantumCircuit,c1::QuantumCircuit)::Bool</code></pre><p>Tests for equivalence of two circuits based on their effect on an  arbitrary input state (a Ket). Circuits are equivalent if they both  yield the same output for any input, up to a global phase. Circuits with different ordering of gates that apply on different  targets can also be equivalent. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If there are <code>Readouts</code> are present in either <code>QuantumCircuit</code>,  they are ignored by <code>compare_circuit</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c0 = QuantumCircuit(qubit_count = 1, instructions=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──X────Y──
               



julia&gt; c1 = QuantumCircuit(qubit_count = 1, instructions=[phase_shift(1,π)])
Quantum Circuit Object:
   qubit_count: 1  
q[1]:──Rz(3.1416)──
                   



julia&gt; compare_circuits(c0,c1)
true            

julia&gt; c0 = QuantumCircuit(qubit_count = 3, instructions=[sigma_x(1),sigma_y(1),control_x(2,3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y───────
                    
q[2]:────────────*──
                 |  
q[3]:────────────X──
                    



julia&gt; c1 = QuantumCircuit(qubit_count = 3, instructions=[control_x(2,3),sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:───────X────Y──
                    
q[2]:──*────────────
       |            
q[3]:──X────────────
                    



julia&gt; compare_circuits(c0,c1)
true    
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L242-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.circuit_contains_gate_type" href="#Snowflurry.circuit_contains_gate_type"><code>Snowflurry.circuit_contains_gate_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circuit_contains_gate_type(circuit::QuantumCircuit, gate_type::Type{&lt;: AbstractGateSymbol})::Bool</code></pre><p>Determines whether a type of gate is present in a circuit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count = 1, instructions=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──X────Y──
               
julia&gt; circuit_contains_gate_type(circuit, Snowflurry.SigmaX)
true
               
julia&gt; circuit_contains_gate_type(circuit, Snowflurry.ControlZ)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L358-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.permute_qubits!" href="#Snowflurry.permute_qubits!"><code>Snowflurry.permute_qubits!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permute_qubits!(circuit::QuantumCircuit,
    qubit_mapping::AbstractDict{T,T}) where T&lt;:Integer</code></pre><p>Modifies a <code>circuit</code> by moving the gates to other qubits based on a <code>qubit_mapping</code>.</p><p>The dictionary <code>qubit_mapping</code> contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.</p><p>For instance, <code>Dict(1=&gt;2)</code> is not a valid <code>qubit_mapping</code>, but <code>Dict(1=&gt;2, 2=&gt;1)</code> is valid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=3);

julia&gt; push!(c, sigma_x(1), hadamard(2), sigma_y(3))
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────────────
                    
q[2]:───────H───────
                    
q[3]:────────────Y──                    



julia&gt; permute_qubits!(c, Dict(1=&gt;3, 3=&gt;1))

julia&gt; show(c)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:────────────Y──
                    
q[2]:───────H───────
                    
q[3]:──X────────────
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L1129-L1170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.permute_qubits" href="#Snowflurry.permute_qubits"><code>Snowflurry.permute_qubits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permute_qubits(circuit::QuantumCircuit,
    qubit_mapping::AbstractDict{T,T})::QuantumCircuit where T&lt;:Integer</code></pre><p>Returns a <code>QuantumCircuit</code> that is a copy of <code>circuit</code> but where the gates have been moved to other qubits based on a <code>qubit_mapping</code>.</p><p>The dictionary <code>qubit_mapping</code> contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.</p><p>For instance, <code>Dict(1=&gt;2)</code> is not a valid <code>qubit_mapping</code>, but <code>Dict(1=&gt;2, 2=&gt;1)</code> is valid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=3);

julia&gt; push!(c, sigma_x(1), hadamard(2), sigma_y(3))
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────────────
                    
q[2]:───────H───────
                    
q[3]:────────────Y──
                    



julia&gt; permute_qubits(c, Dict(1=&gt;3, 3=&gt;1))
Quantum Circuit Object:
   qubit_count: 3 
q[1]:────────────Y──
                    
q[2]:───────H───────
                    
q[3]:──X────────────
                    


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/d385cf6296e9757f4d6ae5c96c7b55f1b1233f3b/src/core/quantum_circuit.jl#L1211-L1253">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="quantum_gates.html">« Quantum Gates</a><a class="docs-footer-nextpage" href="qpu.html">QPU »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 11 January 2024 20:11">Thursday 11 January 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
