<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Circuits · Snowflurry</title><meta name="title" content="Quantum Circuits · Snowflurry"/><meta property="og:title" content="Quantum Circuits · Snowflurry"/><meta property="twitter:title" content="Quantum Circuits · Snowflurry"/><meta name="description" content="Documentation for Snowflurry."/><meta property="og:description" content="Documentation for Snowflurry."/><meta property="twitter:description" content="Documentation for Snowflurry."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="Snowflurry logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../getting_started.html">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/basics.html">Basics</a></li><li><a class="tocitem" href="../tutorials/virtual_qpu.html">Virtual QPU</a></li><li><a class="tocitem" href="../tutorials/anyon_qpu.html">Real hardware</a></li></ul></li><li><span class="tocitem">Advanced Examples</span><ul><li><a class="tocitem" href="../tutorials/advanced/async_jobs.html">Asynchronous Jobs</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="quantum_toolkit.html">Quantum Toolkit</a></li><li><a class="tocitem" href="quantum_gates.html">Quantum Gates</a></li><li class="is-active"><a class="tocitem" href="quantum_circuit.html">Quantum Circuits</a></li><li><a class="tocitem" href="qpu.html">QPU</a></li><li><a class="tocitem" href="pauli_sim.html">Pauli Simulator</a></li><li><a class="tocitem" href="viz.html">Visualization</a></li></ul></li><li><a class="tocitem" href="../development.html">Developing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="quantum_circuit.html">Quantum Circuits</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="quantum_circuit.html">Quantum Circuits</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/main/docs/src/library/quantum_circuit.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantum-Circuit"><a class="docs-heading-anchor" href="#Quantum-Circuit">Quantum Circuit</a><a id="Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuit" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.QuantumCircuit" href="#Snowflurry.QuantumCircuit"><code>Snowflurry.QuantumCircuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuantumCircuit(qubit_count::Int, bit_count::Int, instructions::Vector{AbstractInstruction}, name::String = &quot;default&quot;)
QuantumCircuit(circuit::QuantumCircuit)</code></pre><p>A data structure to represent a <em>quantum circuit</em>.</p><p><strong>Fields</strong></p><ul><li><code>qubit_count::Int</code> – number of qubits (i.e., quantum register size).</li><li><code>bit_count::Int</code> – Optional: number of classical bits (i.e., result register size). Defaults to <code>qubit_count</code> if unspecified.</li><li><code>instructions::Vector{AbstractInstruction}</code> – Optional: the sequence of <code>AbstractInstructions</code> (<code>Gates</code> and <code>Readouts</code>) that operate on qubits. Defaults to empty Vector.</li><li><code>name::String</code> – Optional: name of the circuit job, used to identify it when sending to a hardware or virtual QPU. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:</code></pre><p>A <code>QuantumCircuit</code> can be initialized containing <a href="quantum_gates.html#Snowflurry.Gate"><code>Gates</code></a> and <a href="quantum_toolkit.html#Snowflurry.Readout"><code>Readouts</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2, instructions = [hadamard(1), sigma_x(2), control_x(1, 2), readout(1, 1), readout(2, 2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*────✲───────
                 |            
q[2]:───────X────X─────────✲──
                              </code></pre><p>A deep copy of a <code>QuantumCircuit</code> can be obtained with the following command:</p><pre><code class="language-julia-repl hljs">julia&gt; c_copy = QuantumCircuit(c)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*────✲───────
                 |            
q[2]:───────X────X─────────✲──
                              </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L2-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push!(circuit::QuantumCircuit, gates::AbstractGateSymbol...)</code></pre><p>Inserts one or more <code>gates</code> at the end of a <code>circuit</code>.</p><p>A <code>Vector</code> of <code>AbstractGateSymbol</code> objects can be passed to this function by using splatting. More details about splatting are provided <a href="https://docs.julialang.org/en/v1/manual/faq/#What-does-the-...-operator-do?">here</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; gate_list = [sigma_x(1), hadamard(2)];

julia&gt; push!(c, gate_list...)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*────X───────
                 |            
q[2]:───────X────X─────────H──
                              


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L108-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pop!(circuit::QuantumCircuit)</code></pre><p>Removes the last instruction from <code>circuit.instructions</code>, and returns it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; pop!(c)
Gate Object: Snowflurry.ControlX
Connected_qubits	: [1, 2]
Operator:
(4, 4)-element Snowflurry.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im

julia&gt; c
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L685-L736">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">append!(base_circuit::QuantumCircuit, circuits_to_append::QuantumCircuit...)</code></pre><p>Appends one or more <code>circuits_to_append</code> to the <code>base_circuit</code>.</p><p>The <code>circuits_to_append</code> cannot contain more qubits than the <code>base_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; base = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; append_1 = QuantumCircuit(qubit_count = 1, instructions = [sigma_z(1)])
Quantum Circuit Object:
   qubit_count: 1 
   bit_count: 1 
q[1]:──Z──
          



julia&gt; append_2 = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──*──
       |  
q[2]:──X──
          



julia&gt; append!(base, append_1, append_2)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X────Z────*──
                 |  
q[2]:────────────X──
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L173-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prepend!(base_circuit::QuantumCircuit, circuits_to_prepend::QuantumCircuit...)</code></pre><p>Prepends one or more <code>circuits_to_prepend</code> to the <code>base_circuit</code>.</p><p>The order of the <code>circuits_to_prepend</code> is maintained (i.e., <code>circuits_to_prepend[1]</code> will appear leftmost in <code>base_circuit</code>). The <code>circuits_to_prepend</code> cannot contain more qubits than the <code>base_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; base = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; prepend_1 = QuantumCircuit(qubit_count = 1, instructions = [sigma_z(1)])
Quantum Circuit Object:
   qubit_count: 1 
   bit_count: 1 
q[1]:──Z──
          



julia&gt; prepend_2 = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──*──
       |  
q[2]:──X──
          



julia&gt; prepend!(base, prepend_1, prepend_2)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z────*────X──
            |       
q[2]:───────X───────
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L242-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.simulate" href="#Snowflurry.simulate"><code>Snowflurry.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(circuit::QuantumCircuit)::Ket</code></pre><p>Simulates and returns the wavefunction of the quantum device after running <code>circuit</code>,  assuming an initial state Ket ψ corresponding to the 0th Fock basis, i.e.:  <code>ψ = fock(0, 2^get_num_qubits(circuit))</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The input <code>circuit</code> must not include <code>Readouts</code>. For simulating <code>circuits</code> including <code>Readouts</code>, use <a href="quantum_circuit.html#Snowflurry.simulate_shots"><code>simulate_shots</code></a>.</p></div></div><p>Employs the approach described in Listing 5 of <a href="https://doi.org/10.22331/q-2021-10-06-559">Suzuki <em>et. al.</em> (2021)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; ket = simulate(c)
4-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L958-L1004">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.simulate_shots" href="#Snowflurry.simulate_shots"><code>Snowflurry.simulate_shots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_shots(c::QuantumCircuit, shots_count::Int = 100)</code></pre><p>Emulates a quantum computer by running a circuit for a given number of shots and returning measurement results, as prescribed by the <code>Readouts</code> present in the circuit.  The distribution of measured states corresponds to the coefficients in the resulting state Ket. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), control_x(1, 2), readout(1, 1), readout(2, 2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────*────✲───────
            |            
q[2]:───────X─────────✲──


julia&gt; simulate_shots(c, 99)
99-element Vector{String}:
 &quot;11&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 ⋮
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L1022-L1064">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_measurement_probabilities-Tuple{QuantumCircuit}" href="#Snowflurry.get_measurement_probabilities-Tuple{QuantumCircuit}"><code>Snowflurry.get_measurement_probabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_measurement_probabilities(circuit::QuantumCircuit,
    [target_qubits::Vector{&lt;:Integer}])::AbstractVector{&lt;:Real}</code></pre><p>Returns a vector listing the measurement probabilities for the <code>target_qubits</code> in the <code>circuit</code>.</p><p>If no <code>target_qubits</code> are provided, the probabilities are computed for all the qubits.</p><p>The measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit <a href="quantum_circuit.html#Snowflurry.QuantumCircuit"><code>QuantumCircuit</code></a>, the probabilities are listed for <span>$\left|00\right\rangle$</span>, <span>$\left|10\right\rangle$</span>, <span>$\left|01\right\rangle$</span>, and <span>$\left|11\right\rangle$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention, qubit 1 is the leftmost digit, followed by every subsequent qubit.  <span>$\left|10\right\rangle$</span> has qubit 1 in state <span>$\left|1\right\rangle$</span> and qubit 2 in state <span>$\left|0\right\rangle$</span></p></div></div><p><strong>Examples</strong></p><p>The following example constructs a <code>QuantumCircuit</code> where the probability of measuring <span>$\left|10\right\rangle$</span> is 50% and the probability of measuring <span>$\left|11\right\rangle$</span> is also 50%.</p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count = 2);

julia&gt; push!(circuit, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; get_measurement_probabilities(circuit)
4-element Vector{Float64}:
 0.0
 0.4999999999999999
 0.0
 0.4999999999999999
</code></pre><p>For the same <code>circuit</code>, the probability of measuring qubit 2 and finding 1 is 100%.</p><pre><code class="language-julia-repl hljs">julia&gt; target_qubit = [2];

julia&gt; get_measurement_probabilities(circuit, target_qubit)
2-element Vector{Float64}:
 0.0
 0.9999999999999998
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L1195-L1247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{QuantumCircuit}" href="#Base.inv-Tuple{QuantumCircuit}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(circuit::QuantumCircuit)</code></pre><p>Return a <code>QuantumCircuit</code> which is the inverse of the input <code>circuit</code>.  Each gate is replaced by its corresponding inverse, and the order of gates is reversed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, rotation_y(1, pi/4));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Ry(0.7854)────*──
                     |  
q[2]:────────────────X──
                        



julia&gt; inv(c)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──*────Ry(-0.7854)──
       |                 
q[2]:──X─────────────────
                         


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L1262-L1297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_gates_per_type" href="#Snowflurry.get_num_gates_per_type"><code>Snowflurry.get_num_gates_per_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_gates_per_type(circuit::QuantumCircuit)::AbstractDict{&lt;: AbstractString, &lt;:Integer}</code></pre><p>Returns a dictionary listing the number of gates of each type found in the <code>circuit</code>.</p><p>The dictionary keys are the instruction_symbol of the gates while the values are the number of gates found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), hadamard(2));

julia&gt; push!(c, control_x(1, 2));

julia&gt; push!(c, hadamard(2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*───────
                 |       
q[2]:───────H────X────H──
                         



julia&gt; get_num_gates_per_type(c)
Dict{String, Int64} with 2 entries:
  &quot;h&quot;  =&gt; 3
  &quot;cx&quot; =&gt; 1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L1311-L1343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.get_num_gates" href="#Snowflurry.get_num_gates"><code>Snowflurry.get_num_gates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_gates(circuit::QuantumCircuit)::Integer</code></pre><p>Returns the number of gates in the <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), hadamard(2));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────H────X──
                    



julia&gt; get_num_gates(c)
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L1359-L1385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.serialize_job" href="#Snowflurry.serialize_job"><code>Snowflurry.serialize_job</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">serialize_job(circuit::QuantumCircuit,shot_count::Integer,host::String)</code></pre><p>Creates a JSON-formatted String containing the circuit configuration to be sent  to a <code>QPU</code> service located at the URL specified by <code>host</code>, along with the number of shots requested.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)], name = &quot;sigma_x job&quot;)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X──
          
q[2]:─────
          
julia&gt; serialize_job(c, 10, &quot;machine&quot;, &quot;project_id&quot;)
&quot;{\&quot;shotCount\&quot;:10,\&quot;name\&quot;:\&quot;sigma_x job\&quot;,\&quot;machineName\&quot;:\&quot;machine\&quot;,\&quot;projectID\&quot;:\&quot;project_id\&quot;,\&quot;type\&quot;:\&quot;circuit\&quot;,\&quot;circuit\&quot;:{\&quot;operations\&quot;:[{\&quot;parameters\&quot;:{},\&quot;type\&quot;:\&quot;x\&quot;,\&quot;qubits\&quot;:[0]}],\&quot;bitCount\&quot;:2,\&quot;qubitCount\&quot;:2}}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/anyon/qpu_interface.jl#L134-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.transpile" href="#Snowflurry.transpile"><code>Snowflurry.transpile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transpile(::CompressSingleQubitGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CompressSingleQubitGatesTranspiler</code> transpiler stage  which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single <code>Universal</code> gates in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CompressSingleQubitGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1), sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X────Y──
               
q[2]:──────────
               



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────Y─────────P(1.0472)──
                                 
q[2]:────────────*───────────────
                 |               
q[3]:────────────X───────────────
                                 



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────
                                            
q[2]:────────────────────────────────────*──
                                         |  
q[3]:────────────────────────────────────X──
                                            




julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L323-L393">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastSwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastSwapToCZGateTranspiler</code> transpiler stage which expands all Swap gates into <code>CZ</code> gates and single-qubit gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastSwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [swap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──☒──
       |
q[2]:──☒──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────
                |                     |                     |          
q[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──
                                              
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L429-L459">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastCXToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastCXToCZGateTranspiler</code> transpiler stage which expands all <code>CX</code> gates into <code>CZ</code> and <code>Hadamard</code> gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastCXToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──*──
       |
q[2]:──X──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:───────*───────
            |
q[2]:──H────Z────H──</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L493-L521">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastISwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastISwapToCZGateTranspiler</code> transpiler stage which expands all <code>ISwap</code> and <code>ISwapDagger</code> gates into <code>CZ</code> gates and single-qubit gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastISwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [iswap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──x──
       |
q[2]:──x──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────
                         |                     |                  
q[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──
                                                                  

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [iswap_dagger(1, 2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──x†──
       |   
q[2]:──x†──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Y_m90─────────────*────Y_m90────────────*────Y_90──────────
                         |                     |                  
q[2]:───────────X_m90────Z─────────────X_90────Z────────────X_90──
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L581-L627">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastToffoliToCXGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastToffoliToCXGateTranspiler</code> transpiler stage which expands all Toffoli gates into <code>CX</code> gates and single-qubit gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastToffoliToCXGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 3, instructions = [toffoli(1, 2, 3)])
Quantum Circuit Object:
   qubit_count: 3
   bit_count: 3
q[1]:──*──
       |
q[2]:──*──
       |
q[3]:──X──

julia&gt; transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──────────────────*────────────────────*──────────────*─────────T──────────*──
                       |                    |              |                    |  
q[2]:───────*──────────|─────────*──────────|────T─────────X──────────────T†────X──
            |          |         |          |                                      
q[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──────────────────
                                                                                   
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L683-L717">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastToPhaseShiftAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastToPhaseShiftAndHalfRotationXTranspiler</code> transpiler stage  which converts all single-qubit gates in an input circuit and converts them  into combinations of <code>PhaseShift</code> and <code>RotationX</code> with angle π/2 in an output  circuit. For any gate in the input circuit, the number of gates in the  output varies between zero and 5. The result of the input and output  circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastToPhaseShiftAndHalfRotationXTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z────X_90────Z────X_m90──
                                                 
q[2]:───────────────────────────
                                                 



julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Y──
          
q[2]:─────
          



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2
   bit_count: 2
q[1]:──X_90────Z────X_m90──

q[2]:──────────────────────
                                           



julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0., 0., 0.)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L831-L918">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastUniversalToRzRxRzTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastUniversalToRzRxRzTranspiler</code> transpiler stage  which finds <code>Universal</code> gates in an input circuit and casts  them into a sequence of <code>PhaseShift</code> (P), <code>RotationX</code> (Rx) and  <code>PhaseShift</code> (P) gates in a new circuit. The result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CastUniversalToRzRxRzTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, π/2, π/4, π/8)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──U(θ=1.5708,ϕ=0.7854,λ=0.3927)──
                                      
q[2]:─────────────────────────────────
                                      

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(-1.1781)────Rx(1.5708)────P(2.3562)──
                                              
q[2]:─────────────────────────────────────────
                                              

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0, π/4, 0)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.7854,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(-1.5708)────Rx(0.0000)────P(2.3562)──
                                              
q[2]:─────────────────────────────────────────
                                              

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L1012-L1069">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CastRxToRzAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastRxToRzAndHalfRotationXTranspiler</code> transpiler stage  which finds <code>RotationX(θ)</code> gates in an input circuit and converts (casts)  them into a sequence of gates: <code>Z90</code>,<code>X90</code>,<code>PhaseShift(θ)</code>,<code>XM90</code>,<code>ZM90</code> in a new circuit. The result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastRxToRzAndHalfRotationXTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1,π/8)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Rx(0.3927)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z_90────X_90────P(0.3927)────X_m90────Z_m90──
                                                    
q[2]:───────────────────────────────────────────────
                                                    

julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L1127-L1162">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::SimplifyRxGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyRxGatesTranspiler</code> transpiler stage  which finds <code>RotationX</code> gates in an input circuit and according to its  angle theta, casts them to one of the right-angle <code>RotationX</code> gates,  e.g., <code>SigmaX</code>, <code>X90</code>, or <code>XM90</code>. In the case where <code>theta≈0.</code>, the gate is removed. The result of the input and output circuit on any arbitrary state <code>Ket</code> is  unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = SimplifyRxGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Rx(1.5708)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, pi)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Rx(3.1416)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, 0.)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Rx(0.0000)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L1198-L1280">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::SwapQubitsForAdjacencyTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SwapQubitsForAdjacencyTranspiler</code> transpiler stage  which adds <code>Swap</code> gates around multi-qubit gates so that the  final <code>Operator</code> acts on adjacent qubits. The result of the input  and output circuit on any arbitrary state <code>Ket</code> is unchanged  (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = SwapQubitsForAdjacencyTranspiler(LineConnectivity(6));

julia&gt; circuit = QuantumCircuit(qubit_count = 6, instructions = [toffoli(4, 6, 1)])
Quantum Circuit Object:
   qubit_count: 6 
   bit_count: 6 
q[1]:──X──
       |  
q[2]:──|──
       |  
q[3]:──|──
       |  
q[4]:──*──
       |  
q[5]:──|──
       |  
q[6]:──*──
          




julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 6 
   bit_count: 6 
q[1]:───────────────────────────X───────────────────────────
                                |                           
q[2]:───────☒───────────────────*───────────────────☒───────
            |                   |                   |       
q[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──
       |                   |         |                   |  
q[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──
                      |                   |                 
q[5]:────────────☒────☒───────────────────☒────☒────────────
                 |                             |            
q[6]:────────────☒─────────────────────────────☒────────────
                                                            



julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L1384-L1440">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::SimplifyRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyRzGatesTranspiler</code> transpiler stage  which finds <code>PhaseShift</code> gates in an input circuit and according to its  phase angle phi, casts them to one of the right-angle <code>RotationZ</code> gates,  e.g., <code>SigmaZ</code>, <code>Z90</code>, <code>ZM90</code>, <code>Pi8</code> or <code>Pi8Dagger</code>. In the case where <code>phi≈0.</code>, the  gate is removed. The result of the input and output circuit on any  arbitrary state <code>Ket</code> is unchanged (up to a global phase). The tolerance  used for <code>Base.isapprox()</code> in each case can be set by passing an optional  argument to the <code>Transpiler</code>, e.g: <code>transpiler=SimplifyRzGatesTranspiler(1.0e-10)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = SimplifyRzGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(1.5708)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, pi)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(3.1416)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, 0.)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(0.0000)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L1500-L1583">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CompressRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CompressRzGatesTranspiler</code> transpiler stage  which gathers all Rz-type gates sharing a common target in an input  circuit and combines them into single PhaseShift gate in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CompressRzGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_z(1), z_90(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──Z────Z_90──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(-1.5708)──
                   
q[2]:──────────────
                   

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 3, instructions = [sigma_z(1), pi_8(1), control_x(2,3), z_minus_90(1)])
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──Z────T─────────Z_m90──
                             
q[2]:────────────*───────────
                 |           
q[3]:────────────X───────────
                             

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──P(2.3562)───────
                       
q[2]:───────────────*──
                    |  
q[3]:───────────────X──
                       

julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L1652-L1713">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::RemoveSwapBySwappingGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Removes the <code>Swap</code> gates from the <code>circuit</code> assuming all-to-all connectivity.</p><div class="admonition is-warning"><header class="admonition-header">The initial state must be the ground state!</header><div class="admonition-body"><p>This transpiler stage assumes that the input state is <span>$|0\rangle^{\otimes N}$</span> where <span>$N$</span> is the number of qubits. The stage should not be used on sub-circuits where the input state is not <span>$|0\rangle^{\otimes N}$</span>.</p></div></div><p>This transpiler stage eliminates <code>Swap</code> gates by moving the gates preceding each <code>Swap</code> gate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = RemoveSwapBySwappingGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [hadamard(1), swap(1, 2), sigma_x(2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────☒───────
            |       
q[2]:───────☒────X──
                    



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──────────
               
q[2]:──H────X──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L1730-L1770">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::SimplifyTrivialGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyTrivialGatesTranspiler</code> transpiler stage  which finds gates which have no effect on the state Ket, such as Identity, and  parameterized gates with null parameters such as rotation_x(target, 0.). The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyTrivialGatesTranspiler(1.0e-10)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = SimplifyTrivialGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [identity_gate(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──I──
          
q[2]:─────
          
julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit, transpiled_circuit)
true


julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, 0.)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──P(0.0000)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0., 0., 0.)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                             
julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit, transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L1858-L1934">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::ReadoutsAreFinalInstructionsTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Ensures that each <code>Readout</code> <code>Instruction</code> is the last operation  on each qubit where readouts are present, and that repeated readouts  on the same qubit do not occur, or throws an error.  It leaves the <code>QuantumCircuit</code> unchanged.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = ReadoutsAreFinalInstructionsTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1), sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲────X──
                    
q[2]:───────────────
                    

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
ERROR: AssertionError: Cannot perform `Gate` following `Readout` on qubit: 1
[...]

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [readout(1,1), readout(1,2)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──✲────✲──
               
q[2]:──────────
               

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
ERROR: AssertionError: Found multiple `Readouts` on qubit: 1
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L1976-L2032">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::CircuitContainsAReadoutTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Ensures that at least one <code>Readout</code> <code>Instruction</code> is  present on the <code>QuantumCircuit</code>,  or throws an error.  It leaves the <code>QuantumCircuit</code> unchanged.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = CircuitContainsAReadoutTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H──
          
q[2]:─────
          

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
ERROR: ArgumentError: QuantumCircuit is missing a `Readout`. Would not return any result.
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L2071-L2113">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::ReadoutsDoNotConflictTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Ensures that each <code>Readout</code> <code>Instruction</code> present on the <code>QuantumCircuit</code>  do not have conflicting destination bit, or throws an error.  It leaves the <code>QuantumCircuit</code> unchanged.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = ReadoutsDoNotConflictTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──H────✲──
               
q[2]:──────────
               

julia&gt; circuit = QuantumCircuit(qubit_count=2, instructions = [readout(1,1), readout(2,1)])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──✲───────
               
q[2]:───────✲──
               

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
ERROR: ArgumentError: `Readouts` in `QuantumCircuit` have conflicting destination bit: 1
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L2134-L2176">source</a></section><section><div><pre><code class="language-julia hljs">transpile(::DecomposeSingleTargetSingleControlGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>DecomposeSingleTargetSingleControlGatesTranspiler</code> transpiler stage  which finds single-control, single-target <code>Controlled</code> gates in an input circuit and casts  them into a sequence of <code>RotationZ</code> (Rz), <code>ControlX</code>, <code>Universal</code> (U) and <code>PhaseShift</code> (P)  gates in a new, equivalent circuit. For reference, see Nielsen and Chuang, &quot;Quantum Computation and Quantum Information&quot;, p180. The result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If a global phase is applied by the kernel of the <code>Controlled</code> gate on the target  qubit, this decomposition preserves it.</p></div></div><p>For instance, a rotation<em>z(pi) kernel and a phase</em>shift(pi) will yield results with a phase offset.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = DecomposeSingleTargetSingleControlGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1), controlled(rotation_z(2, pi), [1])])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X────────*───────
                |       
q[2]:───────Rz(3.1416)──
                        
julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X───────────────────*──────────────────────────────────────*───────────────────────────────────
                           |                                      |                                   
q[2]:───────Rz(-1.5708)────X────U(θ=0.0000,ϕ=-1.5708,λ=0.0000)────X────U(θ=0.0000,ϕ=3.1416,λ=0.0000)──
                                                                                                      
julia&gt; compare_circuits(circuit, transpiled_circuit)
true

julia&gt; simulate(transpiled_circuit)
4-element Ket{ComplexF64}:
0.0 + 0.0im
-0.0 + 0.0im
0.7071067811865477 - 0.7071067811865474im
0.0 + 0.0im

julia&gt; circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1), controlled(phase_shift(2, pi), [1])])
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X────────*──────
                |      
q[2]:───────P(3.1416)──
                       

julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
   bit_count: 2 
q[1]:──X───────────────────*──────────────────────────────────────*─────────────────────────────────────P(1.5708)──
                           |                                      |                                                
q[2]:───────Rz(-1.5708)────X────U(θ=0.0000,ϕ=-1.5708,λ=0.0000)────X────U(θ=0.0000,ϕ=3.1416,λ=0.0000)───────────────
                                                                                                                   

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; simulate(circuit)
4-element Ket{ComplexF64}:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/transpile.jl#L2205-L2279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.compare_circuits" href="#Snowflurry.compare_circuits"><code>Snowflurry.compare_circuits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_circuits(c0::QuantumCircuit, c1::QuantumCircuit)::Bool</code></pre><p>Tests for equivalence of two <a href="quantum_circuit.html#Snowflurry.QuantumCircuit"><code>QuantumCircuit</code></a> based on their effect on an  arbitrary input state (a Ket). <code>QuantumCircuit</code> are equivalent if they both  yield the same output for any input, up to a global phase. <code>QuantumCircuit</code> with different ordering of gates that apply on different  targets can also be equivalent. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If there are <code>Readouts</code> are present on either <code>QuantumCircuit</code>,  <code>compare_circuits</code> checks that both circuits have readouts targeting the same qubits, and that no operations exist on those qubits following readouts.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c0 = QuantumCircuit(qubit_count = 1, instructions = [sigma_x(1), sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
   bit_count: 1 
q[1]:──X────Y──
               



julia&gt; c1 = QuantumCircuit(qubit_count = 1, instructions = [phase_shift(1, π)])
Quantum Circuit Object:
   qubit_count: 1  
   bit_count: 1  
q[1]:──P(3.1416)──
                  



julia&gt; compare_circuits(c0, c1)
true            

julia&gt; c0 = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1), sigma_y(1), control_x(2, 3)])
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────Y───────
                    
q[2]:────────────*──
                 |  
q[3]:────────────X──
                    



julia&gt; c1 = QuantumCircuit(qubit_count = 3, instructions = [control_x(2, 3), sigma_x(1), sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:───────X────Y──
                    
q[2]:──*────────────
       |            
q[3]:──X────────────
                    



julia&gt; compare_circuits(c0, c1)
true    

julia&gt; c2 = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1), readout(1, 1)])
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────✲──
               
q[2]:──────────
               
q[3]:──────────
               
julia&gt; c3 = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X──
          
q[2]:─────
          
q[3]:─────
          

julia&gt; compare_circuits(c2,c3)
false    
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L314-L406">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.circuit_contains_gate_type" href="#Snowflurry.circuit_contains_gate_type"><code>Snowflurry.circuit_contains_gate_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circuit_contains_gate_type(circuit::QuantumCircuit, gate_type::Type{&lt;: AbstractGateSymbol})::Bool</code></pre><p>Determines whether a type of gate is present in a circuit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count = 1, instructions = [sigma_x(1), sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
   bit_count: 1 
q[1]:──X────Y──
               
julia&gt; circuit_contains_gate_type(circuit, Snowflurry.SigmaX)
true
               
julia&gt; circuit_contains_gate_type(circuit, Snowflurry.ControlZ)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L460-L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.permute_qubits!" href="#Snowflurry.permute_qubits!"><code>Snowflurry.permute_qubits!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permute_qubits!(circuit::QuantumCircuit,
    qubit_mapping::AbstractDict{T,T}) where T&lt;:Integer</code></pre><p>Modifies a <code>circuit</code> by moving the gates to other qubits based on a <code>qubit_mapping</code>.</p><p>The dictionary <code>qubit_mapping</code> contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.</p><p>For instance, <code>Dict(1 =&gt; 2)</code> is not a valid <code>qubit_mapping</code>, but <code>Dict(1 =&gt; 2, 2 =&gt; 1)</code> is valid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 3);

julia&gt; push!(c, sigma_x(1), hadamard(2), sigma_y(3))
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────────────
                    
q[2]:───────H───────
                    
q[3]:────────────Y──                    



julia&gt; permute_qubits!(c, Dict(1 =&gt; 3, 3 =&gt; 1))

julia&gt; show(c)
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:────────────Y──
                    
q[2]:───────H───────
                    
q[3]:──X────────────
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L1388-L1431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Snowflurry.permute_qubits" href="#Snowflurry.permute_qubits"><code>Snowflurry.permute_qubits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permute_qubits(circuit::QuantumCircuit,
    qubit_mapping::AbstractDict{T,T})::QuantumCircuit where {T&lt;:Integer}</code></pre><p>Returns a <code>QuantumCircuit</code> that is a copy of <code>circuit</code> but where the gates have been moved to other qubits based on a <code>qubit_mapping</code>.</p><p>The dictionary <code>qubit_mapping</code> contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.</p><p>For instance, <code>Dict(1=&gt;2)</code> is not a valid <code>qubit_mapping</code>, but <code>Dict(1=&gt;2, 2=&gt;1)</code> is valid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 3);

julia&gt; push!(c, sigma_x(1), hadamard(2), sigma_y(3))
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:──X────────────
                    
q[2]:───────H───────
                    
q[3]:────────────Y──
                    



julia&gt; permute_qubits(c, Dict(1 =&gt; 3, 3 =&gt; 1))
Quantum Circuit Object:
   qubit_count: 3 
   bit_count: 3 
q[1]:────────────Y──
                    
q[2]:───────H───────
                    
q[3]:──X────────────
                    


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SnowflurrySDK/Snowflurry.jl/blob/606bb5c4fb967ac6b197c2699fc3da0f6ae2c06f/src/core/quantum_circuit.jl#L1472-L1516">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="quantum_gates.html">« Quantum Gates</a><a class="docs-footer-nextpage" href="qpu.html">QPU »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 11 June 2024 18:18">Tuesday 11 June 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
