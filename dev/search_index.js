var documenterSearchIndex = {"docs":
[{"location":"library.html#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"DocTestSetup = :(using Snowflake, SnowflakePlots)","category":"page"},{"location":"library.html#Quantum-Circuit","page":"Library","title":"Quantum Circuit","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"QuantumCircuit\npush!\npop!\nsimulate\nsimulate_shots\nget_measurement_probabilities(circuit::QuantumCircuit)\ninv(circuit::QuantumCircuit)\nget_num_gates_per_type\nget_num_gates\nserialize_job\ntranspile\ncompare_circuits\ncircuit_contains_gate_type","category":"page"},{"location":"library.html#Snowflake.QuantumCircuit","page":"Library","title":"Snowflake.QuantumCircuit","text":"QuantumCircuit(qubit_count)\n\nA data structure to represent a quantum circuit.  \n\nFields\n\nqubit_count::Int – number of qubits (i.e. quantum register size).\ngates::Array{Array{Gate}} – the sequence of gates to operate on qubits.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n\n\n\n\n\n","category":"type"},{"location":"library.html#Base.push!","page":"Library","title":"Base.push!","text":"push!(circuit::QuantumCircuit, gate::AbstractGate)\npush!(circuit::QuantumCircuit, gates::Array{AbstractGate})\n\nPushes a single gate or an array of gates to the circuit gates. This function is mutable. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, [hadamard(1),sigma_x(2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.pop!","page":"Library","title":"Base.pop!","text":"pop!(circuit::QuantumCircuit)\n\nRemoves the last gate from circuit.gates. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, [hadamard(1),sigma_x(2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> pop!(c)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.simulate","page":"Library","title":"Snowflake.simulate","text":"simulate(circuit::QuantumCircuit)\n\nSimulates and returns the wavefunction of the quantum device after running circuit. \n\nEmploys the approach described in Listing 5 of Suzuki et. al. (2021).\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> ket = simulate(c)\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.simulate_shots","page":"Library","title":"Snowflake.simulate_shots","text":"simulate_shots(c::QuantumCircuit, shots_count::Int = 100)\n\nEmulates a quantum computer by running a circuit for a given number of shots and returning measurement results.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> simulate_shots(c, 99)\n99-element Vector{String}:\n \"11\"\n \"00\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"00\"\n \"00\"\n \"11\"\n ⋮\n \"00\"\n \"00\"\n \"11\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_measurement_probabilities-Tuple{QuantumCircuit}","page":"Library","title":"Snowflake.get_measurement_probabilities","text":"get_measurement_probabilities(circuit::QuantumCircuit,\n    [target_qubits::Vector{<:Integer}])::AbstractVector{<:Real}\n\nReturns a vector listing the measurement probabilities for the target_qubits in the circuit.\n\nIf no target_qubits are provided, the probabilities are computed for all the qubits.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit QuantumCircuit, the probabilities are listed for 00, 01, 10, and 11.\n\nExamples\n\nThe following example constructs a QuantumCircuit where the probability of measuring 01 is 50% and the probability of measuring 11 is also 50%.\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, [hadamard(1), sigma_x(2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> get_measurement_probabilities(circuit)\n4-element Vector{Float64}:\n 0.0\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n\n\nFor the same circuit, the probability of measuring qubit 2 and finding 1 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(circuit, target_qubit)\n2-element Vector{Float64}:\n 0.0\n 0.9999999999999998\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Base.inv-Tuple{QuantumCircuit}","page":"Library","title":"Base.inv","text":"inv(circuit::QuantumCircuit)\n\nReturn a QuantumCircuit which is the inverse of the input circuit.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, rotation_y(1, pi/4));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Ry(0.7854)────*──\n                     |  \nq[2]:────────────────X──\n                        \n\n\n\njulia> inv(c)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*────Ry(-0.7854)──\n       |                 \nq[2]:──X─────────────────\n                         \n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_gates_per_type","page":"Library","title":"Snowflake.get_num_gates_per_type","text":"get_num_gates_per_type(circuit::QuantumCircuit)::AbstractDict{<:AbstractString, <:Integer}\n\nReturns a dictionary listing the number of gates of each type found in the circuit.\n\nThe dictionary keys are the instruction_symbol of the gates while the values are the number of gates found.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, [hadamard(1), hadamard(2)]);\n\njulia> push!(c, control_x(1, 2));\n\njulia> push!(c, hadamard(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*───────\n                 |       \nq[2]:───────H────X────H──\n                         \n\n\n\njulia> get_num_gates_per_type(c)\nDict{String, Int64} with 2 entries:\n  \"h\"  => 3\n  \"cx\" => 1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_gates","page":"Library","title":"Snowflake.get_num_gates","text":"get_num_gates(circuit::QuantumCircuit)::Integer\n\nReturns the number of gates in the circuit.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, [hadamard(1), hadamard(2)]);\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────H────X──\n                    \n\n\n\njulia> get_num_gates(c)\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.serialize_job","page":"Library","title":"Snowflake.serialize_job","text":"serialize_job(circuit::QuantumCircuit,repetitions::Integer)\n\nCreates a JSON-formatted String containing the circuit configuration to be sent  to a QPU service, along with the number of repetitions requested.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2,gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> serialize_job(c,10)\n\"{\\\"num_repititions\\\":10,\\\"circuit\\\":{\\\"operations\\\":[{\\\"parameters\\\":{},\\\"type\\\":\\\"x\\\",\\\"qubits\\\":[0]}]}}\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.transpile","page":"Library","title":"Snowflake.transpile","text":"transpile(::CompressSingleQubitGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CompressSingleQubitGatesTranspiler transpiler stage  which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single universal gates in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=Snowflake.CompressSingleQubitGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────Y──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y─────────P(1.0472)──\n                                 \nq[2]:────────────*───────────────\n                 |               \nq[3]:────────────X───────────────\n                                 \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────\n                                            \nq[2]:────────────────────────────────────*──\n                                         |  \nq[3]:────────────────────────────────────X──\n                                            \n\n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastSwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastSwapToCZGateTranspiler transpiler stage which expands all Swap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=Snowflake.CastSwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[swap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──☒──\n       |\nq[2]:──☒──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────\n                |                     |                     |          \nq[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──\n                                              \n\n\n\n\n\n\ntranspile(::CastCXToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastCZToCZGateTranspiler transpiler stage which expands all CX gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=Snowflake.CastCXToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──*──\n       |\nq[2]:──X──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:───────*───────\n            |\nq[2]:──H────Z────H──\n\n\n\n\n\ntranspile(::CastISwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastISwapToCZGateTranspiler transpiler stage which expands all ISwap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=Snowflake.CastISwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[iswap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──x──\n       |\nq[2]:──x──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────\n                         |                     |                  \nq[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──\n                                                                  \n\n\n\n\n\n\ntranspile(::CastToffoliToCXGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastToffoliToCXGateTranspiler transpiler stage which expands all Toffoli gates into CX gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\n```jldoctest julia> transpiler=Snowflake.CastToffoliToCXGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubitcount = 3, gates=[toffoli(1, 2, 3)]) Quantum Circuit Object:    qubitcount: 3 q[1]:────        | q[2]:────        | q[3]:──X──\n\njulia> transpile(transpiler,circuit) Quantum Circuit Object:    qubit_count: 3 Part 1 of 2 q[1]:───────────────────────────────────────────────────────────                        |                    |              | q[2]:─────────────────|─────────*──────────|────T─────────X───────             |          |         |          | q[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──\n\nPart 2 of 2 q[1]:──T──────────*──                   | q[2]:───────T†────X──\n\nq[3]:────────────────```\n\n\n\n\n\ntranspile(::CastToPhaseShiftAndHalfRotationX, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastToPhaseShiftAndHalfRotationX transpiler stage  which converts all single-qubit gates in an input circuit and converts them  into combinations of PhaseShift and RotationX with angle π/2 in an output  circuit. For any gate in the input circuit, the number of gates in the  output varies between zero and 5. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=Snowflake.CastToPhaseShiftAndHalfRotationX();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────X_90────Z────X_m90──\n                                                 \nq[2]:───────────────────────────\n                                                 \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Y──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90────X_90────Z────X_m90────Z_90──\n                                           \nq[2]:──────────────────────────────────────\n                                           \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::PlaceOperationsOnLine, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the PlaceOperationsOnLine transpiler stage  which adds Swap gates around multi-qubit gates so that the  final operator acts on adjacent qubits. The result of the input  and output circuit on any arbitrary state Ket is unchanged  (up to a global phase).\n\nExamples\n\njulia> transpiler=Snowflake.PlaceOperationsOnLine();\n\njulia> circuit = QuantumCircuit(qubit_count = 6, gates=[toffoli(4,6,1)])\nQuantum Circuit Object:\n   qubit_count: 6 \nq[1]:──X──\n       |  \nq[2]:──|──\n       |  \nq[3]:──|──\n       |  \nq[4]:──*──\n       |  \nq[5]:──|──\n       |  \nq[6]:──*──\n          \n\n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 6 \nq[1]:───────────────────────────X───────────────────────────\n                                |                           \nq[2]:───────☒───────────────────*───────────────────☒───────\n            |                   |                   |       \nq[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──\n       |                   |         |                   |  \nq[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──\n                      |                   |                 \nq[5]:────────────☒────☒───────────────────☒────☒────────────\n                 |                             |            \nq[6]:────────────☒─────────────────────────────☒────────────\n                                                            \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.compare_circuits","page":"Library","title":"Snowflake.compare_circuits","text":"compare_circuits(c0::QuantumCircuit,c1::QuantumCircuit)::Bool\n\nTests for equivalence of two circuits based on their effect on an  arbitrary input state (a Ket). Circuits are equivalent if they both  yield the same output for any input, up to a global phase. Circuits with different ordering of gates that apply on different  targets can also be equivalent.\n\nExamples\n\njulia> c0 = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Y──\n               \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 1, gates=[phase_shift(1,π)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──P(3.1416)──\n                  \n\n\n\njulia> compare_circuits(c0,c1)\ntrue            \n\njulia> c0 = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y───────\n                    \nq[2]:────────────*──\n                 |  \nq[3]:────────────X──\n                    \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 3, gates=[control_x(2,3),sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:───────X────Y──\n                    \nq[2]:──*────────────\n       |            \nq[3]:──X────────────\n                    \n\n\n\njulia> compare_circuits(c0,c1)\ntrue    \n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.circuit_contains_gate_type","page":"Library","title":"Snowflake.circuit_contains_gate_type","text":"circuit_contains_gate_type(circuit::QuantumCircuit, gate_type::Type{<:AbstractGate})::Bool\n\nDetermined whether or not a type of gate is present in a circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Y──\n               \njulia> circuit_contains_gate_type(circuit, Snowflake.SigmaX)\ntrue\n               \njulia> circuit_contains_gate_type(circuit, Snowflake.ControlZ)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"library.html#Quantum-Gates","page":"Library","title":"Quantum Gates","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"AbstractGate\neye\nsigma_p\nsigma_m\nsigma_x\nsigma_y\nsigma_z\nhadamard\nphase\nphase_dagger\npi_8\npi_8_dagger\nx_90\nx_minus_90\ny_90\ny_minus_90\nz_90\nz_minus_90\nrotation\nrotation_x\nrotation_y\nphase_shift\nuniversal\ncontrol_z\ncontrol_x\niswap\nswap\ntoffoli\niswap_dagger\nBase.:*(M::AbstractGate, x::Ket)\napply_gate!\nget_operator\ninv(gate::AbstractGate)","category":"page"},{"location":"library.html#Snowflake.AbstractGate","page":"Library","title":"Snowflake.AbstractGate","text":"AbstractGate\n\nA Gate is an instantiation of an AbstractGate, which can be added to a QuantumCircuit in order to apply an operator to one or more target qubits. AbstractGate is useful to dispatch all Gates to default implementation of functions such as getconnectedqubits().  Those functions are then specialized for Gates requiring a different implementation. \n\nAbstractGate is an abstract type, which means that it cannot be instantiated.  Instead, each concrete type of Gate is a struct which is a subtype of AbstractGate. Each descendant of AbstractGate must have at least the following fields:\n\ntarget::Int: the qubit number to which the Gate is applied. Some gates have multiple targets.\nparameter::Real: for parameterized gates, determines which operation is applied (e.g. rotation angles), i.e., is used in the construction of the matrix used in the application of its Operator.\n\nExamples\n\nA struct must be defined for each new gate type, such as the following X_45 gate which applies a 45° rotation about the X axis:\n\njulia> struct X45 <: AbstractGate\n           target::Int\n       end;\n\n\nFor convenience, a constructor can be defined:\n\njulia> x_45(target::Integer) = X45(target);\n\n\nTo simulate the effect of the gate in a QuantumCircuit or when applied to a Ket, the function get_operator must be extended.\n\njulia> Snowflake.get_operator(gate::X45, T::Type{<:Complex}=ComplexF64) = rotation_x(π/4, T);\n\n\nThe gate inverse can also be specified by extending the inv function.\n\njulia> inv(gate::X45) = rotation_x(gate.target, -π/4);\n\n\nAn instance of the X_45 gate can now be created:\n\njulia> x_45_gate = x_45(1)\nGate Object: X45\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im\n0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\njulia> inv(x_45_gate)\nGate Object: Snowflake.RotationX\nParameters: \ntheta\t: -0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    -0.0 + 0.3826834323650898im\n-0.0 + 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.eye","page":"Library","title":"Snowflake.eye","text":"eye()\n\nReturn the identity Operator, which is defined as:\n\nI = beginbmatrix\n    1  0 \n    0  1\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_p","page":"Library","title":"Snowflake.sigma_p","text":"sigma_p()\n\nReturn the spin-frac12 raising Operator, which is defined as:\n\nsigma_+ = beginbmatrix\n    0  1 \n    0  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_m","page":"Library","title":"Snowflake.sigma_m","text":"sigma_m()\n\nReturn the spin-frac12 lowering Operator, which is defined as:\n\nsigma_- = beginbmatrix\n    0  0 \n    1  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_x","page":"Library","title":"Snowflake.sigma_x","text":"sigma_x()\n\nReturn the Pauli-X AntiDiagonalOperator, which is defined as:\n\nsigma_x = beginbmatrix\n    0  1 \n    1  0\n    endbmatrix\n\n\n\n\n\nsigma_x(target)\n\nReturn the Pauli-X Gate, which applies the sigma_x() AntiDiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_y","page":"Library","title":"Snowflake.sigma_y","text":"sigma_y()\n\nReturn the Pauli-Y Operator, which is defined as:\n\nsigma_y = beginbmatrix\n    0  -i \n    i  0\n    endbmatrix\n\n\n\n\n\nsigma_y(target)\n\nReturn the Pauli-Y Gate, which applies the sigma_y() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_z","page":"Library","title":"Snowflake.sigma_z","text":"sigma_z()\n\nReturn the Pauli-Z Operator, which is defined as:\n\nsigma_z = beginbmatrix\n    1  0 \n    0  -1\n    endbmatrix\n\n\n\n\n\nsigma_z(target)\n\nReturn the Pauli-Z Gate, which applies the sigma_z() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.hadamard","page":"Library","title":"Snowflake.hadamard","text":"hadamard()\n\nReturn the Hadamard Operator, which is defined as:\n\nH = frac1sqrt2beginbmatrix\n    1  1 \n    1  -1\n    endbmatrix\n\n\n\n\n\nhadamard(target)\n\nReturn the Hadamard Gate, which applies the hadamard() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.phase","page":"Library","title":"Snowflake.phase","text":"phase()\n\nReturn the phase gate Operator, which is defined as:\n\nS = beginbmatrix\n    1  0 \n    0  i\n    endbmatrix\n\n\n\n\n\nphase(target)\n\nReturn a phase Gate (also known as an S Gate), which applies the phase() DiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.phase_dagger","page":"Library","title":"Snowflake.phase_dagger","text":"phase_dagger()\n\nReturn the adjoint phase gate Operator, which is defined as:\n\nS^dagger = beginbmatrix\n    1  0 \n    0  -i\n    endbmatrix\n\n\n\n\n\nphase_dagger(target)\n\nReturn an adjoint phase Gate (also known as an S^dagger Gate), which applies the phase_dagger() DiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.pi_8","page":"Library","title":"Snowflake.pi_8","text":"pi_8()\n\nReturn the Operator for the π/8 gate, which is defined as:\n\nT = beginbmatrix\n    1  0 \n    0  e^ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8(target)\n\nReturn a π/8 Gate (also known as a T Gate), which applies the pi_8() DiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.pi_8_dagger","page":"Library","title":"Snowflake.pi_8_dagger","text":"pi_8_dagger()\n\nReturn the adjoint DiagonalOperator of the π/8 gate, which is defined as:\n\nT^dagger = beginbmatrix\n    1  0 \n    0  e^-ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8_dagger(target)\n\nReturn an adjoint π/8 Gate (also known as a T^dagger Gate), which applies the pi_8_dagger() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.x_90","page":"Library","title":"Snowflake.x_90","text":"x_90()\n\nReturn the Operator which applies a π/2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -i \n    -i  1\n    endbmatrix\n\n\n\n\n\nx_90(target)\n\nReturn a Gate that applies a 90° rotation about the X axis as defined by the x_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.x_minus_90","page":"Library","title":"Snowflake.x_minus_90","text":"x_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  i \n    i  1\n    endbmatrix\n\n\n\n\n\nx_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the X axis as defined by the x_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.y_90","page":"Library","title":"Snowflake.y_90","text":"y_90()\n\nReturn the Operator which applies a π/2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -1 \n    1  1\n    endbmatrix\n\n\n\n\n\ny_90(target)\n\nReturn a Gate that applies a 90° rotation about the Y axis as defined by the y_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.y_minus_90","page":"Library","title":"Snowflake.y_minus_90","text":"y_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  1 \n    -1  1\n    endbmatrix\n\n\n\n\n\ny_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the Y axis as defined by the y_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.z_90","page":"Library","title":"Snowflake.z_90","text":"z_90()\n\nReturn the Operator which applies a π/2 rotation about the Z axis.\n\nThe Operator is defined as:\n\nR_zleft(fracpi2right) = beginbmatrix\n    1  0 \n    0  i\n    endbmatrix\n\n\n\n\n\nz_90(target)\n\nReturn a Gate that applies a 90° rotation about the Z axis as defined by the z_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.z_minus_90","page":"Library","title":"Snowflake.z_minus_90","text":"z_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the Z axis.\n\nThe Operator is defined as:\n\nR_zleft(-fracpi2right) = beginbmatrix\n    1  0 \n    0  -i\n    endbmatrix\n\n\n\n\n\nz_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the Z axis as defined by the z_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation","page":"Library","title":"Snowflake.rotation","text":"rotation(theta, phi)\n\nReturn the Operator which applies a rotation theta about the cos(phi)X+sin(phi)Y axis.\n\nThe Operator is defined as:\n\nR(theta phi) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -i e^-iphi mathrmsinleft(fractheta2right) 05em      \n    -i e^iphi mathrmsinleft(fractheta2right) \n        mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation(target, theta, phi)\n\nReturn a gate that applies a rotation theta to the target qubit about the cos(phi)X+sin(phi)Y axis.\n\nThe corresponding Operator is rotation(theta, phi).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation_x","page":"Library","title":"Snowflake.rotation_x","text":"rotation_x(theta)\n\nReturn the Operator which applies a rotation theta about the X axis.\n\nThe Operator is defined as:\n\nR_x(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -imathrmsinleft(fractheta2right) 05em      \n-imathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_x(target, theta)\n\nReturn a Gate that applies a rotation theta about the X axis of the target qubit.\n\nThe corresponding Operator is rotation_x(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation_y","page":"Library","title":"Snowflake.rotation_y","text":"rotation_y(theta)\n\nReturn the Operator that applies a rotation theta about the Y axis of the target qubit.\n\nThe Operator is defined as:\n\nR_y(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -mathrmsinleft(fractheta2right) 05em      \nmathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_y(target, theta)\n\nReturn a Gate that applies a rotation theta about the Y axis of the target qubit.\n\nThe corresponding Operator is rotation_y(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.phase_shift","page":"Library","title":"Snowflake.phase_shift","text":"phase_shift(target, phi)\n\nReturn a Gate that applies a phase shift phi to the target qubit as defined by the phase_shift(phi) DiagonalOperator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.universal","page":"Library","title":"Snowflake.universal","text":"universal(theta, phi, lambda)\n\nReturn the Operator which performs a rotation about the angles theta, phi, and lambda. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU\n\nThe Operator is defined as:\n\nU(theta phi lambda) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -e^ilambdamathrmsinleft(fractheta2right) 05em      \n    e^iphimathrmsinleft(fractheta2right) \n        e^ileft(phi+lambdaright)mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nuniversal(target, theta, phi, lambda)\n\nReturn a gate which rotates the target qubit given the angles theta, phi, and lambda. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU\n\nThe corresponding Operator is universal(theta, phi, lambda).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.control_z","page":"Library","title":"Snowflake.control_z","text":"control_z()\n\nReturn the controlled-Z Operator, which is defined as:\n\nCZ = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\n    endbmatrix\n\n\n\n\n\ncontrol_z(control_qubit, target_qubit)\n\nReturn a controlled-Z gate given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_z().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.control_x","page":"Library","title":"Snowflake.control_x","text":"control_x()\n\nReturn the controlled-X (or controlled NOT) Operator, which is defined as:\n\nCX = CNOT = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endbmatrix\n\n\n\n\n\ncontrol_x(control_qubit, target_qubit)\n\nReturn a controlled-X gate (also known as a controlled NOT gate) given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_x().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.iswap","page":"Library","title":"Snowflake.iswap","text":"iswap()\n\nReturn the imaginary swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap(qubit_1, qubit_2)\n\nReturn the imaginary swap Gate which applies the imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.swap","page":"Library","title":"Snowflake.swap","text":"swap()\n\nReturn the swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\nswap(qubit_1, qubit_2)\n\nReturn the swap Gate which applies the swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is swap().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.toffoli","page":"Library","title":"Snowflake.toffoli","text":"toffoli()\n\nReturn the Toffoli Operator, which is defined as:\n\nCCX = CCNOT = beginbmatrix\n    1  0  0  0  0  0  0  0 \n    0  1  0  0  0  0  0  0 \n    0  0  1  0  0  0  0  0 \n    0  0  0  1  0  0  0  0 \n    0  0  0  0  1  0  0  0 \n    0  0  0  0  0  1  0  0 \n    0  0  0  0  0  0  0  1 \n    0  0  0  0  0  0  1  0\n    endbmatrix\n\n\n\n\n\ntoffoli(control_qubit_1, control_qubit_2, target_qubit)\n\nReturn a Toffoli gate (also known as a CCNOT gate) given two control qubits and a target_qubit.\n\nThe corresponding Operator is toffoli().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.iswap_dagger","page":"Library","title":"Snowflake.iswap_dagger","text":"iswap_dagger()\n\nReturn the adjoint of the imaginary swap Operator, which is defined as:\n\niSWAP^dagger = beginbmatrix\n    1  0  0  0 \n    0  0  -i  0 \n    0  -i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap_dagger(qubit_1, qubit_2)\n\nReturn the adjoint imaginary swap Gate which applies the adjoint imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap_dagger().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.:*-Tuple{AbstractGate, Ket}","page":"Library","title":"Base.:*","text":"Base.:*(M::AbstractGate, x::Ket)\n\nReturn a Ket which results from applying Gate M to Ket x.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_1 = sigma_x(1)*ψ_0\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.apply_gate!","page":"Library","title":"Snowflake.apply_gate!","text":"apply_gate!(state::Ket, gate::Gate)\n\nUpdate the state by applying a gate to it.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> apply_gate!(ψ_0, sigma_x(1))\n\njulia> print(ψ_0)\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_operator","page":"Library","title":"Snowflake.get_operator","text":"get_operator(gate::Gate)\n\nReturns the Operator which is associated to a Gate.\n\nExamples\n\njulia> x = sigma_x(1);\n\njulia> get_operator(x)\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.inv-Tuple{AbstractGate}","page":"Library","title":"Base.inv","text":"inv(gate::AbstractGate)\n\nReturn a Gate which is the inverse of the input gate.\n\nExamples\n\njulia> u = universal(1, -pi/2, pi/3, pi/4)\nGate Object: Snowflake.Universal\nParameters: \ntheta\t: -1.5707963267948966\nphi\t: 1.0471975511965976\nlambda\t: 0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.5 + 0.4999999999999999im\n-0.3535533905932738 - 0.6123724356957945im    -0.18301270189221924 + 0.6830127018922194im\n\n\njulia> inv(u)\nGate Object: Snowflake.Universal\nParameters: \ntheta\t: 1.5707963267948966\nphi\t: -0.7853981633974483\nlambda\t: -1.0471975511965976\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    -0.3535533905932738 + 0.6123724356957945im\n0.5 - 0.4999999999999999im    -0.18301270189221924 - 0.6830127018922194im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Quantum-Processing-Unit","page":"Library","title":"Quantum Processing Unit","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"AnyonQPU\nVirtualQPU\nClient\nget_host\nsubmit_circuit\nget_status\nget_result\nrun_job\nget_transpiler\nSequentialTranspiler","category":"page"},{"location":"library.html#Snowflake.AnyonQPU","page":"Library","title":"Snowflake.AnyonQPU","text":"AnyonQPU\n\nA data structure to represent a Anyon System's QPU.  \n\nFields\n\nclient       ::Client – Client to the QPU server.\n\nExample\n\njulia> c = Client(host=\"http://example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\");\n  \njulia> qpu=AnyonQPU(c)\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon \n   serial_number: ANYK202201 \n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.VirtualQPU","page":"Library","title":"Snowflake.VirtualQPU","text":"VirtualQPU\n\nA data structure to represent a Quantum Simulator.  \n\nExample\n\njulia> qpu=VirtualQPU()\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflake.jl\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.Client","page":"Library","title":"Snowflake.Client","text":"Client\n\nA data structure to represent a Client to a QPU service.  \n\nFields\n\nhost::String – URL of the QPU server.\nuser::String – Username.\naccess_token::String – User access token.\n\nExample\n\njulia> c = Client(host=\"http://example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\")\nClient for QPU service:\n   host:         http://example.anyonsys.com\n   user:         test_user \n \n  \n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.get_host","page":"Library","title":"Snowflake.get_host","text":"get_host(Client)\n\nReturns host URL of a Client to a QPU service.  \n\nExample\n\njulia> c = Client(host=\"http://example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\");\n\njulia> get_host(c)\n\"http://example.anyonsys.com\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.submit_circuit","page":"Library","title":"Snowflake.submit_circuit","text":"submit_circuit(client::Client,circuit::QuantumCircuit,num_repetitions::Integer)\n\nSubmit a circuit to a Client of QPU service, requesting a number of  repetitions (num_repetitions). Returns circuitID.  \n\nExample\n\njulia> submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_status","page":"Library","title":"Snowflake.get_status","text":"get_status(client::Client,circuitID::String)::Dict{String, String}\n\nObtain the status of a circuit computation through a Client of a QPU service. Returns status::Dict containing status[\"type\"]:      -\"queued\"   : Computation in queue.     -\"running\"  : Computation being processed.     -\"failed\"   : QPU service has returned an error message.     -\"succeeded\": Computation is completed, result is available.\n\nIn the case of status[\"type\"]==\"failed\", the server error is contained in status[\"message\"].\n\nExample\n\njulia> circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\njulia> get_status(client,circuitID)\nStatus: succeeded\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_result","page":"Library","title":"Snowflake.get_result","text":"get_result(client::Client,circuit::String)::Dict{String, Int}\n\nGet the histogram of a completed circuit calculation, through a Client of a QPU service,  by circuit identifier circuitID.\n\nExample\n\njulia> circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\njulia> get_status(client,circuitID);\n\njulia> get_result(client,circuitID)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.run_job","page":"Library","title":"Snowflake.run_job","text":"run_job(qpu::VirtualQPU, circuit::QuantumCircuit,num_repetitions::Integer)\n\nRun a circuit computation on a QPU simulator, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations.\n\nExample\n\njulia> qpu=VirtualQPU();\n\njulia> run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\nrun_job(qpu::AnyonQPU, circuit::QuantumCircuit,num_repetitions::Integer)\n\nRun a circuit computation on a QPU service, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=AnyonQPU(client);\n\njulia> run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_transpiler","page":"Library","title":"Snowflake.get_transpiler","text":"get_transpiler(qpu::AnyonQPU)::Transpiler\n\nReturns the transpiler associated with this QPU.\n\nExample\n\njulia> qpu=AnyonQPU(client);\n\njulia> get_transpiler(qpu)\nSequentialTranspiler(Transpiler[CastToffoliToCXGateTranspiler(), CastSwapToCZGateTranspiler(), CastCXToCZGateTranspiler(), CastISwapToCZGateTranspiler(), CompressSingleQubitGatesTranspiler(), CastToPhaseShiftAndHalfRotationX(1.0e-6), PlaceOperationsOnLine()])\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.SequentialTranspiler","page":"Library","title":"Snowflake.SequentialTranspiler","text":"SequentialTranspiler(Vector{<:Transpiler})\n\nComposite transpiler object which is constructed from an array  of Transpiler stages. Calling      transpile(::SequentialTranspiler,::QuantumCircuit)` will apply each stage in sequence to the input circuit, and return a transpiled output circuit. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=Snowflake.SequentialTranspiler([Snowflake.CompressSingleQubitGatesTranspiler(),Snowflake.CastToPhaseShiftAndHalfRotationX()]);\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),hadamard(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────H──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────X_90────Z_90────X_m90────Z──\n                                                              \nq[2]:───────────────────────────────────\n                                                              \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y─────────P(1.0472)──  \n\nq[2]:────────────*───────────────\n                 |               \nq[3]:────────────X───────────────\n                                 \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──P(-2.0944)───────\n                        \nq[2]:────────────────*──\n                     |  \nq[3]:────────────────X──\n                        \n\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Quantum-Toolkit","page":"Library","title":"Quantum Toolkit","text":"","category":"section"},{"location":"library.html#Basic-Quantum-Objects","page":"Library","title":"Basic Quantum Objects","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"There are three basic quantum objects in Snowflake to simulate a quantum system. These objects are Ket, Bra, and AbstractOperator.","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"Ket\nBra\nDiagonalOperator\nAntiDiagonalOperator\nDenseOperator\nBase.adjoint\nis_hermitian\nBase.exp(A::AbstractOperator)\nBase.getindex(A::AbstractOperator, m::Int64, n::Int64)\neigen\ntr\nexpected_value\nkron\nMultiBodySystem\ncommute\nanticommute\nnormalize!\nget_measurement_probabilities(x::Ket{Complex{T}}) where T<:Real\nket2dm\nfock_dm\nwigner\nmoyal\ngenlaguerre\nget_embed_operator\nget_num_qubits(x::AbstractOperator)\nget_num_qubits(x::Union{Ket, Bra})\nget_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\nget_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\nfock\nspin_up\nspin_down\ncreate\ndestroy\nnumber_op\ncoherent\nsesolve\nmesolve\ncompare_kets","category":"page"},{"location":"library.html#Snowflake.Ket","page":"Library","title":"Snowflake.Ket","text":"A Ket represents a quantum wavefunction and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.  \n\nExamples\n\nAlthough NOT the preferred way, one can directly build a Ket object by passing a column vector as the initializer. \n\njulia> using Snowflake\n\njulia> ψ = Ket([1.0; 0.0; 0.0])\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\n\nA better way to initialize a Ket is to use a pre-built basis such as the fock basis. See fock for further information on this function. \n\njulia> ψ = fock(2, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.Bra","page":"Library","title":"Snowflake.Bra","text":"A structure representing a Bra (i.e. a row vector of complex values). A Bra is created as the complex conjugate of a Ket.\n\nExamples\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> _ψ = Bra(ψ)\n3-element Bra{ComplexF64}:\n0.0 - 0.0im\n1.0 - 0.0im\n0.0 - 0.0im\n\n\njulia> _ψ * ψ    # A Bra times a Ket is a scalar\n1.0 + 0.0im\n\njulia> ψ*_ψ     # A Ket times a Bra is an operator\n(3, 3)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.DiagonalOperator","page":"Library","title":"Snowflake.DiagonalOperator","text":"A structure representing a diagonal quantum Operator (i.e. a complex matrix, with non-zero elements all lying on the diagonal).\n\nExamples\n\njulia> z = DiagonalOperator([1.0,-1.0])\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\njulia> z = DiagonalOperator([1.0+im,1.0,1.0,0.0-im])\n(4,4)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 1.0im    .    .    .\n.    1.0 + 0.0im    .    .\n.    .    1.0 + 0.0im    .\n.    .    .    0.0 - 1.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.AntiDiagonalOperator","page":"Library","title":"Snowflake.AntiDiagonalOperator","text":"A structure representing a anti-diagonal quantum Operator (i.e. a complex matrix, with non-zero elements all lying on the cross-diagonal).\n\nExamples\n\njulia> AntiDiagonalOperator([1,2])\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    2.0 + 0.0im    .\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.DenseOperator","page":"Library","title":"Snowflake.DenseOperator","text":"A structure representing a quantum operator with a full (dense) matrix representation.\n\nExamples\n\njulia> z = DenseOperator([1.0 0.0;0.0 -1.0])\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    -1.0 + 0.0im\n\n\nAlternatively:\n\njulia> z = rotation(π/2,-π/4)  \n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.4999999999999999 - 0.5im\n-0.4999999999999999 - 0.5im    0.7071067811865476 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Base.adjoint","page":"Library","title":"Base.adjoint","text":"Base.adjoint(x)\n\nCompute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.is_hermitian","page":"Library","title":"Snowflake.is_hermitian","text":"is_hermitian(A::AbstractOperator)\n\nDetermine if Operator A is Hermitian (i.e. self-adjoint).\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> is_hermitian(Y)\ntrue\n\njulia> P = sigma_p()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    0.0 + 0.0im    .\n\n\njulia> is_hermitian(P)\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.exp-Tuple{AbstractOperator}","page":"Library","title":"Base.exp","text":"exp(A::AbstractOperator)\n\nCompute the matrix exponential of Operator A.\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> x_rotation_90_deg = exp(-im*π/4*X)\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865475 + 0.0im    0.0 - 0.7071067811865475im\n0.0 - 0.7071067811865475im    0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Base.getindex-Tuple{AbstractOperator, Int64, Int64}","page":"Library","title":"Base.getindex","text":"getindex(A::AbstractOperator, i::Integer, j::Integer)\n\nAccess the element at row i and column j in the matrix corresponding to Operator A.\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> Y[1,1]\n0.0 + 0.0im\n\njulia> Y[1,2]\n0.0 - 1.0im\n\njulia> Y[2,1]\n0.0 + 1.0im\n\njulia> Y[2,2]\n0.0 + 0.0im\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#LinearAlgebra.eigen","page":"Library","title":"LinearAlgebra.eigen","text":"eigen(A::AbstractOperator)\n\nCompute the eigenvalue decomposition of Operator A and return an Eigen factorization object F. Eigenvalues are found in F.values while eigenvectors are found in the matrix F.vectors. Each column of this matrix corresponds to an eigenvector. The ith eigenvector is extracted by calling F.vectors[:, i].\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> F = eigen(X);\n\njulia> eigenvalues = F.values\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> eigenvector_1 = F.vectors[:, 1]\n2-element Vector{ComplexF64}:\n -0.7071067811865475 + 0.0im\n  0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.tr","page":"Library","title":"LinearAlgebra.tr","text":"tr(A::AbstractOperator)\n\nCompute the trace of Operator A.\n\nExamples\n\njulia> I = eye()\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\n\njulia> trace = tr(I)\n2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.expected_value","page":"Library","title":"Snowflake.expected_value","text":"expected_value(A::AbstractOperator, psi::Ket)\n\nCompute the expectation value ⟨ψ|A|ψ⟩ given Operator A and Ket |ψ⟩.\n\nExamples\n\njulia> ψ = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> A = sigma_z()\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\n\njulia> expected_value(A, ψ)\n-1.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.kron","page":"Library","title":"Base.kron","text":"kron(x, y)\n\nCompute the Kronecker product of two Kets or two  DenseOperator , DiagonalOperator, AntiDiagonalOperator. More details about the Kronecker product can be found here. \n\nExamples\n\njulia> ψ_0 = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> ψ_1 = Ket([1.0; 0.0])\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_0_1 = kron(ψ_0, ψ_1)\n4-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> kron(sigma_x(), sigma_y())\n(4, 4)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.MultiBodySystem","page":"Library","title":"Snowflake.MultiBodySystem","text":"A structure representing a quantum multi-body system.\n\nFields\n\nhilbert_space_structure – a vector of integers specifying the local Hilbert space size for each \"body\" within the multi-body system. \n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.commute","page":"Library","title":"Snowflake.commute","text":"commute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the commutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> σ_y = sigma_y()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> commute(σ_x,σ_y)\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n0.0 + 2.0im    .\n.    0.0 - 2.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.anticommute","page":"Library","title":"Snowflake.anticommute","text":"anticommute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the anticommutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> anticommute(σ_x,σ_x)\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n2.0 + 0.0im    .\n.    2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.normalize!","page":"Library","title":"LinearAlgebra.normalize!","text":"normalize!(x::Ket)\n\nNormalizes Ket x such that its magnitude becomes unity.\n\njulia> ψ=Ket([1.,2.,4.])\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n4.0 + 0.0im\n\njulia> normalize!(ψ)\n3-element Ket{ComplexF64}:\n0.2182178902359924 + 0.0im\n0.4364357804719848 + 0.0im\n0.8728715609439696 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T<:Real","page":"Library","title":"Snowflake.get_measurement_probabilities","text":"get_measurement_probabilities(x::Ket{Complex{T}},\n    [target_bodies::Vector{U},\n    hspace_size_per_body::Union{U,Vector{U}}=2])::AbstractVector{T}\n    where {T<:Real, U<:Integer}\n\nReturns a vector listing the measurement probabilities of the target_bodies of Ket x.\n\nThe Hilbert space size per body can be specified by providing a Vector of Integer for the hspace_size_per_body argument. The Vector must specify the Hilbert space size for each body. If the space size is uniform, a single Integer can be given instead. If only x is provided, the probabilities are provided for all the bodies.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit Ket, the probabilities are listed for 00, 01, 10, and 11.\n\nExamples\n\nThe following example constructs a Ket, where the probability of measuring 00 is 50% and the probability of measuring 10 is also 50%.\n\njulia> ψ = 1/sqrt(2)*Ket([1, 0, 1, 0])\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_measurement_probabilities(ψ)\n4-element Vector{Float64}:\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n 0.0\n\n\nFor the same Ket, the probability of measuring qubit 2 and finding 0 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(ψ, target_qubit)\n2-element Vector{Float64}:\n 0.9999999999999998\n 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.ket2dm","page":"Library","title":"Snowflake.ket2dm","text":"ket2dm(ψ::Ket)\n\nReturns the density matrix corresponding to the pure state ψ.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.fock_dm","page":"Library","title":"Snowflake.fock_dm","text":"fock_dm(i::Int64, hspace_size::Int64)\n\nReturns the density matrix corresponding to the Fock base i defined in a Hilbert space of size hspace_size.\n\njulia> dm=fock_dm(0,2)\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.wigner","page":"Library","title":"Snowflake.wigner","text":"wigner(ρ::AbstractOperator, p::Real, q::Real)\n\nComputes the Wigner function of the density matrix ρ at the point (p,q).\n\njulia> using Printf\n\njulia> alpha = 0.25;\n\njulia> hspace_size = 8;\n\njulia> Ψ = coherent(alpha, hspace_size);\n\njulia> prob = wigner(ket2dm(Ψ), 0, 0);\n\njulia> @printf \"prob: %.6f\" prob\nprob: -0.561815\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.moyal","page":"Library","title":"Snowflake.moyal","text":"moyal(m, n)\n\nReturns the Moyal function w_mn(eta) for Fock states m and n.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.genlaguerre","page":"Library","title":"Snowflake.genlaguerre","text":"genlaguerre(x, alpha, n)\n\nReturns the generalized Laguerre polynomial of degree n for x using a recursive method. See https://en.wikipedia.org/wiki/Laguerre_polynomials.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_embed_operator","page":"Library","title":"Snowflake.get_embed_operator","text":"get_embed_operator(op::DenseOperator, target_body_index::Int, system::MultiBodySystem)\n\nUses a local operator (op), which is defined for a particular body (e.g. qubit) with index target_body_index, to build the corresponding operator for the Hilbert space of the multi-body system given by system. \n\nExamples\n\njulia> system = MultiBodySystem(3,2)\nSnowflake.Multibody system with 3 bodies\n   Hilbert space structure:\n   [2, 2, 2]\n\njulia> x = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> X_1=get_embed_operator(x,1,system)\n(8, 8)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_qubits-Tuple{AbstractOperator}","page":"Library","title":"Snowflake.get_num_qubits","text":"get_num_qubits(x::AbstractOperator)\n\nReturns the number of qubits associated with an Operator.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0.\n                     0. 0.])\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_qubits(ρ)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_qubits-Tuple{Union{Bra, Ket}}","page":"Library","title":"Snowflake.get_num_qubits","text":"get_num_qubits(x::Union{Ket, Bra})\n\nReturns the number of qubits associated with a Ket or a Bra.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_qubits(ψ)\n2\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_bodies","page":"Library","title":"Snowflake.get_num_bodies","text":"get_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with an Operator given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0. 0.\n                     0. 0. 0.\n                     0. 0. 0.])\n(3, 3)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_bodies(ρ, 3)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_bodies-2","page":"Library","title":"Snowflake.get_num_bodies","text":"get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with a Ket or a Bra given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0., 0., 0., 0., 0., 0.])\n9-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_bodies(ψ, 3)\n2\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.fock","page":"Library","title":"Snowflake.fock","text":"fock(i, hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the ith fock basis of a Hilbert space with size hspace_size as a Ket.\n\nThe Ket contains values of type T, which by default is ComplexF64.\n\nExamples\n\njulia> ψ = fock(0, 3)\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3,ComplexF32) # specifying a type other than ComplexF64\n3-element Ket{ComplexF32}:\n0.0f0 + 0.0f0im\n1.0f0 + 0.0f0im\n0.0f0 + 0.0f0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.spin_up","page":"Library","title":"Snowflake.spin_up","text":"spin_up(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-up state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_up()\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.spin_down","page":"Library","title":"Snowflake.spin_down","text":"spin_down(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-down state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_down()\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.create","page":"Library","title":"Snowflake.create","text":"create(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic creation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.destroy","page":"Library","title":"Snowflake.destroy","text":"destroy(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic annhilation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.number_op","page":"Library","title":"Snowflake.number_op","text":"number_op(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the number operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.coherent","page":"Library","title":"Snowflake.coherent","text":"coherent(alpha, hspace_size)\n\nReturns a coherent state for the parameter alpha in a Fock space of size hspace_size. Note that |alpha|^2 is equal to the photon number of the coherent state. \n\n# Examples\n\njulia> ψ = coherent(2.0,20)\n20-element Ket{ComplexF64}:\n0.1353352832366127 + 0.0im\n0.2706705664732254 + 0.0im\n0.3827859860416437 + 0.0im\n0.44200318416631873 + 0.0im\n0.44200318416631873 + 0.0im\n0.3953396664268989 + 0.0im\n0.3227934859426707 + 0.0im\n0.24400893961026582 + 0.0im\n0.17254037586855772 + 0.0im\n0.11502691724570517 + 0.0im\n0.07274941014482605 + 0.0im\n0.043869544940011405 + 0.0im\n0.025328093580341972 + 0.0im\n0.014049498479026656 + 0.0im\n0.007509772823502764 + 0.0im\n0.003878030010563634 + 0.0im\n0.001939015005281817 + 0.0im\n0.000940560432521708 + 0.0im\n0.0004433844399679012 + 0.0im\n0.00020343873336404819 + 0.0im\n\n\njulia> expected_value(number_op(20),ψ)\n3.99999979364864 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sesolve","page":"Library","title":"Snowflake.sesolve","text":"sesolve(H::AbstractOperator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{AbstractOperator}=(AbstractOperator)[])\nsesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[])\n\nSolves the Shrodinger equation:\n\nfracd Psid t=-i hatHPsi\n\nFields\n\nH – the Hamiltonian operator or a function that returns the Hamiltonian as a function of time.\nψ_0 – initital status of a quantum system\nt_range – time interval for which the system has to be simulated. \ne_ops – list of operators for which the expected value will be returned as a function of time. \n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.mesolve","page":"Library","title":"Snowflake.mesolve","text":"mesolve(H::AbstractOperator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{AbstractOperator}=(AbstractOperator)[])\nmesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{AbstractOperator}=(AbstractOperator)[])\n\nSolves the Lindblad Master equation:\n\ndotrho=-i H rho+sum_i gamma_ileft(L_i rho L^dag_i - frac12leftL^dag_i L_i rhorightright)\n\nFields\n\nH – the Hamiltonian operator or a function that returns the Hamiltonian as a function of time.\nψ_0 – initital status of a quantum system\nt_range – time interval for which the system has to be simulated. \ne_ops – list of operators for which the expected value will be returned as function of time. \nc_ops – list of collapse operators L_i's.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.compare_kets","page":"Library","title":"Snowflake.compare_kets","text":"compare_kets(ψ_0::Ket,ψ_1::Ket)\n\nChecks for equivalence allowing for a global phase difference between two input kets.\n\nExamples\n\njulia> ψ_0 = Ket([1.,2.,3.,4.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n3.0 + 0.0im\n4.0 + 0.0im\n\n\njulia> δ=π/3 # phase offset\n1.0471975511965976\n\njulia> ψ_1 = exp(im*δ)*ψ_0\n4-element Ket{ComplexF64}:\n0.5000000000000001 + 0.8660254037844386im\n1.0000000000000002 + 1.7320508075688772im\n1.5000000000000004 + 2.598076211353316im\n2.0000000000000004 + 3.4641016151377544im\n\n\njulia> compare_kets(ψ_0,ψ_1)\ntrue\n\njulia> apply_gate!(ψ_1,sigma_x(1))\n\njulia> compare_kets(ψ_0,ψ_1) # no longer equivalent after SigmaX gate\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Visualization","page":"Library","title":"Visualization","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"The SnowflakePlots package provides multiple tools for visualizing quantum computer calculations.","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"plot_bloch_sphere(circuit::QuantumCircuit; qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\nplot_bloch_sphere(ket::Ket; qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\nplot_bloch_sphere(density_matrix::AbstractOperator; qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\nBlochSphere\nplot_bloch_sphere_animation(ket_list::Vector{Ket{T}} where {T<:Complex};\n    qubit_id::Int = 1,\n    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())","category":"page"},{"location":"library.html#SnowflakePlots.plot_bloch_sphere-Tuple{QuantumCircuit}","page":"Library","title":"SnowflakePlots.plot_bloch_sphere","text":"plot_bloch_sphere(circuit::QuantumCircuit;\n    qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\n\nPlots the Bloch sphere of qubit qubit_id for the circuit.\n\nIf the circuit contains multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit qubit_id. The appearance of the Bloch sphere can be modified by passing a BlochSphere struct.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count=2)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n\n\njulia> push!(circuit, [hadamard(1), sigma_x(2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\n\njulia> plot = plot_bloch_sphere(circuit, qubit_id=2)\n\n\n(Image: Bloch sphere for circuit)\n\nThe Bloch sphere can be saved to a file by calling:\n\njulia> PlotlyJS.savefig(plot, \"bloch_sphere.png\", width=size(plot)[1],\n                        height=size(plot)[2])\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#SnowflakePlots.plot_bloch_sphere-Tuple{Ket}","page":"Library","title":"SnowflakePlots.plot_bloch_sphere","text":"plot_bloch_sphere(ket::Ket;\n    qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\n\nPlots the Bloch sphere of qubit qubit_id for the state represented by ket.\n\nIf ket is associated with multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit qubit_id. The appearance of the Bloch sphere can be modified by passing a BlochSphere struct.\n\nExamples\n\njulia> ket = Ket(1/sqrt(2)*[1, 1])\n2-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.7071067811865475 + 0.0im\n\n\n\n\njulia> plot = plot_bloch_sphere(ket)\n\n\n(Image: Bloch sphere for ket)\n\nThe Bloch sphere can be saved to a file by calling:\n\njulia> PlotlyJS.savefig(plot, \"bloch_sphere.png\", width=size(plot)[1],\n                        height=size(plot)[2])\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#SnowflakePlots.plot_bloch_sphere-Tuple{AbstractOperator}","page":"Library","title":"SnowflakePlots.plot_bloch_sphere","text":"plot_bloch_sphere(density_matrix::AbstractOperator;\n    qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\n\nPlots the Bloch sphere of qubit qubit_id given the density_matrix.\n\nIf the density_matrix is associated with multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit qubit_id. The appearance of the Bloch sphere can be modified by passing a BlochSphere struct.\n\nExamples\n\njulia> ρ = DenseOperator([1.0 0.0;\n                          0.0 0.0])\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\n\njulia> plot = plot_bloch_sphere(ρ)\n\n\n(Image: Bloch sphere for operator)\n\nThe Bloch sphere can be saved to a file by calling:\n\njulia> PlotlyJS.savefig(plot, \"bloch_sphere.png\", width=size(plot)[1],\n                        height=size(plot)[2])\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#SnowflakePlots.BlochSphere","page":"Library","title":"SnowflakePlots.BlochSphere","text":"BlochSphere\n\nContains fields which affect how a Bloch sphere is generated.\n\nExamples\n\njulia> ket = Ket(1/sqrt(2)*[1, 1])\n2-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.7071067811865475 + 0.0im\n\n\njulia> bloch_sphere = BlochSphere(vector_color=\"green\");\n\n\njulia> plot = plot_bloch_sphere(ket, bloch_sphere=bloch_sphere)\n\n\n(Image: Bloch sphere for ket)\n\n\n\n\n\n","category":"type"},{"location":"library.html#SnowflakePlots.plot_bloch_sphere_animation-Tuple{Array{Ket{T}, 1} where T<:Complex}","page":"Library","title":"SnowflakePlots.plot_bloch_sphere_animation","text":"plot_bloch_sphere_animation(ket_list::Vector{Ket{T}} where {T<:Complex};\n    qubit_id::Int = 1,\n    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())\n\nPlots a Bloch sphere animation of qubit qubit_id for the states listed in ket_list.\n\nIf ket_list is associated with multiple qubits, the Bloch sphere animation is constructed from the 1-qubit reduced density matrices of qubit qubit_id. Animation settings and the appearance of the Bloch sphere can be modified by passing an AnimatedBlochSphere struct.\n\nExamples\n\njulia> ket_list = [Ket([1, 0]), Ket(1/sqrt(2)*[1, 1])];\n\njulia> plot = plot_bloch_sphere_animation(ket_list)\n\n\nThe Bloch sphere animation can be saved to an html file by calling:\n\njulia> PlotlyJS.savefig(plot, \"bloch_sphere_animation.html\")\n\n\n\n\n\n\n","category":"method"},{"location":"library.html","page":"Library","title":"Library","text":"<iframe src=\"assets/visualize/plot_bloch_sphere_animation_for_ket.html\"\nstyle=\"height:825px;width:100%;\">\n</iframe>","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"plot_bloch_sphere_animation(density_matrix_list::Vector{T} where {T<:AbstractOperator};\n    qubit_id::Int = 1,\n    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())","category":"page"},{"location":"library.html#SnowflakePlots.plot_bloch_sphere_animation-Tuple{Vector{T} where T<:AbstractOperator}","page":"Library","title":"SnowflakePlots.plot_bloch_sphere_animation","text":"plot_bloch_sphere_animation(density_matrix_list::Vector{T} where {T<:AbstractOperator};\n    qubit_id::Int = 1,\n    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())\n\nPlots a Bloch sphere animation of qubit qubit_id for the states listed in density_matrix_list.\n\nIf density_matrix_list is associated with multiple qubits, the Bloch sphere animation is constructed from the 1-qubit reduced density matrices of qubit qubit_id. Animation settings and the appearance of the Bloch sphere can be modified by passing an AnimatedBlochSphere struct.\n\nExamples\n\njulia> ψ_0 = DenseOperator([0.5 0.5; 0.5 0.5]);\n\njulia> ψ_1 = DenseOperator([0.5 -0.5im; 0.5im 0.5]);\n\njulia> plot = plot_bloch_sphere_animation([ψ_0, ψ_1])\n\n\nThe Bloch sphere animation can be saved to an html file by calling:\n\njulia> PlotlyJS.savefig(plot, \"bloch_sphere_animation.html\")\n\n\n\n\n\n\n","category":"method"},{"location":"library.html","page":"Library","title":"Library","text":"<iframe src=\"assets/visualize/plot_bloch_sphere_animation_for_operator.html\"\nstyle=\"height:825px;width:100%;\">\n</iframe>","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"AnimatedBlochSphere","category":"page"},{"location":"library.html#SnowflakePlots.AnimatedBlochSphere","page":"Library","title":"SnowflakePlots.AnimatedBlochSphere","text":"AnimatedBlochSphere\n\nContains fields which affect how a Bloch sphere animation is generated.\n\nExamples\n\nBy default, additional Bloch sphere vectors are generated between each state using interpolation. The number of additional vectors can be changed by passing a value for the keyword num_interpolated_points.\n\njulia> ket_list = [Ket([1, 0]), Ket(1/sqrt(2)*[1, 1])];\n\njulia> animated_sphere = AnimatedBlochSphere(num_interpolated_points=0,\n        history_line_color=\"transparent\", frame_duration=1000);\n\njulia> plot = plot_bloch_sphere_animation(ket_list, animated_bloch_sphere=animated_sphere)\n\n\n\n\n\n\n","category":"type"},{"location":"library.html","page":"Library","title":"Library","text":"<iframe src=\"assets/visualize/plot_bloch_sphere_animation_without_interpolation.html\"\nstyle=\"height:825px;width:100%;\">\n</iframe>","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"plot_histogram\nviz_wigner","category":"page"},{"location":"library.html#SnowflakePlots.plot_histogram","page":"Library","title":"SnowflakePlots.plot_histogram","text":"plot_histogram(circuit::QuantumCircuit, shots_count::Int)\n\nPlots a histogram showing the measurement output distribution of a circuit.\n\nThe number of shots taken is specified by shots_count.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, [hadamard(1), sigma_x(2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n\n\n\njulia> plot = plot_histogram(circuit, 100)\n\n\n(Image: Measurement histogram for circuit)\n\n\n\n\n\n","category":"function"},{"location":"library.html#SnowflakePlots.viz_wigner","page":"Library","title":"SnowflakePlots.viz_wigner","text":"viz_wigner(ρ::AbstractOperator,\n    x::Union{AbstractRange{<:Real},AbstractVector{<:Real}},\n    y::Union{AbstractRange{<:Real},AbstractVector{<:Real}})\n\nGenerates a contour plot of the Wigner function of the density matrix ρ.\n\nThe range of the plot is specified by the phase-space coordinates x and y.\n\nExamples\n\njulia> ρ = ket2dm(coherent(0.25, 8));\n\njulia> x = y = -3.0:0.1:3.0;\n\n\njulia> viz_wigner(ρ, x, y)\n\n\n(Image: Wigner function contour plot)\n\n\n\n\n\n","category":"function"},{"location":"library.html","page":"Library","title":"Library","text":"DocTestSetup = nothing","category":"page"},{"location":"qc/basics.html#What-is-Quantum-Computing?","page":"Basics","title":"What is Quantum Computing?","text":"","category":"section"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Quantum computing is a new paradigm in high performance computing that utilizes the fundamental principles of quantum mechanics to perform calculations. Quantum computation holds great promise to outperform classical computers in some tasks such as prime factorization, quantum simulation, search, optimization, and algebraic programs such as machine learning.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"The power of quantum computing stems from two fundamental properties of quantum mechanics, namely superposition and entanglement.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Snowflake is a Julia-based SDK for performing quantum computations. Quantum computation is conducted by building and executing quantum circuits. These circuits are comprised of quantum gates, instructions, and classical control logic. Complex algorithms and applications can be expressed in terms of quantum circuits that can be executed on a quantum computer.","category":"page"},{"location":"qc/basics.html#Quantum-Circuits","page":"Basics","title":"Quantum Circuits","text":"","category":"section"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Algorithms and applications that utilize quantum mechanical resources use a concept known as a quantum circuit to represent quantum operations. A quantum circuit is a computational pipeline consisting of a quantum register. The following figure shows an example of a 3-qubit quantum circuit:","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"(Image: Bell State generator circuit)","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"The initial state of each qubit is given on the left side of the figure. The lines correspond to the timeline of operations that are performed on the qubits. The boxes and symbols denote different single-qubit or multi-qubit gates.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"You can define a quantum circuit with Snowflake as follows:","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"julia> c = QuantumCircuit(qubit_count = 2)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n  ","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"The above example creates a quantum circuit with two qubits and no classical bit. It is now ready to be used to store quantum instructions, which are also known as quantum gates. ","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"tip: Circuit UUID\nNote that the circuit object has been given a Universally Unique Identifier (UUID). This UUID can be used later to retrieve the circuit results from a remote server such as a quantum computer on the cloud.","category":"page"},{"location":"qc/basics.html#Quantum-Gates","page":"Basics","title":"Quantum Gates","text":"","category":"section"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"A quantum gate is a basic quantum operation that affects one or more qubits. Quantum gates are the building blocks of quantum circuits, like classical logic gates are for conventional digital circuits.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Unlike their classic counterparts, quantum gates are reversible. Quantum gates are unitary operators and can be represented as unitary matrices.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Now, let's add a few gates to our circuit using the push_gate command:","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"julia> push!(c, [hadamard(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"The first command added a Hadamard gate to the quantum circuit object c. The gate will operate on qubit 1.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"julia> push!(c, [control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"The second command added a CNOT gate (Control-X gate) with qubit 1 as the control and qubit 2 as the target. ","category":"page"},{"location":"qc/basics.html#Quantum-Processing-Unit-(QPU)","page":"Basics","title":"Quantum Processing Unit (QPU)","text":"","category":"section"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Usually, quantum circuits cannot be immediately executed on a quantum processor. This is because QPUs typically execute only a limited number of quantum gates directly on the hardware. Such gates are commonly referred to as native gates. This means that once a general quantum circuit is defined, it needs to be transpiled such that it only makes use of the native gates of a given QPU . ","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Snowflake introduces QPU to represent physical or virtual quantum processors. For example, the following command creates a virtual QPU which can implement Pauli matrices and Control-Z gates:","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"DocTestSetup = nothing","category":"page"},{"location":"qc/overview.html#Snowflake-Overview","page":"Snowflake Overview","title":"Snowflake Overview","text":"","category":"section"},{"location":"qc/overview.html","page":"Snowflake Overview","title":"Snowflake Overview","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"qc/overview.html","page":"Snowflake Overview","title":"Snowflake Overview","text":"Snowflake is a pure Julia quantum computing stack that allows you to easily design quantum circuits, algorithms, experiments and applications and run them on real quantum computers and/or classical simulators.","category":"page"},{"location":"qc/overview.html","page":"Snowflake Overview","title":"Snowflake Overview","text":"DocTestSetup = nothing","category":"page"},{"location":"index.html#Snowflake.jl","page":"Home","title":"Snowflake.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A library for quantum computing using Julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Snowflake is a pure Julia quantum computing stack that allows you to easily design quantum circuits, algorithms, experiments and applications. Julia can then run them on real quantum computers and/or classical simulators. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nThe documentation of Snowflake is still a work in progress. That being said, a lot can be learnt from the unit tests in the test folder.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Make sure your system has Julia (v.1.6 or a more recent version) installed. If not, download the latest version from https://julialang.org/downloads/.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Launch Julia REPL and type:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Snowflake\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you intend to use a particular development branch from github repo, you can use the following commands:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/anyonlabs/Snowflake.jl\", rev=\"BRANCH_NAME\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note: Replace the BRANCH_NAME with the name of the branch you want to use. The stable release is main and the most up-to-date one is next.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Multiple visualization tools are available in the SnowflakePlots package. After installing Snowflake, the SnowflakePlots package can be installed by entering the following in the Julia REPL:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/anyonlabs/Snowflake.jl\", subdir=\"SnowflakePlots.jl\",\n    rev=\"BRANCH_NAME\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note: BRANCH_NAME should be the same as the one used to add Snowflake.","category":"page"},{"location":"index.html#Get-Started","page":"Home","title":"Get Started","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Like other Julia Packages, you can use Snowflake in a Julia REPL, in a Julia script, or in a notebook.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A typical workflow to use a quantum computer consists of the following four steps:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Build: Design a quantum circuit(s) that represents the problem you are considering.\nCompile: Compile circuits for a specific quantum service, e.g. a quantum system or classical simulator.\nRun: Run the compiled circuits on the specified quantum service(s). These services can be cloud-based or local.\nPostprocess: Compute summary statistics and visualize the results of the experiments.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Now, let's try Snowflake and SnowflakePlots by making a two-qubit circuit which implements a Bell/EPR state. The quantum circuit for generating a Bell state involves a Hadamard gate on one of the qubits followed by a CNOT gate (see https://en.wikipedia.org/wiki/Quantumlogicgate for an introduction to quantum logic gates). This circuit is shown below:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Bell State generator circuit)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"First import Snowflake:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Snowflake","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Then, let's define a two-qubit circuit:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"c = QuantumCircuit(qubit_count=2)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you are using Julia REPL, you should see an output similar to:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Quantum Circuit Object:\n   id: 1e9c4f6e-64df-11ec-0c5b-036aab5b72cb\n   qubit_count: 2\n   bit_count: 0\nq[1]:\n\nq[2]:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note that the circuit object has been given a Universally Unique Identifier (UUID). This UUID can be used later to retrieve the circuit results from a remote server such as a quantum computer on the cloud.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Now, let's build the circuit using the following commands:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"push!(c, [hadamard(1)])\npush!(c, [control_x(1, 2)])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The first line adds a Hadamard gate to circuit object c which will operate on qubit 1. The second line adds a CNOT gate (Control-X gate) with qubit 1 as the control qubit and qubit 2 as the target qubit. The output in Julia REPL would look like:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Quantum Circuit Object:\n   id: 1e9c4f6e-64df-11ec-0c5b-036aab5b72cb\n   qubit_count: 2\n   bit_count: 0\nq[1]:──H────*──\n            |\nq[2]:───────X──","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note: Unlike C++ or Python, indexing in Julia starts from \"1\" and not \"0\"!","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You can also simulate this circuit and obtain the final quantum state of this two-qubit register:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ψ = simulate(c)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"which would give:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note: Snowflake always assumes a qubit is initialized in state 0.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Finally, you can use SnowflakePlots to generate a histogram which shows the measurement output distribution after taking a certain number of shots, in this case 100, on a quantum computer simulator:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using SnowflakePlots\n\nplot_histogram(c, 100)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Measurement results histogram)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The script below puts all the steps above together:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Snowflake, SnowflakePlots\n\nc = QuantumCircuit(qubit_count=2)\npush!(c, [hadamard(1)])\npush!(c, [control_x(1, 2)])\nψ = simulate(c)\nplot_histogram(c, 100)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"DocTestSetup = nothing","category":"page"},{"location":"simulating_quantum_systems.html#Simulating-Quantum-Systems","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"","category":"section"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"Snowflake provides capability to directly simulate a quantum system on a classical computer. The following sections of this page provide you with documentation and examples of how to achieve that.","category":"page"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"Note that using a quantum computer does not involve using these objects. But, simulating the operation of a quantum computer, or any quantum system for that matter, on a classical computer does!","category":"page"},{"location":"simulating_quantum_systems.html#Basic-Quantum-Objects","page":"Simulating Quantum Systems","title":"Basic Quantum Objects","text":"","category":"section"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"There are three basic quantum objects defined in Snowflake to simulate a Quantum system. These objects are Ket, Bra, and Operator, which inherit from AbstractOperator. Particular Operators are either DenseOperator, DiagonalOperator, or AntiDiagonalOperator.","category":"page"},{"location":"simulating_quantum_systems.html#Multibody-Systems","page":"Simulating Quantum Systems","title":"Multibody Systems","text":"","category":"section"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"MultiBodySystem structures are used to represent quantum multi-body systems. After defining a multi-body system, it is possible to build an operator for this system given a local operator (e.g. one which acts on a qubit). An operator for a multi-body system can be obtained by calling get_embed_operator.","category":"page"},{"location":"simulating_quantum_systems.html#Fock-Space","page":"Simulating Quantum Systems","title":"Fock Space","text":"","category":"section"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"A Ket which represents a bosonic Fock space can be created by calling fock.","category":"page"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"DocTestSetup = nothing","category":"page"}]
}
