var documenterSearchIndex = {"docs":
[{"location":"library/viz.html#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"library/viz.html","page":"Visualization","title":"Visualization","text":"The SnowflurryPlots package provides multiple visualization tools for Snowflurry.jl. Please see the documentation of SnowflurryPlots for more details. ","category":"page"},{"location":"tutorials/advanced/async_jobs.html#Asynchronous-jobs","page":"Asynchronous Jobs","title":"Asynchronous jobs","text":"","category":"section"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"DocTestSetup = quote\n    ENV[\"THUNDERHEAD_USER\"] = \"test-user\"\n    ENV[\"THUNDERHEAD_API_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"THUNDERHEAD_HOST\"] = \"yukon.anyonsys.com\"\n    ENV[\"THUNDERHEAD_PROJECT_ID\"] = \"9d6949c8-bb5d-4aeb-9aa3-e7b284f0f269\"\nend","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"In this tutorial we will learn how to run jobs asynchronously using Julia tasks. Asynchronous jobs allow for the code to continue with other computation while waiting for the quantum resources.","category":"page"},{"location":"tutorials/advanced/async_jobs.html#Julia-tasks","page":"Asynchronous Jobs","title":"Julia tasks","text":"","category":"section"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"Practical applications of quantum computing typically involve both classical and quantum computation. A quantum processor is indeed a hardware accelerator in this paradigm. In such scenarios, it might take some time for the quantum computer to run the circuit that was submitted to it.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"In many cases, it is desirable to be able to continue with some classical computation while the program waits for the quantum hardware to complete its task. This is an example of asynchronous programming. We recommend you consult Julia's page on asynchronous programming if you are unfamiliar with this concept.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"In Snowflurry, communicating with a quantum processor will yield execution every time it waits for a response from the quantum computer. This gives you the opportunity to perform work while the quantum computer is running your job.","category":"page"},{"location":"tutorials/advanced/async_jobs.html#Code","page":"Asynchronous Jobs","title":"Code","text":"","category":"section"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"To provide maximum flexibility, Snowflurry does not impose any restrictions on how you parallelize your code. We cannot know what will be best for your code. That is up to you!","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"We will start by importing Snowflurry, building our circuit and defining our QPU as demonstrated in the Running a Circuit on a Real Hardware tutorial.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"using Snowflurry\n\ncircuit = QuantumCircuit(qubit_count = 2, instructions = [\n    hadamard(1),\n    control_x(1, 2),\n    readout(1, 1),\n    readout(2, 2),\n])\n\nuser = ENV[\"THUNDERHEAD_USER\"]\ntoken = ENV[\"THUNDERHEAD_API_TOKEN\"]\nhost = ENV[\"THUNDERHEAD_HOST\"]\nproject = ENV[\"THUNDERHEAD_PROJECT_ID\"]\n\nqpu = AnyonYukonQPU(host=host, user=user, access_token=token, project_id=project)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"Next, we are going to define and schedule our task.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"shot_count = 200\ntask = Task(() -> run_job(qpu, circuit, shot_count))\nschedule(task)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"warning: Warning\nNote the last line above. It is important to schedule the task; otherwise, Julia will not know that it should start it!","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"Next, we need to yield execution of the current thread to the newly scheduled task to ensure that the scheduler starts with the task. Otherwise, the task will be scheduled, but it might not submit a job to the quantum computer any time soon! After yielding once, we can continue to do work before we fetch the results from that task.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"yieldto(task)\n\n# Simulate work by calculating the nth Fibonacci number slowly\nfunction fibonacci(n)\n  if n <= 2\n    return 1\n  end\n  return fibonacci(n - 1) + fibonacci(n - 2)\nend\n\nfibonacci(30)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"After we are done with our work, we can fetch the result of our job.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"result = fetch(task)\nprintln(result)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"The full code is available at tutorials/asynchronous_jobs.jl","category":"page"},{"location":"tutorials/virtual_qpu.html#Run-a-circuit-on-a-Virtual-QPU","page":"Virtual QPU","title":"Run a circuit on a Virtual QPU","text":"","category":"section"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"In the previous tutorial, we introduced some basic concepts of quantum computing, namely the quantum circuit and quantum gates.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"We also learnt how to build a quantum circuit using Snowflurry and simulate the result of such circuit using our local machine.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"In this tutorial, we will cover the steps involved in running a quantum circuit on a virtual Quantum Processing Unit (QPU).","category":"page"},{"location":"tutorials/virtual_qpu.html#QPU-Object","page":"Virtual QPU","title":"QPU Object","text":"","category":"section"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Interactions with different QPUs are facilitated using structs (objects) that represent QPU hardware.  These structures are used to implement a harmonized interface and are derived from an abstract type called AbstractQPU. This interface gives you a unified way to write code that is agnostic of the quantum service you are using. The interface dictates how to get metadata about the QPU, how to run a quantum circuit on the QPU, and more.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"warning: Warning\nYou should not use AbstractQPU, rather use a QPU object which is derived from AbstractQPU. For further details on the implemented derived QPUs, see the Library page.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Now that you know what QPU objects are, let's get started by importing Snowflurry:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"using Snowflurry","category":"page"},{"location":"tutorials/virtual_qpu.html#Virtual-QPU","page":"Virtual QPU","title":"Virtual QPU","text":"","category":"section"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Next, we are going to create a virtual QPU which will run on our local machine:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"qpu_v = VirtualQPU()\n# output\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflurry.jl\n","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"We can print QPU's meta data by simply using","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"print(qpu_v)\n# output\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflurry.jl\n","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"or alternatively, retrieve the QPU metadata in a Dict{String,String} format through the following command:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"get_metadata(qpu_v)\n# output\nDict{String, String} with 2 entries:\n  \"developers\" => \"Anyon Systems Inc.\"\n  \"package\"    => \"Snowflurry.jl\"\n\n","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Now, let's create a circuit to create a Bell pair as was explained in the previous tutorial:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"c = QuantumCircuit(qubit_count = 2)\npush!(c, hadamard(1), control_x(1, 2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Although we've created a circuit that makes a Bell pair, we need to measure something in order to collect any results. In Snowflurry, we can use a Readout instruction to perform a measurement, which are built  using the readout() helper function.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"note: Note\nMeasurements are always performed in the Z basis (also known as the computational basis).","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"push!(c, readout(1, 1), readout(2, 2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────*────✲───────\n            |            \nq[2]:───────X─────────✲──","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Here we see that a readout instruction can be added to a circuit like any other gate. Each readout instruction needs two parameters: which qubit to measure and which result bit to write to. For example, readout(2, 4) means \"read qubit 2 and store the result in classical bit 4\". So, in this example, the first readout reads from qubit 1 and writes that result to bit 1 of the result. The second readout does the same for qubit 2 and bit 2 of the result.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"In Snowflurry, readout instructions can read from any qubit and write to any result bit but with some restrictions:","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Any readout operation must be the final operation applied to its target qubit\nWe plan to lift this restriction in future versions of Snowflurry\nSeparate readout operations must write to separate result bits","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"With our measurements defined, we can now run this circuit on the virtual qpu for let's say 100 shots.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"shots_count = 100\nresult = run_job(qpu_v, c, shots_count)","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"The result object is a Dict{String, Int64} that summarizes how many times each state was measured in the shots run on the QPU.  It contains only non-zero entries.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"print(result)\n\nDict(\"00\" => 53, \"11\" => 47)","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"Here we see that, after measurement, the classical result bits were set to left00rightrangle in 53 of the 100 shots. In the other 47 shots, the result bits were set to left11rightrangle. (The qubit ordering convention used is qubit number 1 on the left, with each following qubit to the right of it.)","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"note: Note\nThe reason the number of measured values for states left00rightrangle and left11rightrangle are not necessarily equal is due to the fact that VirtualQPU tries to mimic the statistical nature of real hardware. By increasing the shots_count the experiment will confirm that the probability of  left00rightrangle and  left11rightrangle are equal.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"The virtual QPU currently mimics an ideal hardware with no error. Therefore, the states  left01rightrangle and  left10rightrangle have a probability of zero, and they are never measured.  In future versions, we expect to add noise models for sources such as crosstalk, thermal noise, etc.","category":"page"},{"location":"tutorials/virtual_qpu.html","page":"Virtual QPU","title":"Virtual QPU","text":"In the next tutorial, we will show how to submit a job to real quantum processing hardware.","category":"page"},{"location":"development.html#Snowflurry-development","page":"Developing","title":"Snowflurry development","text":"","category":"section"},{"location":"development.html#Installing-Snowflurry-for-local-development","page":"Developing","title":"Installing Snowflurry for local development","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"When developing Snowflurry, you must ensure that you are using a local copy of Snowflurry, not the latest released version. The easiest way to achieve that is to set the project to the local directory.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If you are starting a new instance of Julia, then you can activate the Snowflurry project with","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Or, if you are inside a script or REPL, you can use","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If the current directory is not the Snowflurry project, replace . with the Snowflurry project path.","category":"page"},{"location":"development.html#Running-tests","page":"Developing","title":"Running tests","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"First open a Julia REPL in the current project","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"and run the tests","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.test()","category":"page"},{"location":"development.html#Build-the-documentation","page":"Developing","title":"Build the documentation","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"Open a Julia REPL using the docs project","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=./docs","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If it is the first time building the docs, you need to instantiate the Julia project and add the Snowflurry project as a development dependency. This means the version of the Snowflurry package loaded is the one at the path specified, pwd(), and not the one registered at JuliaHub.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.develop(PackageSpec(path=pwd()))\nPkg.instantiate()","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"At which point, the project status should be similar to the one below. The versions might be slightly different, but what is important is that the Status line refers to the docs/Project.toml and that Snowflurry refers to <pwd()>/Snowflurry.jl.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Pkg.status()\n\n# output\n      Status `<pwd()>/Snowflurry.jl/docs/Project.toml`\n  [e30172f5] Documenter v0.27.24\n  [cd3eb016] HTTP v1.7.4\n  [682c06a0] JSON v0.21.4\n  [7bd9edc1] Snowflurry v0.1.0 `<pwd()>/Snowflurry.jl`\n  [90137ffa] StaticArrays v1.5.21\n  [2913bbd2] StatsBase v0.33.21\n  [de0858da] Printf","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Then you can run the following to build the documentation website.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"include(\"./docs/make.jl\")","category":"page"},{"location":"development.html#Run-coverage-locally","page":"Developing","title":"Run coverage locally","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"If you haven't already, instantiate the project with Julia's package manager.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=. -e 'using Pkg; Pkg.Instantiate()'","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"You can run coverage locally from the project directory using","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=. coverage.jl","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"The script returns the covered and total line as output. An example output is shown below","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Covered lines: 1373\nTotal lines: 1383\nCoverage percentage: 0.9927693420101229","category":"page"},{"location":"library/qpu.html#Quantum-Processing-Unit","page":"QPU","title":"Quantum Processing Unit","text":"","category":"section"},{"location":"library/qpu.html","page":"QPU","title":"QPU","text":"AnyonYukonQPU\nAnyonYamaskaQPU\nVirtualQPU\nClient\nget_host\nsubmit_job\nget_status\nrun_job\ntranspile_and_run_job\nget_transpiler\nSequentialTranspiler\nAllToAllConnectivity\nLineConnectivity\nLatticeConnectivity\npath_search\nget_adjacency_list\nget_qubits_distance","category":"page"},{"location":"library/qpu.html#Snowflurry.AnyonYukonQPU","page":"QPU","title":"Snowflurry.AnyonYukonQPU","text":"AnyonYukonQPU <: AbstractQPU\n\nA data structure to represent an Anyon System's Yukon generation QPU,  consisting of 6 qubits in a linear arrangement (see LineConnectivity). \n\nFields\n\nclient                  ::Client – Client to the QPU server.\nstatus_request_throttle ::Function – Used to rate-limit job status requests.\nproject_id              ::String – Used to identify which project the jobs sent to this QPU belong to.\n\nExample\n\njulia>  qpu = AnyonYukonQPU(host = \"example.anyonsys.com\", user = \"test_user\", access_token = \"not_a_real_access_token\", project_id = \"9d6949c8-bb5d-4aeb-9aa3-e7b284f0f269\")\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   project_id:    9d6949c8-bb5d-4aeb-9aa3-e7b284f0f269\n   qubit_count:   6 \n   connectivity_type:  linear\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.AnyonYamaskaQPU","page":"QPU","title":"Snowflurry.AnyonYamaskaQPU","text":"AnyonYamaskaQPU <: AbstractQPU\n\nA data structure to represent an Anyon System's Yamaska generation QPU,  consisting of 12 qubits in a 2D lattice arrangement (see LatticeConnectivity).\n\nFields\n\nclient                  ::Client – Client to the QPU server.\nstatus_request_throttle ::Function – Used to rate-limit job status requests.\nproject_id              ::String – Used to identify which project the jobs sent to this QPU belong to.\n\nExample\n\njulia>  qpu = AnyonYamaskaQPU(host = \"example.anyonsys.com\", user = \"test_user\", access_token = \"not_a_real_access_token\", project_id = \"9d6949c8-bb5d-4aeb-9aa3-e7b284f0f269\")\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yamaska\n   serial_number: ANYK202301\n   project_id:    9d6949c8-bb5d-4aeb-9aa3-e7b284f0f269\n   qubit_count:   12 \n   connectivity_type:  2D-lattice\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.VirtualQPU","page":"QPU","title":"Snowflurry.VirtualQPU","text":"VirtualQPU\n\nA data structure to represent a Quantum Simulator.  \n\nExample\n\njulia> qpu = VirtualQPU()\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflurry.jl\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.Client","page":"QPU","title":"Snowflurry.Client","text":"Client\n\nA data structure to represent a Client to a QPU service.  \n\nFields\n\nhost::String – URL of the QPU server.\nuser::String – Username.\naccess_token::String – User access token.\n\nExample\n\njulia> c = Client(host = \"http://example.anyonsys.com\", user = \"test_user\", access_token = \"not_a_real_access_token\")\nClient for QPU service:\n   host:         http://example.anyonsys.com\n   user:         test_user \n \n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.get_host","page":"QPU","title":"Snowflurry.get_host","text":"get_host(Client)\n\nReturns host URL of a Client to a QPU service.  \n\nExample\n\njulia> c = Client(host = \"http://example.anyonsys.com\", user = \"test_user\", access_token = \"not_a_real_access_token\");\n\njulia> get_host(c)\n\"http://example.anyonsys.com\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.submit_job","page":"QPU","title":"Snowflurry.submit_job","text":"submit_job(client::Client,circuit::QuantumCircuit,shot_count::Integer)\n\nSubmit a circuit to a Client of QPU service, requesting a number of  repetitions (shot_count). Returns circuitID.\n\nExample\n\njulia> submit_job(client, QuantumCircuit(qubit_count = 3, instructions = [sigma_x(3), control_z(2, 1), readout(1, 1)]), 100, \"project_id\")\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_status","page":"QPU","title":"Snowflurry.get_status","text":"get_status(client::Client,circuitID::String)::Tuple{Status,Dict{String,Int}}\n\nObtain the status of a circuit computation through a Client of a QPU service. Returns status::Dict containing status[\"type\"]:      -\"QUEUED\"   : Computation in queue     -\"RUNNING\"  : Computation being processed     -\"FAILED\"   : QPU service has returned an error message     -\"SUCCEEDED\": Computation is completed, result is available.\n\nIn the case of status[\"type\"]==\"FAILED\", the server error is contained in status[\"message\"].\n\nIn the case of status[\"type\"]==\"SUCCEEDED\", the second element in the return Tuple is  the histogram of the job results, as computed on the QPU.\n\nExample\n\njulia> jobID = submit_job(client, QuantumCircuit(qubit_count = 3, instructions = [sigma_x(3), control_z(2, 1), readout(1, 1)]), 100, \"project_id\")\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\njulia> get_status(client, jobID)\n(Status: SUCCEEDED\n, Dict(\"001\" => 100))\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.run_job","page":"QPU","title":"Snowflurry.run_job","text":"run_job(qpu::VirtualQPU, circuit::QuantumCircuit, shot_count::Integer)\n\nRun a circuit computation on a QPU simulator, repeatedly for the specified number of repetitions (shot_count). Returns the histogram of the completed circuit measurements, as prescribed by the Readouts present.\n\nExample\n\njulia> qpu = VirtualQPU();\n\njulia> run_job(qpu, QuantumCircuit(qubit_count = 3, instructions = [sigma_x(3), control_z(2, 1), readout(1, 1), readout(2, 2), readout(3, 3)]), 100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\nrun_job(qpu::AnyonYukonQPU, circuit::QuantumCircuit, shot_count::Integer)\n\nRun a circuit computation on a QPU service, repeatedly for the specified number of repetitions (shot_count). Returns the histogram of the completed circuit calculations, or an error message. If the circuit received in invalid - for instance, it is missing a Readout - it is not sent to the host, and an error is throw.\n\nExample\n\njulia> qpu = AnyonYukonQPU(client, \"project_id\");\n\njulia> run_job(qpu, QuantumCircuit(qubit_count = 3, instructions = [sigma_x(3), control_z(2, 1), readout(1, 1)]), 100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.transpile_and_run_job","page":"QPU","title":"Snowflurry.transpile_and_run_job","text":"transpile_and_run_job(qpu::VirtualQPU, circuit::QuantumCircuit,shot_count::Integer; transpiler::Transpiler = get_transpiler(qpu))\n\nThis method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a key-word argument. The transpiled circuit is then run on a QPU simulator, repeatedly for the specified number of repetitions (shot_count). Returns the histogram of the completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=VirtualQPU();\n\njulia> transpile_and_run_job(qpu, QuantumCircuit(qubit_count = 3, instructions = [sigma_x(3), control_z(2, 1), readout(1, 1), readout(2, 2), readout(3, 3)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\ntranspile_and_run_job(qpu::AnyonYukonQPU, circuit::QuantumCircuit,shot_count::Integer;transpiler::Transpiler=get_transpiler(qpu))\n\nThis method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a key-word argument. The transpiled circuit is then run on the AnyonYukonQPU, repeatedly for the specified number of repetitions (shot_count).\n\nReturns the histogram of the completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu = AnyonYukonQPU(client_anyon, \"project_id\");\n\njulia> transpile_and_run_job(qpu, QuantumCircuit(qubit_count = 3, instructions = [sigma_x(3), control_z(2, 1), readout(3, 3)]), 100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_transpiler","page":"QPU","title":"Snowflurry.get_transpiler","text":"get_transpiler(qpu::AbstractQPU)::Transpiler\n\nReturns the transpiler associated with this QPU.\n\nExample\n\njulia> qpu = AnyonYukonQPU(client, \"project_id\");\n\njulia> get_transpiler(qpu)\nSequentialTranspiler(Transpiler[CircuitContainsAReadoutTranspiler(), ReadoutsDoNotConflictTranspiler(), CastToffoliToCXGateTranspiler(), CastCXToCZGateTranspiler(), CastISwapToCZGateTranspiler(), SwapQubitsForAdjacencyTranspiler(LineConnectivity{6}\n1──2──3──4──5──6\n), CastSwapToCZGateTranspiler(), CompressSingleQubitGatesTranspiler(), SimplifyTrivialGatesTranspiler(1.0e-6), CastUniversalToRzRxRzTranspiler(), SimplifyRxGatesTranspiler(1.0e-6), CastRxToRzAndHalfRotationXTranspiler(), CompressRzGatesTranspiler(), SimplifyRzGatesTranspiler(1.0e-6), ReadoutsAreFinalInstructionsTranspiler(), UnsupportedGatesTranspiler()])\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.SequentialTranspiler","page":"QPU","title":"Snowflurry.SequentialTranspiler","text":"SequentialTranspiler(Vector{<:Transpiler})\n\nComposite transpiler object which is constructed from an array  of Transpiler stages. Calling      transpile(::SequentialTranspiler,::QuantumCircuit) will apply each stage in sequence to the input circuit and return a transpiled output circuit. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler = SequentialTranspiler([CompressSingleQubitGatesTranspiler(), CastToPhaseShiftAndHalfRotationXTranspiler()]);\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1), hadamard(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X────H──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z────X_90────Z_90────X_m90────Z──\n                                                              \nq[2]:───────────────────────────────────\n                                                              \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────Y─────────P(1.0472)──\n\nq[2]:────────────*───────────────\n                 |               \nq[3]:────────────X───────────────\n                                 \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──P(-2.0944)───────\n                        \nq[2]:────────────────*──\n                     |  \nq[3]:────────────────X──\n                        \n\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.AllToAllConnectivity","page":"QPU","title":"Snowflurry.AllToAllConnectivity","text":"AllToAllConnectivity <:AbstractConnectivity\n\nA data structure to represent all-to-all qubit connectivity in an Anyon System's QPU.   This connectivity type is encountered in simulated QPUs, such as the VirtualQPU\n\nExample\n\njulia> connectivity = AllToAllConnectivity()\nAllToAllConnectivity()\n\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.LineConnectivity","page":"QPU","title":"Snowflurry.LineConnectivity","text":"LineConnectivity <:AbstractConnectivity\n\nA data structure to represent linear qubit connectivity in an Anyon System's QPU.   This connectivity type is encountered in QPUs such as the AnyonYukonQPU\n\nFields\n\ndimension                  ::Int – Qubit count in this connectivity.\n\nExample\n\njulia> connectivity = LineConnectivity(6)\nLineConnectivity{6}\n1──2──3──4──5──6\n\n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.LatticeConnectivity","page":"QPU","title":"Snowflurry.LatticeConnectivity","text":"LatticeConnectivity <:AbstractConnectivity\n\nA data structure to represent 2D-lattice qubit connectivity in an Anyon System's QPU.   This connectivity type is encountered in QPUs such as the AnyonYamaskaQPU\n\nFields\n\nqubits_per_row    ::Vector{Int} – number of qubits in each line, when constructing the printout.\ndimensions        ::Vector{Int} – number of rows and columns (turned 45° in the printout).\n\nExample\n\nThe following lattice has 4 rows, made of qubits  [2, 6, 10], [1, 5, 9], [4, 8, 12] and [3, 7, 11], with each of those rows having 3 columns.\n\nThe corresponding qubits_per_row field is [2,4,4,2], the number of qubits in each line in the printed representation.  \n\njulia> connectivity = LatticeConnectivity(4, 3)\nLatticeConnectivity{4,3}\n        1 ──  2 \n        |     | \n  3 ──  4 ──  5 ──  6 \n        |     |     | \n        7 ──  8 ──  9 ── 10 \n              |     | \n             11 ── 12 \n\n\n\nLattices of arbitrary dimensions can be built:\n\njulia> connectivity = LatticeConnectivity(6, 4)\nLatticeConnectivity{6,4}\n              1 ──  2 \n              |     | \n        3 ──  4 ──  5 ──  6 \n        |     |     |     | \n  7 ──  8 ──  9 ── 10 ── 11 ── 12 \n        |     |     |     |     | \n       13 ── 14 ── 15 ── 16 ── 17 ── 18 \n              |     |     |     | \n             19 ── 20 ── 21 ── 22 \n                    |     | \n                   23 ── 24 \n\n\n\n\n\nNon-rectangular shapes can also be achieved by directly specifying the desired qubits_per_row as a Vector{Int}:\n\njulia> connectivity = LatticeConnectivity([5, 7, 8, 8, 7, 5])\nLatticeConnectivity{8,5}\n        1 ──  2 ──  3 ──  4 ──  5 \n        |     |     |     |     | \n  6 ──  7 ──  8 ──  9 ── 10 ── 11 ── 12 \n  |     |     |     |     |     |     | \n 13 ── 14 ── 15 ── 16 ── 17 ── 18 ── 19 ── 20 \n        |     |     |     |     |     |     | \n       21 ── 22 ── 23 ── 24 ── 25 ── 26 ── 27 ── 28 \n              |     |     |     |     |     |     | \n             29 ── 30 ── 31 ── 32 ── 33 ── 34 ── 35 \n                    |     |     |     |     | \n                   36 ── 37 ── 38 ── 39 ── 40 \n\n\n\n\n\n","category":"type"},{"location":"library/qpu.html#Snowflurry.path_search","page":"QPU","title":"Snowflurry.path_search","text":"path_search(origin::Int, target::Int, connectivity::AbstractConnectivity)\n\nFind the shortest path between origin and target qubits in terms of  Manhattan distance, using the Breadth-First Search algorithm, on any  connectivity::AbstractConnectivity.\n\nExample\n\njulia> connectivity = LineConnectivity(6)\nLineConnectivity{6}\n1──2──3──4──5──6\n\n\njulia> path = path_search(2, 5, connectivity)\n4-element Vector{Int64}:\n 5\n 4\n 3\n 2\n\n\nOn LatticeConnectivity, the print_connectivity() method is used to visualize the path. The qubits along the path between origin and target are marker with ( )\n\njulia> connectivity = LatticeConnectivity(6, 4)\nLatticeConnectivity{6,4}\n              1 ──  2 \n              |     | \n        3 ──  4 ──  5 ──  6 \n        |     |     |     | \n  7 ──  8 ──  9 ── 10 ── 11 ── 12 \n        |     |     |     |     | \n       13 ── 14 ── 15 ── 16 ── 17 ── 18 \n              |     |     |     | \n             19 ── 20 ── 21 ── 22 \n                    |     | \n                   23 ── 24 \n\n\njulia> path = path_search(3, 24, connectivity)\n8-element Vector{Int64}:\n 24\n 23\n 20\n 19\n 14\n 13\n  8\n  3\n\n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_adjacency_list","page":"QPU","title":"Snowflurry.get_adjacency_list","text":"get_adjacency_list(connectivity::AbstractConnectivity)::Dict{Int,Vector{Int}}\n\nGiven an object of type AbstractConnectivity, get_adjacency_list returns a Dict where key => value pairs are each qubit number => an Vector of the qubits that are adjacent (neighbors) to it on this particular connectivity.\n\nExample\n\njulia> connectivity = LineConnectivity(6)\nLineConnectivity{6}\n1──2──3──4──5──6\n\n\njulia> get_adjacency_list(connectivity)\nDict{Int64, Vector{Int64}} with 6 entries:\n  5 => [4, 6]\n  4 => [3, 5]\n  6 => [5]\n  2 => [1, 3]\n  3 => [2, 4]\n  1 => [2]\n\njulia> connectivity = LatticeConnectivity(4, 3)\nLatticeConnectivity{4,3}\n        1 ──  2 \n        |     | \n  3 ──  4 ──  5 ──  6 \n        |     |     | \n        7 ──  8 ──  9 ── 10 \n              |     | \n             11 ── 12 \n\n  \njulia> get_adjacency_list(connectivity)\nDict{Int64, Vector{Int64}} with 12 entries:\n  5  => [2, 8, 4, 6]\n  12 => [9, 11]\n  8  => [5, 11, 7, 9]\n  1  => [4, 2]\n  6  => [9, 5]\n  11 => [8, 12]\n  9  => [6, 12, 8, 10]\n  3  => [4]\n  7  => [4, 8]\n  4  => [1, 7, 3, 5]\n  2  => [5, 1]\n  10 => [9]\n\n\nnote: Note\nget_adjacency_list cannot be performed for AllToAllConnectivity, as in such a connectivity, all qubits are adjacent,  with no upper bound on the number of qubits. A finite list of adjacent qubits thus cannot be constructed. \n\n\n\n\n\n","category":"function"},{"location":"library/qpu.html#Snowflurry.get_qubits_distance","page":"QPU","title":"Snowflurry.get_qubits_distance","text":"get_qubits_distance(target_1::Int, target_2::Int, ::AbstractConnectivity)\n\nFind the length of the shortest path between target qubits in terms of  Manhattan distance, using the Breadth-First Search algorithm, on any  connectivity::AbstractConnectivity.\n\nExample\n\njulia>  connectivity = LineConnectivity(6)\nLineConnectivity{6}\n1──2──3──4──5──6\n\n\njulia> get_qubits_distance(2, 5, connectivity)\n3\n\njulia> connectivity = LatticeConnectivity(6, 4)\nLatticeConnectivity{6,4}\n              1 ──  2 \n              |     | \n        3 ──  4 ──  5 ──  6 \n        |     |     |     | \n  7 ──  8 ──  9 ── 10 ── 11 ── 12 \n        |     |     |     |     | \n       13 ── 14 ── 15 ── 16 ── 17 ── 18 \n              |     |     |     | \n             19 ── 20 ── 21 ── 22 \n                    |     | \n                   23 ── 24 \n\n\njulia> get_qubits_distance(3, 24, connectivity)\n7\n\n\n\n\n\n\n","category":"function"},{"location":"tutorials/basics.html#Basic-Concepts","page":"Basics","title":"Basic Concepts","text":"","category":"section"},{"location":"tutorials/basics.html#Quantum-Circuits","page":"Basics","title":"Quantum Circuits","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In quantum computing, a quantum circuit represents a sequence of operations that are intended to be applied to qubits.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's start with an example. We are going to start by importing Snowflurry.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"using Snowflurry","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can then create an empty QuantumCircuit by specifying the number of qubits (qubit_count) and classical bits (bit_count) the circuit will involve.  The classical bits (or result bits) are ordinary memory registries that each store the output of a Readout operation on a particular qubit.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"c = QuantumCircuit(qubit_count = 2, bit_count = 2)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:\n     \nq[2]:\n     ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Optionally, if bit_count is not specified it will assume the same value as qubit_count. ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"c = QuantumCircuit(qubit_count = 2)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:\n     \nq[2]:\n     ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"You can visualize a QuantumCircuit object at any point by simply printing it:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"print(c)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:\n     \nq[2]:\n     ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"note: Note\nIn Snowflurry, we assume all qubits are initialized to be in state 0 (ground state).","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We have not yet added any quantum operation to our circuit and it looks empty! So, let's add some quantum operations!","category":"page"},{"location":"tutorials/basics.html#Quantum-Gates","page":"Basics","title":"Quantum Gates","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Basic logical operations on qubits are commonly called quantum logic gates or simply gates. We will quite often talk about single-qubit gates, two-qubit gates or multiple-qubit gates in quantum information theory.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's start by adding a single-qubit gate called the Hadamard gate to our circuit, c, and specify that it will only operate on qubit '1'. The Hadamard gate is one of the most frequently used gates in quantum computing as it puts its target qubit into a perfect superposition of state left0rightrangle and left1rightrangle.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We build this gate by calling hadamard() function with the target qubit = 1, and we add it to our circuit c by calling the push! function:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"push!(c, hadamard(1))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:──H──\n          \nq[2]:─────\n","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"warning: Indexing in Julia\nUnlike C++ or Python, indexing in Julia starts from \"1\" and not \"0\"!","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Note the exclamation mark at the end of push! which emphasizes the fact that we have called a mutating function that will change the argument c (our quantum circuit).","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"If we now print circuit c, we will see the following output","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"print(c)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:──H──\n          \nq[2]:─────\n","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Now let's add a famous two-qubit gate, control_x, also known as the CNOT gate in the quantum information community.  Here the first argument is the control_qubit = 1, and the second is the target_qubit = 2.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"push!(c, control_x(1, 2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Voilà! You just made your first quantum circuit with Snowflurry that does something interesting.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"It puts a two-qubit register in a maximally-entangled quantum state (fracleft00rightrangle+left11rightranglesqrt2). (The qubit ordering convention used is qubit number 1 on the left, with each following qubit to the right of it.) This state is one of the four celebrated Bell States or the EPR states. These states do not have classical counterparts and are among the building blocks of many interesting ideas in quantum computing and quantum communication.","category":"page"},{"location":"tutorials/basics.html#Circuit-Simulation","page":"Basics","title":"Circuit Simulation","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"You can verify what your circuit will ideally do on a real computer by simulating the circuit on your own local machine:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"simulate(c)\n# output\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"The output of the simulate() function is a Ket object. A Ket is a complex vector that represents the wavefunction of a quantum object such as our two-qubit system.","category":"page"},{"location":"tutorials/basics.html#Histogram","page":"Basics","title":"Histogram","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In the previous section, we used the simulate function to calculate the wavefunction of a two-qubit quantum register, after the circuit, c, is applied to it. However, in the real world, we do not have direct access to the wavefunction of a quantum register. Rather, we need to run the quantum circuit several times over (several shots) on the quantum processor and measure the qubits states at the end of each shot. The result of each shot is a bitstring that tells us which qubits were measured to be in state left0rightrangle and which qubits were measured to be in state left1rightrangle. The probability of getting a bitstring then depends on the wavefunction.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can indeed mimick this behaviour in our simulations as well. This can be achieved by using the plot_histogram function from the SnowflurryPlots library. For example, we can generate a histogram which shows the measurement output distribution after taking running the circuit c for a given number of shots, let's say 100 times, on a quantum computer simulator:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"using SnowflurryPlots\nplot_histogram(c, 100)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"(Image: Measurement results histogram)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In the next tutorial, we will discuss how to run the above circuit on a virtual quantum processor.","category":"page"},{"location":"tutorials/anyon_qpu.html#Running-a-Circuit-on-Real-Hardware","page":"Real hardware","title":"Running a Circuit on Real Hardware","text":"","category":"section"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"using Snowflurry\n\nDocTestSetup = quote\n    ENV[\"THUNDERHEAD_USER\"] = \"test-user\"\n    ENV[\"THUNDERHEAD_API_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"THUNDERHEAD_HOST\"] = \"yukon.anyonsys.com\"\n    ENV[\"THUNDERHEAD_PROJECT_ID\"] = \"9d6949c8-bb5d-4aeb-9aa3-e7b284f0f269\"\nend","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"In the previous tutorial, we learnt how to run a quantum circuit on a virtual QPU. We also learnt that every QPU driver should adhere to the AbstractQPU API.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"In this tutorial, we will learn how to submit a job to real hardware. At the moment, we have only implemented the driver for Anyon's quantum processors but we welcome contributions from other members of the community, as well as other hardware vendors to use Snowflurry with a variety of machines.","category":"page"},{"location":"tutorials/anyon_qpu.html#Anyon-QPU","page":"Real hardware","title":"Anyon QPU","text":"","category":"section"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"note: Note\nThis tutorial is written for the selected partners and users who have been granted access to Anyon's hardware.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"The current release of Snowflurry supports Anyon's Yukon quantum processor (see AnyonYukonQPU) which is made from an array of 6 tunable superconducting transmon qubits interleaved with 5 tunable couplers. The following generation of QPU, called AnyonYamaskaQPU is also implemented, in which 12 qubits are arranged in a lattice, along with 14 couplers. ","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"We can start by defining a qpu variable to point to the host computer that will queue jobs on the quantum processor and provide it with user credentials. A valid project_id is also required to submit jobs on Anyon infrastructure:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"using Snowflurry\n\nqpu = AnyonYukonQPU(host = \"http://yukon.anyonsys.com\", user = \"USER_NAME\", access_token = \"API_KEY\", project_id = \"9d6949c8-bb5d-4aeb-9aa3-e7b284f0f269\")","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"danger: Keep your credentials safe!\nIf you plan to make your code public or work in a shared environment, it is best to use environment variables to set the user credentials rather than hardcoding them!","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"We can now print the qpu object to print further information about the hardware:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"println(qpu)\n\n# output\n\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   project_id:    9d6949c8-bb5d-4aeb-9aa3-e7b284f0f269\n   qubit_count:   6\n   connectivity_type:  linear","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"Alternatively, one can use the get_metadata function to obtain a Dict object corresponding to the QPU information:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"get_metadata(qpu)\n\n# output\n\nDict{String, Union{Int64, String}} with 6 entries:\n  \"qubit_count\"       => 6\n  \"generation\"        => \"Yukon\"\n  \"manufacturer\"      => \"Anyon Systems Inc.\"\n  \"serial_number\"     => \"ANYK202201\"\n  \"project_id\"        => \"9d6949c8-bb5d-4aeb-9aa3-e7b284f0f269\"\n  \"connectivity_type\" => \"linear\"","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"We now continue to build a small circuit to create a Bell state as was presented in the previous tutorials:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"c = QuantumCircuit(qubit_count = 2)\npush!(c, hadamard(1), control_x(1, 2), readout(1, 1), readout(2, 2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:──H────*────✲───────\n            |            \nq[2]:───────X─────────✲──","category":"page"},{"location":"tutorials/anyon_qpu.html#Circuit-Transpilation","page":"Real hardware","title":"Circuit Transpilation","text":"","category":"section"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"The circuit above cannot be directly executed on the quantum processor. This is because the quantum processor only implements a set of native gates. This means that any arbitrary gate should first be transpiled into a set of native gates that can run on the QPU.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"If you examine the src/anyon/anyon.jl file, you notice that Anyon Yukon Processor implements the following set of native gates:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":" set_of_native_gates=[\n        PhaseShift,\n        Pi8,\n        Pi8Dagger,\n        SigmaX,\n        SigmaY,\n        SigmaZ,\n        X90,\n        XM90,\n        Y90,\n        YM90,\n        Z90,\n        ZM90,\n        ControlZ,\n    ]","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"Snowflurry is designed to allow users to design and use their own transpilers for different QPUs. Alternatively, a user may opt not to use the default transpilers that are implemented for each QPU driver.","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"Let's see how we can transpile the above circuit, c, to a circuit that can run on Anyon's QPU. We first define a transpiler object that refers to the default transpiler for AnyonYukonQPU which shipped with Snowflurry:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"transpiler = get_transpiler(qpu)","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"Next, let's transpile the original circuit:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"c_transpiled = transpile(transpiler, c)\n\n# output\n\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2\nq[1]:──Z_90────────────X_90────Z_90────────────────────*────────────────────────────✲───────\n                                                       |                                    \nq[2]:──────────Z_90────────────────────X_90────Z_90────Z────Z_90────X_90────Z_90─────────✲──","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"The final circuit c_transpiled is now ready to be submitted to the QPU:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"shot_count = 200\nresult = run_job(qpu, c_transpiled, shot_count)\nprintln(result)","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"which should print something like:","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"Dict(\"11\" => 97, \"00\" => 83, \"01\" => 11, \"10\" => 9)","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"The results show that the samples are mostly sampled between state left00rightrangle and left11rightrangle. We do see some finite population in left01rightrangle and left10rightrangle that are due to the error in the computation. (The qubit ordering convention used is qubit number 1 on the left, with each following qubit to the right of it.)","category":"page"},{"location":"tutorials/anyon_qpu.html","page":"Real hardware","title":"Real hardware","text":"note: Note\nThe user can skip the explicit transpiling step by using the transpile_and_run_job function. This function will use the default transpiler of the QPU and then submit the job to the machine.","category":"page"},{"location":"library/pauli_sim.html#Pauli-Simulator","page":"Pauli Simulator","title":"Pauli Simulator","text":"","category":"section"},{"location":"library/pauli_sim.html","page":"Pauli Simulator","title":"Pauli Simulator","text":"Snowflurry provides tools for the efficient storage and manipulation of Pauli group elements.","category":"page"},{"location":"library/pauli_sim.html","page":"Pauli Simulator","title":"Pauli Simulator","text":"Snowflurry.PauliGroupElement\nget_pauli\nBase.:*(p1::Snowflurry.PauliGroupElement, p2::Snowflurry.PauliGroupElement)\nget_quantum_circuit\nget_negative_exponent\nget_imaginary_exponent","category":"page"},{"location":"library/pauli_sim.html#Snowflurry.PauliGroupElement","page":"Pauli Simulator","title":"Snowflurry.PauliGroupElement","text":"PauliGroupElement\n\nA Pauli group element which is represented using the approach of Dehaene and De Moor (2003).\n\nThe get_pauli functions should be used to generate PauliGroupElement objects.\n\n\n\n\n\n","category":"type"},{"location":"library/pauli_sim.html#Snowflurry.get_pauli","page":"Pauli Simulator","title":"Snowflurry.get_pauli","text":"get_pauli(circuit::QuantumCircuit; imaginary_exponent::Integer=0,\n    negative_exponent::Integer=0)::PauliGroupElement\n\nReturns a PauliGroupElement given a circuit containing Pauli gates.\n\nA Pauli group element corresponds to i^delta (-1)^epsilon sigma_a, where delta and epsilon are set by specifying imaginary_exponent and negative_exponent, respectively. The exponents must be 0 or 1. Their default value is 0. As for sigma_a, it is a tensor product of Pauli operators. The Pauli operators are specified in the circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 2);\n\njulia> push!(circuit, sigma_x(1), sigma_y(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\njulia> get_pauli(circuit, imaginary_exponent=1, negative_exponent=1)\nPauli Group Element:\n-1.0im*X(1)*Y(2)\n\n\n\n\nIf multiple Pauli gates are applied to the same qubit in the circuit, the gates are multiplied with the first gate in the circuit being the rightmost gate in the multiplication.\n\njulia> circuit = QuantumCircuit(qubit_count = 1);\n\njulia> push!(circuit, sigma_x(1), sigma_z(1))\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──X────Z──\n               \n\n\n\njulia> get_pauli(circuit)\nPauli Group Element:\n1.0im*Y(1)\n\n\n\n\n\n\n\n\nget_pauli(gate::AbstractGateSymbol, num_qubits::Integer; imaginary_exponent::Integer=0,\n    negative_exponent::Integer=0)::PauliGroupElement\n\nReturns a PauliGroupElement given a gate and the number of qubits.\n\nA Pauli group element corresponds to i^delta (-1)^epsilon sigma_a, where delta and epsilon are set by specifying imaginary_exponent and negative_exponent, respectively. The exponents must be 0 or 1. Their default value is 0. As for sigma_a, it is a tensor product of Pauli operators. In this variant of the get_pauli function, a single Pauli operator is set by providing a gate. The number of qubits is specified by num_qubits.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> get_pauli(gate, num_qubits)\nPauli Group Element:\n1.0*X(2)\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/pauli_sim.html#Base.:*-Tuple{Snowflurry.PauliGroupElement, Snowflurry.PauliGroupElement}","page":"Pauli Simulator","title":"Base.:*","text":"Base.:*(p1::PauliGroupElement, p2::PauliGroupElement)::PauliGroupElement\n\nReturns the product of two PauliGroupElement objects.\n\nThe PauliGroupElement objects must be associated with the same number of qubits.\n\nExamples\n\njulia> pauli_z = get_pauli(sigma_z(1), 1)\nPauli Group Element:\n1.0*Z(1)\n\n\n\njulia> pauli_y = get_pauli(sigma_y(1), 1)\nPauli Group Element:\n1.0*Y(1)\n\n\n\njulia> pauli_z*pauli_y\nPauli Group Element:\n-1.0im*X(1)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/pauli_sim.html#Snowflurry.get_quantum_circuit","page":"Pauli Simulator","title":"Snowflurry.get_quantum_circuit","text":"get_quantum_circuit(pauli::PauliGroupElement)::QuantumCircuit\n\nReturns the Pauli gates of a PauliGroupElement as a QuantumCircuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 2);\n\njulia> push!(circuit, sigma_x(1), sigma_y(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\njulia> pauli = get_pauli(circuit, imaginary_exponent = 1, negative_exponent = 1)\nPauli Group Element:\n-1.0im*X(1)*Y(2)\n\n\n\njulia> get_quantum_circuit(pauli)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/pauli_sim.html#Snowflurry.get_negative_exponent","page":"Pauli Simulator","title":"Snowflurry.get_negative_exponent","text":"get_negative_exponent(pauli::PauliGroupElement)::Int\n\nReturns the negative exponent of a PauliGroupElement.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> pauli = get_pauli(gate, num_qubits, negative_exponent = 1)\nPauli Group Element:\n-1.0*X(2)\n\n\n\njulia> get_negative_exponent(pauli)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library/pauli_sim.html#Snowflurry.get_imaginary_exponent","page":"Pauli Simulator","title":"Snowflurry.get_imaginary_exponent","text":"get_imaginary_exponent(pauli::PauliGroupElement)::Int\n\nReturns the imaginary exponent of a PauliGroupElement.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> pauli = get_pauli(gate, num_qubits, imaginary_exponent = 1)\nPauli Group Element:\n1.0im*X(2)\n\n\n\njulia> get_imaginary_exponent(pauli)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library/pauli_sim.html","page":"Pauli Simulator","title":"Pauli Simulator","text":"DocTestSetup = nothing","category":"page"},{"location":"library/quantum_gates.html#Quantum-Gates","page":"Quantum Gates","title":"Quantum Gates","text":"","category":"section"},{"location":"library/quantum_gates.html","page":"Quantum Gates","title":"Quantum Gates","text":"AbstractGateSymbol\nControlled\nGate\neye\nidentity_gate\nsigma_p\nsigma_m\nsigma_x\nsigma_y\nsigma_z\nhadamard\npi_8\npi_8_dagger\nx_90\nx_minus_90\ny_90\ny_minus_90\nz_90\nz_minus_90\nrotation\nrotation_x\nrotation_y\nrotation_z\nphase_shift\nuniversal\ncontrol_z\ncontrol_x\niswap\nswap\ntoffoli\niswap_dagger\nBase.:*(M::Gate, x::Ket)\napply_instruction!\nget_operator\ninv(gate::AbstractGateSymbol)\nmove_instruction","category":"page"},{"location":"library/quantum_gates.html#Snowflurry.AbstractGateSymbol","page":"Quantum Gates","title":"Snowflurry.AbstractGateSymbol","text":"AbstractGateSymbol\n\nA GateSymbol is an instantiation of an AbstractGateSymbol, which, when used inside a Gate (specifing placement) can be added to a QuantumCircuit to apply an operator to one or more target qubits. AbstractGateSymbol is useful to dispatch all GateSymbols to default implementation of functions such as getconnectedqubits().  Those functions are then specialized for GateSymbols requiring a different implementation. \n\nAbstractGateSymbol is an abstract type, which means that it cannot be instantiated.  Instead, each concrete type of GateSymbols is a struct which is a subtype of AbstractGateSymbol. Each descendant of AbstractGateSymbol must implement at least the following methods:\n\nget_operator(gate::AbstractGateSymbol, T::Type{<:Complex}=ComplexF64})::AbstractOperator\nget_num_connected_qubits(gate::AbstractGateSymbol)::Integer\n\nExamples\n\nA struct must be defined for each new GateSymbol type, such as the following X_45 GateSymbol which applies a 45 rotation about the X axis:\n\njulia> struct X45 <: AbstractGateSymbol\n       end;\n\nWe need to define how many connected qubits our new GateSymbol has.\n\njulia> Snowflurry.get_num_connected_qubits(::X45) = 1\n\n\nA Gate constructor must be defined as:\n\njulia> x_45(target::Integer) = Gate(X45(), [target]);\n\nalong with an Operator constructor, with default precision ComplexF64, defined as:\n\njulia> x_45(T::Type{<:Complex} = ComplexF64) = rotation_x(π/4, T);\n\n\nTo simulate the effect of the gate in a QuantumCircuit or when applied to a Ket, the function get_operator must be extended.\n\njulia> Snowflurry.get_operator(gate::X45, T::Type{<:Complex} = ComplexF64) = rotation_x(π/4, T);\n\n\nThe gate inverse can also be specified by extending the inv function.\n\njulia> Base.inv(::X45) = Snowflurry.RotationX(-π/4);\n\n\nAn instance of the X_45 Gate can now be created, along with its inverse:\n\njulia> x_45_gate = x_45(1)\nGate Object: X45\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im\n0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\njulia> inv(x_45_gate)\nGate Object: Snowflurry.RotationX\nParameters: \ntheta\t: -0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    -0.0 + 0.3826834323650898im\n-0.0 + 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\n\nTo enable printout of a QuantumCircuit containing our new GateSymbol type, a display symbol  must be defined as follows.\n\njulia> Snowflurry.gates_display_symbols[X45] = [\"X45\"];\n\n\nIf this Gate is to be sent as an instruction to a hardware QPU,  an instruction String must be defined.\n\njulia> Snowflurry.instruction_symbols[X45] = \"x45\";\n\n\nA circuit containing this Gate can now be constructed:\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [x_45_gate])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──X45──\n\nq[2]:───────\n\n\nIn addition, a Controlled{X45} gate can be constructed using:\n\njulia> control = 1; target = 2;\n\njulia> controlled(x_45(target), [control])\nGate Object: Controlled{X45}\nConnected_qubits\t: [1, 2]\nOperator:\n(4, 4)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im\n0.0 + 0.0im    0.0 + 0.0im    0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_gates.html#Snowflurry.Controlled","page":"Quantum Gates","title":"Snowflurry.Controlled","text":"Controlled{G<:AbstractGateSymbol}<:AbstractGateSymbol\n\nThe Controlled object allows the construction of a controlled AbstractGateSymbol using an Operator  (the kernel) and the corresponding number of control qubits. A helper function, controlled can be used to easily create both controlled AbstractGateSymbols and controlled Gates. The apply_gate will call into the optimized routine, and if no such routine is present, it will fall-back to casting the operator into the equivalent DenseOperator and applying the created operator.\n\nExamples\n\nWe can use the controlled function to create a controlled-Hadamard gate\n\njulia> controlled_hadamard = controlled(hadamard(2), [1])\nGate Object: Controlled{Snowflurry.Hadamard}\nConnected_qubits\t: [1, 2]\nOperator:\n(4, 4)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.7071067811865475 + 0.0im    0.7071067811865475 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.7071067811865475 + 0.0im    -0.7071067811865475 + 0.0im\n\n\nIt can then be used in a QuantumCircuit as any other Gate, and its display symbol is  inherited from the display symbol of the single-target Hadamard Gate:\n\njulia> circuit=QuantumCircuit(qubit_count=2,instructions = [controlled_hadamard])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──H──\n          \n\nIn general, a Controlled with an arbitraty number of targets and controls can be  constructed. For instance, the following constructs the equivalent of a Toffoli Gate,  but as a ConnectedGate{SigmaX}, with control_qubits=[1,2] and target_qubit=[3]:\n\njulia> toffoli_as_controlled_gate = controlled(sigma_x(3), [1, 2])\nGate Object: Controlled{Snowflurry.SigmaX}\nConnected_qubits\t: [1, 2, 3]\nOperator:\n(8, 8)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_gates.html#Snowflurry.Gate","page":"Quantum Gates","title":"Snowflurry.Gate","text":"Gate <: AbstractInstruction\n\nGate is an implementation of an AbstractInstruction that specifies an AbstractGateSymbol and its placement inside a QuantumCircuit.  The placement corresponds to the target qubit (or qubits) on which the Gate operates.\n\nExamples\n\njulia> gate = iswap(1, 2)\nGate Object: Snowflurry.ISwap\nConnected_qubits\t: [1, 2]\nOperator:\n(4, 4)-element Snowflurry.SwapLikeOperator:\nUnderlying data ComplexF64:\nEquivalent DenseOperator:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n\njulia> gate = universal(3, pi/2, -pi/2, pi/2)\nGate Object: Snowflurry.Universal\nParameters:\ntheta\t: 1.5707963267948966\nphi\t: -1.5707963267948966\nlambda\t: 1.5707963267948966\n\nConnected_qubits\t: [3]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    -4.329780281177466e-17 - 0.7071067811865475im\n4.329780281177466e-17 - 0.7071067811865475im    0.7071067811865476 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_gates.html#Snowflurry.eye","page":"Quantum Gates","title":"Snowflurry.eye","text":"eye(),\neye(size::Integer)\n\nReturn the identity matrix as a DenseOperator, which is defined as:\n\nI = beginbmatrix\n    1  0 \n    0  1\n    endbmatrix\n\nCalling eye(size) will produce an identity matrix DenseOperator  of dimensions (size,size).\n\nExamples\n\njulia> eye()\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\njulia> eye(4)\n(4, 4)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.identity_gate","page":"Quantum Gates","title":"Snowflurry.identity_gate","text":"identity_gate(target)\n\nReturn the Identity Gate, which applies the identity_gate() IdentityOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.sigma_p","page":"Quantum Gates","title":"Snowflurry.sigma_p","text":"sigma_p()\n\nReturn the spin-frac12 raising Operator, which is defined as:\n\nsigma_+ = beginbmatrix\n    0  1 \n    0  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.sigma_m","page":"Quantum Gates","title":"Snowflurry.sigma_m","text":"sigma_m()\n\nReturn the spin-frac12 lowering Operator, which is defined as:\n\nsigma_- = beginbmatrix\n    0  0 \n    1  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.sigma_x","page":"Quantum Gates","title":"Snowflurry.sigma_x","text":"sigma_x()\n\nReturn the Pauli-X AntiDiagonalOperator, which is defined as:\n\nsigma_x = beginbmatrix\n    0  1 \n    1  0\n    endbmatrix\n\n\n\n\n\nsigma_x(target)\n\nReturn the Pauli-X Gate, which applies the sigma_x() AntiDiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.sigma_y","page":"Quantum Gates","title":"Snowflurry.sigma_y","text":"sigma_y()\n\nReturn the Pauli-Y Operator, which is defined as:\n\nsigma_y = beginbmatrix\n    0  -i \n    i  0\n    endbmatrix\n\n\n\n\n\nsigma_y(target)\n\nReturn the Pauli-Y Gate, which applies the sigma_y() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.sigma_z","page":"Quantum Gates","title":"Snowflurry.sigma_z","text":"sigma_z()\n\nReturn the Pauli-Z Operator, which is defined as:\n\nsigma_z = beginbmatrix\n    1  0 \n    0  -1\n    endbmatrix\n\n\n\n\n\nsigma_z(target)\n\nReturn the Pauli-Z Gate, which applies the sigma_z() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.hadamard","page":"Quantum Gates","title":"Snowflurry.hadamard","text":"hadamard()\n\nReturn the Hadamard Operator, which is defined as:\n\nH = frac1sqrt2beginbmatrix\n    1  1 \n    1  -1\n    endbmatrix\n\n\n\n\n\nhadamard(target)\n\nReturn the Hadamard Gate, which applies the hadamard() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.pi_8","page":"Quantum Gates","title":"Snowflurry.pi_8","text":"pi_8()\n\nReturn the Operator for the π8 gate, which is defined as:\n\nT = beginbmatrix\n    1  0 \n    0  e^ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8(target)\n\nReturn a π8 Gate (also known as a T Gate), which applies the pi_8() DiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.pi_8_dagger","page":"Quantum Gates","title":"Snowflurry.pi_8_dagger","text":"pi_8_dagger()\n\nReturn the adjoint DiagonalOperator of the π8 gate, which is defined as:\n\nT^dagger = beginbmatrix\n    1  0 \n    0  e^-ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8_dagger(target)\n\nReturn an adjoint π8 Gate (also known as a T^dagger Gate), which applies the pi_8_dagger() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.x_90","page":"Quantum Gates","title":"Snowflurry.x_90","text":"x_90()\n\nReturn the Operator which applies a π2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -i \n    -i  1\n    endbmatrix\n\n\n\n\n\nx_90(target)\n\nReturn a Gate that applies a 90 rotation about the X axis as defined by the x_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.x_minus_90","page":"Quantum Gates","title":"Snowflurry.x_minus_90","text":"x_minus_90()\n\nReturn the Operator which applies a -π2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  i \n    i  1\n    endbmatrix\n\n\n\n\n\nx_minus_90(target)\n\nReturn a Gate that applies a -90 rotation about the X axis as defined by the x_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.y_90","page":"Quantum Gates","title":"Snowflurry.y_90","text":"y_90()\n\nReturn the Operator which applies a π2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -1 \n    1  1\n    endbmatrix\n\n\n\n\n\ny_90(target)\n\nReturn a Gate that applies a 90 rotation about the Y axis as defined by the y_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.y_minus_90","page":"Quantum Gates","title":"Snowflurry.y_minus_90","text":"y_minus_90()\n\nReturn the Operator which applies a -π2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  1 \n    -1  1\n    endbmatrix\n\n\n\n\n\ny_minus_90(target)\n\nReturn a Gate that applies a -90 rotation about the Y axis as defined by the y_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.z_90","page":"Quantum Gates","title":"Snowflurry.z_90","text":"z_90()\n\nReturn the Operator which applies a π2 rotation about the Z axis.\n\nThe Operator is defined as: ```math R_z\\left(\\frac{\\pi}{2}\\right) = \\begin{bmatrix}     e^{-i\\frac{pi}{4} & 0 \\[0.5em]     0 & e^{i\\frac{pi}{4}} \\end{bmatrix}.\n\n\n\n\n\nz_90(target)\n\nReturn a Gate that applies a 90 rotation about the Z axis as defined by the z_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.z_minus_90","page":"Quantum Gates","title":"Snowflurry.z_minus_90","text":"z_minus_90()\n\nReturn the Operator which applies a -π2 rotation about the Z axis. The Operator is defined as:\n\nR_zleft(-fracpi2right) = beginbmatrix\n    e^ifracpi4  0 05em\n    0  e^-ifracpi4\nendbmatrix\n\n\n\n\n\nz_minus_90(target)\n\nReturn a Gate that applies a -90 rotation about the Z axis as defined by the z_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.rotation","page":"Quantum Gates","title":"Snowflurry.rotation","text":"rotation(theta, phi)\n\nReturn the Operator which applies a rotation theta about an axis vecn defined by: vecn=cos(phi)X+sin(phi)Y.\n\nThe Operator is defined as:\n\nR(theta phi) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -i e^-iphi mathrmsinleft(fractheta2right) 05em\n    -i e^iphi mathrmsinleft(fractheta2right) \n        mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation(target, theta, phi)\n\nReturn a gate that applies a rotation theta to the target qubit about an axis vecn defined by: vecn=cos(phi)X+sin(phi)Y.\n\nThe corresponding Operator is rotation(theta, phi).\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.rotation_x","page":"Quantum Gates","title":"Snowflurry.rotation_x","text":"rotation_x(theta)\n\nReturn the Operator which applies a rotation theta about the X axis.\n\nThe Operator is defined as:\n\nR_x(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -imathrmsinleft(fractheta2right) 05em\n-imathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_x(target, theta)\n\nReturn a Gate that applies a rotation theta about the X axis of the target qubit.\n\nThe corresponding Operator is rotation_x(theta).\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.rotation_y","page":"Quantum Gates","title":"Snowflurry.rotation_y","text":"rotation_y(theta)\n\nReturn the Operator that applies a rotation theta about the Y axis of the target qubit.\n\nThe Operator is defined as:\n\nR_y(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -mathrmsinleft(fractheta2right) 05em\nmathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_y(target, theta)\n\nReturn a Gate that applies a rotation theta about the Y axis of the target qubit.\n\nThe corresponding Operator is rotation_y(theta).\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.rotation_z","page":"Quantum Gates","title":"Snowflurry.rotation_z","text":"rotation_z(lambda)\n\nReturn the DiagonalOperator that applies a rotation of z.\n\nThe DiagonalOperator is defined as:\n\nR_z(lambda) = beginbmatrix\n    e^-ifraclambda2  0 05em\n    0  e^ifraclambda2\nendbmatrix\n\n\n\n\n\nrotation_z(target, lambda)\n\nReturn a Gate that applies a rotation lambda about the Z axis of the target qubit.\n\nThe corresponding Operator is rotation_z(lambda).\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.phase_shift","page":"Quantum Gates","title":"Snowflurry.phase_shift","text":"phase_shift(phi)\n\nReturn the DiagonalOperator that applies a phase shift phi.\n\nThe DiagonalOperator is defined as:\n\nP(phi) = beginbmatrix\n    1  0 05em\n    0  e^iphi\nendbmatrix\n\n\n\n\n\nphase_shift(target, phi)\n\nReturn a Gate that applies a phase shift phi to the target qubit as defined by the phase_shift(phi) DiagonalOperator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.universal","page":"Quantum Gates","title":"Snowflurry.universal","text":"universal(theta, phi, lambda)\n\nReturn the Operator which performs a rotation about the angles theta, phi, and lambda. See: Theorem 4.1 in Quantum Computation and Quantum Information by Nielsen and Chuang.\n\nThe Operator is defined as:\n\nU(theta phi lambda) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -e^ilambdamathrmsinleft(fractheta2right) 05em\n    e^iphimathrmsinleft(fractheta2right) \n        e^ileft(phi+lambdaright)mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nuniversal(target, theta, phi, lambda)\n\nReturn a gate which rotates the target qubit given the angles theta, phi, and lambda. See: Theorem 4.1 in Quantum Computation and Quantum Information by Nielsen and Chuang.\n\nThe corresponding Operator is universal(theta, phi, lambda).\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.control_z","page":"Quantum Gates","title":"Snowflurry.control_z","text":"control_z()\n\nReturn the controlled-Z Operator, which is defined as:\n\nCZ = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\n    endbmatrix\n\n\n\n\n\ncontrol_z(control_qubit, target_qubit)\n\nReturn a controlled-Z gate given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_z().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.control_x","page":"Quantum Gates","title":"Snowflurry.control_x","text":"control_x()\n\nReturn the controlled-X (or controlled NOT) Operator, which is defined as:\n\nCX = CNOT = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endbmatrix\n\n\n\n\n\ncontrol_x(control_qubit, target_qubit)\n\nReturn a controlled-X gate (also known as a controlled NOT gate) given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_x().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.iswap","page":"Quantum Gates","title":"Snowflurry.iswap","text":"iswap()\n\nReturn the imaginary swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap(qubit_1, qubit_2)\n\nReturn the imaginary swap Gate which applies the imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.swap","page":"Quantum Gates","title":"Snowflurry.swap","text":"swap()\n\nReturn the swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\nswap(qubit_1, qubit_2)\n\nReturn the swap Gate which applies the swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is swap().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.toffoli","page":"Quantum Gates","title":"Snowflurry.toffoli","text":"toffoli()\n\nReturn the Toffoli Operator, which is defined as:\n\nCCX = CCNOT = beginbmatrix\n    1  0  0  0  0  0  0  0 \n    0  1  0  0  0  0  0  0 \n    0  0  1  0  0  0  0  0 \n    0  0  0  1  0  0  0  0 \n    0  0  0  0  1  0  0  0 \n    0  0  0  0  0  1  0  0 \n    0  0  0  0  0  0  0  1 \n    0  0  0  0  0  0  1  0\n    endbmatrix\n\n\n\n\n\ntoffoli(control_qubit_1, control_qubit_2, target_qubit)\n\nReturn a Toffoli gate (also known as a CCNOT gate) given two control qubits and a target_qubit.\n\nThe corresponding Operator is toffoli().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.iswap_dagger","page":"Quantum Gates","title":"Snowflurry.iswap_dagger","text":"iswap_dagger()\n\nReturn the adjoint of the imaginary swap Operator, which is defined as:\n\niSWAP^dagger = beginbmatrix\n    1  0  0  0 \n    0  0  -i  0 \n    0  -i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap_dagger(qubit_1, qubit_2)\n\nReturn the adjoint imaginary swap Gate which applies the adjoint imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap_dagger().\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Base.:*-Tuple{Gate, Ket}","page":"Quantum Gates","title":"Base.:*","text":"Base.:*(M::Gate, x::Ket)\n\nReturn a Ket which results from applying Gate M to Ket x.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_1 = sigma_x(1) * ψ_0\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_gates.html#Snowflurry.apply_instruction!","page":"Quantum Gates","title":"Snowflurry.apply_instruction!","text":"apply_instruction!(state::Ket, gate::Gate)\n\nUpdate the state by applying a gate to it.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> apply_instruction!(ψ_0, sigma_x(1))\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Snowflurry.get_operator","page":"Quantum Gates","title":"Snowflurry.get_operator","text":"get_operator(gate::Gate)\n\nReturns the Operator which is associated to a Gate.\n\nExamples\n\njulia> x = sigma_x(1);\n\njulia> get_operator(get_gate_symbol(x))\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_gates.html#Base.inv-Tuple{AbstractGateSymbol}","page":"Quantum Gates","title":"Base.inv","text":"inv(gate::AbstractGateSymbol)\n\nReturn a Gate which is the inverse of the input gate.\n\nExamples\n\njulia> u = universal(1, -pi/2, pi/3, pi/4)\nGate Object: Snowflurry.Universal\nParameters: \ntheta\t: -1.5707963267948966\nphi\t: 1.0471975511965976\nlambda\t: 0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.5 + 0.4999999999999999im\n-0.3535533905932738 - 0.6123724356957945im    -0.18301270189221924 + 0.6830127018922194im\n\n\njulia> inv(u)\nGate Object: Snowflurry.Universal\nParameters: \ntheta\t: 1.5707963267948966\nphi\t: -0.7853981633974483\nlambda\t: -1.0471975511965976\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    -0.3535533905932738 + 0.6123724356957945im\n0.5 - 0.4999999999999999im    -0.18301270189221924 - 0.6830127018922194im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_gates.html#Snowflurry.move_instruction","page":"Quantum Gates","title":"Snowflurry.move_instruction","text":"move_instruction(gate::Gate,\n    qubit_mapping::AbstractDict{<:Integer,<:Integer})::AbstractGateSymbol\n\nReturns a copy of gate where the qubits on which the gate acts have been updated based on qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit.\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Snowflurry.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> move_instruction(gate, Dict(1=>2))\nGate Object: Snowflurry.SigmaX\nConnected_qubits\t: [2]\nOperator:\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\nmove_instruction(\n    original_readout::Readout,\n    qubit_mapping::AbstractDict{T,T},\n)::AbstractInstruction where {T<:Integer}\n\nReturns a copy of original_readout where the qubits which the original_readout measures have been updated based on qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit.\n\nExamples\n\njulia> r = readout(1, 1)\nExplicit Readout object:\n   connected_qubit: 1 \n   destination_bit: 1 \n\njulia> move_instruction(r, Dict(1 => 2))\nExplicit Readout object:\n   connected_qubit: 2 \n   destination_bit: 1 \n\n\n\n\n\n\n","category":"function"},{"location":"getting_started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"DocTestSetup = quote\n    ENV[\"THUNDERHEAD_USER\"] = \"test-user\"\n    ENV[\"THUNDERHEAD_API_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"THUNDERHEAD_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"getting_started.html#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The following installation steps are for people interested in using Snowflurry in their own applications. If you are interested in helping to develop Snowflurry, head right over to our Developing Snowflurry page.","category":"page"},{"location":"getting_started.html#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Make sure your system has Julia installed. If not, download the latest version from https://julialang.org/downloads/.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We officially support the latest stable release and the latest Long-Term Support (LTS) release. Any release in-between should work (please submit a Github issue if they don't), but we only actively test against the LTS and the latest stable version.","category":"page"},{"location":"getting_started.html#Installing-the-Snowflurry-package","page":"Getting Started","title":"Installing the Snowflurry package","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The latest release of Snowflurry can be pulled from JuliaHub and installed with the following command:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(\"Snowflurry\")","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"This adds the Snowflurry package to the current Julia Environment.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Snowflurry is under active development. To use the development version, the main branch from Github can be installed instead using the following commands in the Julia REPL:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(url=\"https://github.com/SnowflurrySDK/Snowflurry.jl\", rev=\"main\")","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"warning: Warning\nThe main branch of Snowflurry targets new internal infrastructure. Existing users should use the latest stable release instead.","category":"page"},{"location":"getting_started.html#Installing-the-SnowflurryPlots-package","page":"Getting Started","title":"Installing the SnowflurryPlots package","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Multiple visualization tools are available in the SnowflurryPlots package. After installing Snowflurry, the SnowflurryPlots package can be installed by entering the following in the Julia REPL:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(url=\"https://github.com/SnowflurrySDK/SnowflurryPlots.jl\", rev=\"main\")","category":"page"},{"location":"getting_started.html#Typical-workflow","page":"Getting Started","title":"Typical workflow","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"A typical workflow to execute a quantum circuit on a quantum service consists of these three steps.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Create: Build the circuit using quantum gates.\nTranspile: transform the circuit into an equivalent one, but with improved performance and ensuring compatibility with the chosen quantum service.\nExecute: Run the compiled circuits on the specified quantum service. The quantum service could be a remote quantum hardware or a local simulator.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Now is the time to start with Snowflurry and go over the tutorials.","category":"page"},{"location":"library/quantum_toolkit.html#Quantum-Toolkit","page":"Quantum Toolkit","title":"Quantum Toolkit","text":"","category":"section"},{"location":"library/quantum_toolkit.html#Basic-Quantum-Objects","page":"Quantum Toolkit","title":"Basic Quantum Objects","text":"","category":"section"},{"location":"library/quantum_toolkit.html","page":"Quantum Toolkit","title":"Quantum Toolkit","text":"There are three basic quantum objects in Snowflurry to simulate a quantum system. These objects are Ket, Bra, and AbstractOperator.","category":"page"},{"location":"library/quantum_toolkit.html","page":"Quantum Toolkit","title":"Quantum Toolkit","text":"Ket\nBra\nDiagonalOperator\nAntiDiagonalOperator\nDenseOperator\nSwapLikeOperator\nIdentityOperator\nSparseOperator\nReadout\nreadout\nBase.adjoint\nis_hermitian\nBase.exp(A::AbstractOperator)\nBase.getindex(A::AbstractOperator, m::Int64, n::Int64)\nexpected_value(A::AbstractOperator, psi::Ket)\nsparse\neigen\ntr\nkron\nMultiBodySystem\ncommute\nanticommute\nnormalize!\nget_measurement_probabilities(x::Ket{Complex{T}}) where T<:Real\nket2dm\nfock_dm\nwigner\nmoyal\ngenlaguerre\nget_embed_operator\nget_num_qubits(x::AbstractOperator)\nget_num_qubits(x::Union{Ket, Bra})\nget_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\nget_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\nfock\nspin_up\nspin_down\ncreate\ndestroy\nnumber_op\ncoherent\ncompare_kets\ncompare_operators","category":"page"},{"location":"library/quantum_toolkit.html#Snowflurry.Ket","page":"Quantum Toolkit","title":"Snowflurry.Ket","text":"A Ket represents a quantum wavefunction and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.   A Ket representing a system with a qubit count of n=2 has 2^n states.  By convention, qubit 1 is the leftmost digit, followed by every subsequent qubit.  Hence, a 2-qubit Ket has 4 complex-valued coefficients a_ij, each corresponding to state leftijrightrangle, in the following order:\n\npsi = beginbmatrix\n    a_00  \n    a_10  \n    a_01  \n    a_11  \n    endbmatrix\n\nExamples\n\nA Ket can be initialized by using a pre-built basis such as the fock basis. See fock for further information on this function. \n\njulia> ψ = fock(2, 4)\n4-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\n\nAlthough NOT the preferred way, one can also directly build a Ket object by passing a column vector as the initializer. \n\njulia> using Snowflurry\n\njulia> ψ = Ket([1.0; 0.0; 0.0; 0.0])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.Bra","page":"Quantum Toolkit","title":"Snowflurry.Bra","text":"A structure representing a Bra (i.e., a row vector of complex values). A Bra is created as the complex conjugate of a Ket.\n\nExamples\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> _ψ = Bra(ψ)\n3-element Bra{ComplexF64}:\n0.0 - 0.0im\n1.0 - 0.0im\n0.0 - 0.0im\n\n\njulia> _ψ * ψ    # A Bra times a Ket is a scalar\n1.0 + 0.0im\n\njulia> ψ*_ψ     # A Ket times a Bra is an operator\n(3, 3)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.DiagonalOperator","page":"Quantum Toolkit","title":"Snowflurry.DiagonalOperator","text":"DiagonalOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a diagonal quantum Operator (i.e., a complex matrix of element type T, with non-zero elements all lying on the diagonal). The equivalent dense matrix would have size NxN.\n\nExamples\n\njulia> z = DiagonalOperator([1.0,-1.0])\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\njulia> z = DiagonalOperator([1.0+im,1.0,1.0,0.0-im])\n(4,4)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 1.0im    .    .    .\n.    1.0 + 0.0im    .    .\n.    .    1.0 + 0.0im    .\n.    .    .    0.0 - 1.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.AntiDiagonalOperator","page":"Quantum Toolkit","title":"Snowflurry.AntiDiagonalOperator","text":"AntiDiagonalOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a anti-diagonal quantum Operator (i.e., a complex matrix of element type T, with non-zero elements all lying on the cross-diagonal). The equivalent dense matrix would have size NxN.\n\nExamples\n\njulia> AntiDiagonalOperator([1, 2])\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    2.0 + 0.0im    .\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.DenseOperator","page":"Quantum Toolkit","title":"Snowflurry.DenseOperator","text":"DenseOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a quantum operator with a full (dense) matrix representation of size NxN and containing elements of type T.\n\nExamples\n\njulia> z = DenseOperator([1.0 0.0;0.0 -1.0])\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    -1.0 + 0.0im\n\n\nAlternatively:\n\njulia> z = rotation(π/2, -π/4)  \n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.4999999999999999 - 0.5im\n-0.4999999999999999 - 0.5im    0.7071067811865476 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.SwapLikeOperator","page":"Quantum Toolkit","title":"Snowflurry.SwapLikeOperator","text":"SwapLikeOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a quantum operator performing a \"swap\" operation, with element type T. A phase value is applied to the swapped qubit coefficients. This operator is always of size 4x4.\n\nFor example, the iswap Operator can be built using a phase=0.0 + 1.0im by calling:\n\njulia> SwapLikeOperator(0.0 + 1.0im)\n(4, 4)-element Snowflurry.SwapLikeOperator:\nUnderlying data ComplexF64:\nEquivalent DenseOperator:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.IdentityOperator","page":"Quantum Toolkit","title":"Snowflurry.IdentityOperator","text":"IdentityOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing the identity quantum operator, with element type T. This operator is always of size 2x2.\n\nExample\n\njulia> IdentityOperator()\n(2, 2)-element Snowflurry.IdentityOperator:\nUnderlying data ComplexF64:\nEquivalent DenseOperator:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.SparseOperator","page":"Quantum Toolkit","title":"Snowflurry.SparseOperator","text":"SparseOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a quantum operator with a sparse (CSR) matrix representation, with element type T. The equivalent dense matrix would have size NxN.\n\nwarning: Warning\nThe apply_operator() method is not implemented for this operator type. Try using DenseOperator instead.\n\nExamples\n\njulia> z = SparseOperator([-1.0 1.0;0.0 -1.0])\n(2, 2)-element Snowflurry.SparseOperator:\nUnderlying data ComplexF64:\n -1.0 + 0.0im   1.0 + 0.0im\n       ⋅       -1.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.Readout","page":"Quantum Toolkit","title":"Snowflurry.Readout","text":"Readout <: AbstractInstruction\n\nReadout is an implementation of an AbstractInstruction that specifies  an explicit measurement on a particular qubit, and the destination bit in  the classical result registry (classical bit). It is built using the readout(qubit::Int, bit::Int) helper function, where  the first argument is the target qubit, and the second is the destination classical bit. Measurements are always performed in the Z basis (also known as the computational basis).\n\nExamples\n\njulia> r = readout(1, 2)\nExplicit Readout object:\n   connected_qubit: 1 \n   destination_bit: 2 \n\n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.readout","page":"Quantum Toolkit","title":"Snowflurry.readout","text":"readout(qubit::Int, bit::Int)\n\nReturn a Readout AbstractInstruction, which performs a  readout on the target qubit, and places the result in the destination bit.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Base.adjoint","page":"Quantum Toolkit","title":"Base.adjoint","text":"Base.adjoint(x)\n\nCompute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.is_hermitian","page":"Quantum Toolkit","title":"Snowflurry.is_hermitian","text":"is_hermitian(A::AbstractOperator)\n\nDetermine if Operator A is Hermitian (i.e., self-adjoint).\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> is_hermitian(Y)\ntrue\n\njulia> P = sigma_p()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    0.0 + 0.0im    .\n\n\njulia> is_hermitian(P)\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Base.exp-Tuple{AbstractOperator}","page":"Quantum Toolkit","title":"Base.exp","text":"exp(A::AbstractOperator)\n\nCompute the matrix exponential of Operator A.\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> x_rotation_90_deg = exp(-im*π/4*X)\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865475 + 0.0im    0.0 - 0.7071067811865475im\n0.0 - 0.7071067811865475im    0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#Base.getindex-Tuple{AbstractOperator, Int64, Int64}","page":"Quantum Toolkit","title":"Base.getindex","text":"getindex(A::AbstractOperator, i::Integer, j::Integer)\n\nAccess the element at row i and column j in the matrix corresponding to Operator A.\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> Y[1,1]\n0.0 + 0.0im\n\njulia> Y[1,2]\n0.0 - 1.0im\n\njulia> Y[2,1]\n0.0 + 1.0im\n\njulia> Y[2,2]\n0.0 + 0.0im\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#Snowflurry.expected_value-Tuple{AbstractOperator, Ket}","page":"Quantum Toolkit","title":"Snowflurry.expected_value","text":"expected_value(A::AbstractOperator, psi::Ket)\n\nCompute the expectation value ⟨ψ|A|ψ⟩ given Operator A and Ket |ψ⟩.\n\nExamples\n\njulia> ψ = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> A = sigma_z()\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\n\njulia> expected_value(A, ψ)\n-1.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#SparseArrays.sparse","page":"Quantum Toolkit","title":"SparseArrays.sparse","text":"sparse(x::AbstractOperator)\n\nReturns a SparseOperator representation of x.\n\nExamples\n\njulia> z = sparse(sigma_z())\n(2, 2)-element Snowflurry.SparseOperator:\nUnderlying data ComplexF64:\n 1.0 + 0.0im        ⋅     \n      ⋅       -1.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#LinearAlgebra.eigen","page":"Quantum Toolkit","title":"LinearAlgebra.eigen","text":"eigen(A::AbstractOperator)\n\nCompute the eigenvalue decomposition of Operator A and return an Eigen factorization object F. Eigenvalues are found in F.values while eigenvectors are found in the matrix F.vectors. Each column of this matrix corresponds to an eigenvector. The ith eigenvector is extracted by calling F.vectors[:, i].\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> F = eigen(X);\n\njulia> eigenvalues = F.values\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> eigenvector_1 = F.vectors[:, 1]\n2-element Vector{ComplexF64}:\n -0.7071067811865475 + 0.0im\n  0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#LinearAlgebra.tr","page":"Quantum Toolkit","title":"LinearAlgebra.tr","text":"tr(A::AbstractOperator)\n\nCompute the trace of Operator A.\n\nExamples\n\njulia> I = eye()\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\n\njulia> trace = tr(I)\n2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Base.kron","page":"Quantum Toolkit","title":"Base.kron","text":"kron(x, y)\n\nCompute the Kronecker product of two Kets or two  DenseOperator , DiagonalOperator, AntiDiagonalOperator. More details about the Kronecker product can be found here. \n\nExamples\n\njulia> ψ_0 = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> ψ_1 = Ket([1.0; 0.0])\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_0_1 = kron(ψ_0, ψ_1)\n4-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> kron(sigma_x(), sigma_y())\n(4, 4)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.MultiBodySystem","page":"Quantum Toolkit","title":"Snowflurry.MultiBodySystem","text":"A structure representing a quantum multi-body system.\n\nFields\n\nhilbert_space_structure – a vector of integers specifying the local Hilbert space size for each \"body\" within the multi-body system. \n\n\n\n\n\n","category":"type"},{"location":"library/quantum_toolkit.html#Snowflurry.commute","page":"Quantum Toolkit","title":"Snowflurry.commute","text":"commute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the commutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> σ_y = sigma_y()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> commute(σ_x, σ_y)\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n0.0 + 2.0im    .\n.    0.0 - 2.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.anticommute","page":"Quantum Toolkit","title":"Snowflurry.anticommute","text":"anticommute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the anticommutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> anticommute(σ_x, σ_x)\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n2.0 + 0.0im    .\n.    2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#LinearAlgebra.normalize!","page":"Quantum Toolkit","title":"LinearAlgebra.normalize!","text":"normalize!(x::Ket)\n\nNormalizes Ket x such that its magnitude becomes unity.\n\njulia> ψ = Ket([1., 2., 4.])\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n4.0 + 0.0im\n\njulia> normalize!(ψ)\n3-element Ket{ComplexF64}:\n0.2182178902359924 + 0.0im\n0.4364357804719848 + 0.0im\n0.8728715609439696 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T<:Real","page":"Quantum Toolkit","title":"Snowflurry.get_measurement_probabilities","text":"get_measurement_probabilities(x::Ket{Complex{T}},\n    [target_bodies::Vector{U},\n    hspace_size_per_body::Union{U,Vector{U}}=2])::AbstractVector{T}\n    where {T<:Real, U<:Integer}\n\nReturns a vector listing the measurement probabilities of the target_bodies of Ket x.\n\nThe Hilbert space size per body can be specified by providing a Vector of Integer for the hspace_size_per_body argument. The Vector must specify the Hilbert space size for each body. If the space size is uniform, a single Integer can be given instead. If only x is provided, the probabilities are provided for all the bodies.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit Ket, the probabilities are listed for left00rightrangle,  left10rightrangle, left01rightrangle, and left11rightrangle. \n\nnote: Note\nBy convention, qubit 1 is the leftmost digit, followed by every subsequent qubit.  left10rightrangle has qubit 1 in state left1rightrangle and qubit 2 in state left0rightrangle\n\nExamples\n\nThe following example constructs a Ket, where the probability of measuring  left00rightrangle is 50% and the probability of measuring left01rightrangle is also 50%.\n\njulia> ψ = 1/sqrt(2) * Ket([1, 0, 1, 0])\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_measurement_probabilities(ψ)\n4-element Vector{Float64}:\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n 0.0\n\n\nFor the same Ket, the probability of measuring qubit 2 and finding 0 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(ψ, target_qubit)\n2-element Vector{Float64}:\n 0.9999999999999998\n 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#Snowflurry.ket2dm","page":"Quantum Toolkit","title":"Snowflurry.ket2dm","text":"ket2dm(ψ::Ket)\n\nReturns the density matrix corresponding to the pure state ψ.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.fock_dm","page":"Quantum Toolkit","title":"Snowflurry.fock_dm","text":"fock_dm(i::Int64, hspace_size::Int64)\n\nReturns the density matrix corresponding to the Fock base i defined in a Hilbert space of size hspace_size.\n\njulia> dm = fock_dm(0, 2)\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.wigner","page":"Quantum Toolkit","title":"Snowflurry.wigner","text":"wigner(ρ::AbstractOperator, p::Real, q::Real)\n\nComputes the Wigner function of the density matrix ρ at the point (p,q).\n\njulia> alpha = 0.25;\n\njulia> hspace_size = 8;\n\njulia> Ψ = coherent(alpha, hspace_size);\n\njulia> prob = wigner(ket2dm(Ψ), 0, 0);\n\njulia> @printf \"prob: %.6f\" prob\nprob: -0.561815\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.moyal","page":"Quantum Toolkit","title":"Snowflurry.moyal","text":"moyal(m, n)\n\nReturns the Moyal function w_mn(eta) for Fock states m and n.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.genlaguerre","page":"Quantum Toolkit","title":"Snowflurry.genlaguerre","text":"genlaguerre(x, alpha, n)\n\nReturns the generalized Laguerre polynomial of degree n for x using a recursive method. See https://en.wikipedia.org/wiki/Laguerre_polynomials.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.get_embed_operator","page":"Quantum Toolkit","title":"Snowflurry.get_embed_operator","text":"get_embed_operator(op::DenseOperator, target_body_index::Int, system::MultiBodySystem)\n\nUses a local operator (op), which is defined for a particular body (e.g. qubit) with index target_body_index, to build the corresponding operator for the Hilbert space of the multi-body system given by system. \n\nExamples\n\njulia> system = MultiBodySystem(3, 2)\nSnowflurry.Multibody system with 3 bodies\n   Hilbert space structure:\n   [2, 2, 2]\n\njulia> x = sigma_x()\n(2,2)-element Snowflurry.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> X_1 = get_embed_operator(x, 1, system)\n(8, 8)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.get_num_qubits-Tuple{AbstractOperator}","page":"Quantum Toolkit","title":"Snowflurry.get_num_qubits","text":"get_num_qubits(x::AbstractOperator)\n\nReturns the number of qubits associated with an Operator.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0. \n                          0. 0.])\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_qubits(ρ)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#Snowflurry.get_num_qubits-Tuple{Union{Bra, Ket}}","page":"Quantum Toolkit","title":"Snowflurry.get_num_qubits","text":"get_num_qubits(x::Union{Ket, Bra})\n\nReturns the number of qubits associated with a Ket or a Bra.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_qubits(ψ)\n2\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_toolkit.html#Snowflurry.get_num_bodies","page":"Quantum Toolkit","title":"Snowflurry.get_num_bodies","text":"get_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with an Operator given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0. 0.\n                          0. 0. 0.\n                          0. 0. 0.])\n(3, 3)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_bodies(ρ, 3)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.get_num_bodies-2","page":"Quantum Toolkit","title":"Snowflurry.get_num_bodies","text":"get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with a Ket or a Bra given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0., 0., 0., 0., 0., 0.])\n9-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_bodies(ψ, 3)\n2\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.fock","page":"Quantum Toolkit","title":"Snowflurry.fock","text":"fock(i, hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the ith Fock basis of a Hilbert space with size hspace_size as a Ket.\n\nThe Ket contains values of type T, which by default is ComplexF64.\n\nExamples\n\njulia> ψ = fock(0, 3)\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3, ComplexF32) # specifying a type other than ComplexF64\n3-element Ket{ComplexF32}:\n0.0f0 + 0.0f0im\n1.0f0 + 0.0f0im\n0.0f0 + 0.0f0im\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.spin_up","page":"Quantum Toolkit","title":"Snowflurry.spin_up","text":"spin_up(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-up state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_up()\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.spin_down","page":"Quantum Toolkit","title":"Snowflurry.spin_down","text":"spin_down(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-down state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_down()\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.create","page":"Quantum Toolkit","title":"Snowflurry.create","text":"create(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic creation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.destroy","page":"Quantum Toolkit","title":"Snowflurry.destroy","text":"destroy(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic annhilation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.number_op","page":"Quantum Toolkit","title":"Snowflurry.number_op","text":"number_op(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the number operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.coherent","page":"Quantum Toolkit","title":"Snowflurry.coherent","text":"coherent(alpha, hspace_size)\n\nReturns a coherent state for the parameter alpha in a Fock space of size hspace_size. Note that |alpha|^2 is equal to the photon number of the coherent state. \n\n# Examples\n\njulia> ψ = coherent(2.0, 20)\n20-element Ket{ComplexF64}:\n0.1353352832366127 + 0.0im\n0.2706705664732254 + 0.0im\n0.3827859860416437 + 0.0im\n0.44200318416631873 + 0.0im\n0.44200318416631873 + 0.0im\n0.3953396664268989 + 0.0im\n0.3227934859426707 + 0.0im\n0.24400893961026582 + 0.0im\n0.17254037586855772 + 0.0im\n0.11502691724570517 + 0.0im\n0.07274941014482605 + 0.0im\n0.043869544940011405 + 0.0im\n0.025328093580341972 + 0.0im\n0.014049498479026656 + 0.0im\n0.007509772823502764 + 0.0im\n0.003878030010563634 + 0.0im\n0.001939015005281817 + 0.0im\n0.000940560432521708 + 0.0im\n0.0004433844399679012 + 0.0im\n0.00020343873336404819 + 0.0im\n\n\njulia> expected_value(number_op(20), ψ)\n3.99999979364864 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.compare_kets","page":"Quantum Toolkit","title":"Snowflurry.compare_kets","text":"compare_kets(ψ_0::Ket,ψ_1::Ket)\n\nChecks for equivalence allowing for a global phase difference between two input kets.\n\nExamples\n\njulia> ψ_0 = Ket([1., 2., 3., 4.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n3.0 + 0.0im\n4.0 + 0.0im\n\n\njulia> δ = π/3 # phase offset\n1.0471975511965976\n\njulia> ψ_1 = exp(im * δ) * ψ_0\n4-element Ket{ComplexF64}:\n0.5000000000000001 + 0.8660254037844386im\n1.0000000000000002 + 1.7320508075688772im\n1.5000000000000004 + 2.598076211353316im\n2.0000000000000004 + 3.4641016151377544im\n\n\njulia> compare_kets(ψ_0, ψ_1)\ntrue\n\njulia> apply_instruction!(ψ_1, sigma_x(1))\n4-element Ket{ComplexF64}:\n1.5000000000000004 + 2.598076211353316im\n2.0000000000000004 + 3.4641016151377544im\n0.5000000000000001 + 0.8660254037844386im\n1.0000000000000002 + 1.7320508075688772im\n\n\njulia> compare_kets(ψ_0, ψ_1) # no longer equivalent after SigmaX gate\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_toolkit.html#Snowflurry.compare_operators","page":"Quantum Toolkit","title":"Snowflurry.compare_operators","text":"compare_operators(H_0::AbstractOperator, H_1::AbstractOperator)::Bool\n\nChecks for equivalence allowing for a global phase difference between two input operators.\n\nExamples\n\njulia> H_0 = z_90()\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n0.7071067811865476 - 0.7071067811865475im    .\n.    0.7071067811865476 + 0.7071067811865475im\n\n\njulia> H_1 = phase_shift(pi / 2)\n(2,2)-element Snowflurry.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    6.123233995736766e-17 + 1.0im\n\n\njulia> compare_operators(H_0, H_1)\ntrue\n\njulia> H_1 *= sigma_x()\n(2, 2)-element Snowflurry.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    1.0 + 0.0im\n6.123233995736766e-17 + 1.0im    0.0 + 0.0im\n\n\njulia> compare_operators(H_0, H_1) # no longer equivalent after applying sigma x\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"index.html#Snowflurry.jl","page":"Home","title":"Snowflurry.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"DocTestSetup = :(using Snowflurry)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A library for quantum computing using Julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Snowflurry is a pure Julia quantum computing stack that allows you to easily design quantum circuits, experiments and algorithms. Snowflurry can run these quantum applications on real quantum computers or classical simulators.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nSnowflurry has yet to reach version 1.0, but we intend to keep compatibility with what is documented here. We will only make a breaking change if something is broken. After version 1.0, the public API will be stable and only change with major releases.","category":"page"},{"location":"library/quantum_circuit.html#Quantum-Circuit","page":"Quantum Circuits","title":"Quantum Circuit","text":"","category":"section"},{"location":"library/quantum_circuit.html","page":"Quantum Circuits","title":"Quantum Circuits","text":"QuantumCircuit\npush!\npop!\nappend!\nprepend!\nsimulate\nsimulate_shots\nget_measurement_probabilities(circuit::QuantumCircuit)\ninv(circuit::QuantumCircuit)\nget_num_gates_per_type\nget_num_gates\nserialize_job\ntranspile\ncompare_circuits\ncircuit_contains_gate_type\npermute_qubits!\npermute_qubits","category":"page"},{"location":"library/quantum_circuit.html#Snowflurry.QuantumCircuit","page":"Quantum Circuits","title":"Snowflurry.QuantumCircuit","text":"QuantumCircuit(qubit_count::Int, bit_count::Int, instructions::Vector{AbstractInstruction}, name::String = \"default\")\nQuantumCircuit(circuit::QuantumCircuit)\n\nA data structure to represent a quantum circuit.\n\nFields\n\nqubit_count::Int – number of qubits (i.e., quantum register size).\nbit_count::Int – Optional: number of classical bits (i.e., result register size). Defaults to qubit_count if unspecified.\ninstructions::Vector{AbstractInstruction} – Optional: the sequence of AbstractInstructions (Gates and Readouts) that operate on qubits. Defaults to empty Vector.\nname::String – Optional: name of the circuit job, used to identify it when sending to a hardware or virtual QPU. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:\n\nA QuantumCircuit can be initialized containing Gates and Readouts:\n\njulia> c = QuantumCircuit(qubit_count = 2, instructions = [hadamard(1), sigma_x(2), control_x(1, 2), readout(1, 1), readout(2, 2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*────✲───────\n                 |            \nq[2]:───────X────X─────────✲──\n                              \n\nA deep copy of a QuantumCircuit can be obtained with the following command:\n\njulia> c_copy = QuantumCircuit(c)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*────✲───────\n                 |            \nq[2]:───────X────X─────────✲──\n                              \n\n\n\n\n\n","category":"type"},{"location":"library/quantum_circuit.html#Base.push!","page":"Quantum Circuits","title":"Base.push!","text":"push!(circuit::QuantumCircuit, gates::AbstractGateSymbol...)\n\nInserts one or more gates at the end of a circuit.\n\nA Vector of AbstractGateSymbol objects can be passed to this function by using splatting. More details about splatting are provided here.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> gate_list = [sigma_x(1), hadamard(2)];\n\njulia> push!(c, gate_list...)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*────X───────\n                 |            \nq[2]:───────X────X─────────H──\n                              \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Base.pop!","page":"Quantum Circuits","title":"Base.pop!","text":"pop!(circuit::QuantumCircuit)\n\nRemoves the last instruction from circuit.instructions. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> pop!(c)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Base.append!","page":"Quantum Circuits","title":"Base.append!","text":"append!(base_circuit::QuantumCircuit, circuits_to_append::QuantumCircuit...)\n\nAppends one or more circuits_to_append to the base_circuit.\n\nThe circuits_to_append cannot contain more qubits than the base_circuit.\n\nExamples\n\njulia> base = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> append_1 = QuantumCircuit(qubit_count = 1, instructions = [sigma_z(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──Z──\n          \n\n\n\njulia> append_2 = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──X──\n          \n\n\n\njulia> append!(base, append_1, append_2)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X────Z────*──\n                 |  \nq[2]:────────────X──\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Base.prepend!","page":"Quantum Circuits","title":"Base.prepend!","text":"prepend!(base_circuit::QuantumCircuit, circuits_to_prepend::QuantumCircuit...)\n\nPrepends one or more circuits_to_prepend to the base_circuit.\n\nThe order of the circuits_to_prepend is maintained (i.e., circuits_to_prepend[1] will appear leftmost in base_circuit). The circuits_to_prepend cannot contain more qubits than the base_circuit.\n\nExamples\n\njulia> base = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> prepend_1 = QuantumCircuit(qubit_count = 1, instructions = [sigma_z(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──Z──\n          \n\n\n\njulia> prepend_2 = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──X──\n          \n\n\n\njulia> prepend!(base, prepend_1, prepend_2)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z────*────X──\n            |       \nq[2]:───────X───────\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.simulate","page":"Quantum Circuits","title":"Snowflurry.simulate","text":"simulate(circuit::QuantumCircuit)::Ket\n\nSimulates and returns the wavefunction of the quantum device after running circuit,  assuming an initial state Ket ψ corresponding to the 0th Fock basis, i.e.:  ψ = fock(0, 2^get_num_qubits(circuit)).\n\nnote: Note\nThe input circuit must not include Readouts. For simulating circuits including Readouts, use simulate_shots.\n\nEmploys the approach described in Listing 5 of Suzuki et. al. (2021).\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> ket = simulate(c)\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.simulate_shots","page":"Quantum Circuits","title":"Snowflurry.simulate_shots","text":"simulate_shots(c::QuantumCircuit, shots_count::Int = 100)\n\nEmulates a quantum computer by running a circuit for a given number of shots and returning measurement results, as prescribed by the Readouts present in the circuit.  The distribution of measured states corresponds to the coefficients in the resulting state Ket. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), control_x(1, 2), readout(1, 1), readout(2, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────*────✲───────\n            |            \nq[2]:───────X─────────✲──\n\n\njulia> simulate_shots(c, 99)\n99-element Vector{String}:\n \"11\"\n \"00\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"00\"\n \"00\"\n \"11\"\n ⋮\n \"00\"\n \"00\"\n \"11\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.get_measurement_probabilities-Tuple{QuantumCircuit}","page":"Quantum Circuits","title":"Snowflurry.get_measurement_probabilities","text":"get_measurement_probabilities(circuit::QuantumCircuit,\n    [target_qubits::Vector{<:Integer}])::AbstractVector{<:Real}\n\nReturns a vector listing the measurement probabilities for the target_qubits in the circuit.\n\nIf no target_qubits are provided, the probabilities are computed for all the qubits.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit QuantumCircuit, the probabilities are listed for left00rightrangle, left10rightrangle, left01rightrangle, and left11rightrangle.\n\nnote: Note\nBy convention, qubit 1 is the leftmost digit, followed by every subsequent qubit.  left10rightrangle has qubit 1 in state left1rightrangle and qubit 2 in state left0rightrangle\n\nExamples\n\nThe following example constructs a QuantumCircuit where the probability of measuring left10rightrangle is 50% and the probability of measuring left11rightrangle is also 50%.\n\njulia> circuit = QuantumCircuit(qubit_count = 2);\n\njulia> push!(circuit, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> get_measurement_probabilities(circuit)\n4-element Vector{Float64}:\n 0.0\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n\n\nFor the same circuit, the probability of measuring qubit 2 and finding 1 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(circuit, target_qubit)\n2-element Vector{Float64}:\n 0.0\n 0.9999999999999998\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_circuit.html#Base.inv-Tuple{QuantumCircuit}","page":"Quantum Circuits","title":"Base.inv","text":"inv(circuit::QuantumCircuit)\n\nReturn a QuantumCircuit which is the inverse of the input circuit.  Each gate is replaced by its corresponding inverse, and the order of gates is reversed.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, rotation_y(1, pi/4));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Ry(0.7854)────*──\n                     |  \nq[2]:────────────────X──\n                        \n\n\n\njulia> inv(c)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──*────Ry(-0.7854)──\n       |                 \nq[2]:──X─────────────────\n                         \n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/quantum_circuit.html#Snowflurry.get_num_gates_per_type","page":"Quantum Circuits","title":"Snowflurry.get_num_gates_per_type","text":"get_num_gates_per_type(circuit::QuantumCircuit)::AbstractDict{<: AbstractString, <:Integer}\n\nReturns a dictionary listing the number of gates of each type found in the circuit.\n\nThe dictionary keys are the instruction_symbol of the gates while the values are the number of gates found.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), hadamard(2));\n\njulia> push!(c, control_x(1, 2));\n\njulia> push!(c, hadamard(2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*───────\n                 |       \nq[2]:───────H────X────H──\n                         \n\n\n\njulia> get_num_gates_per_type(c)\nDict{String, Int64} with 2 entries:\n  \"h\"  => 3\n  \"cx\" => 1\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.get_num_gates","page":"Quantum Circuits","title":"Snowflurry.get_num_gates","text":"get_num_gates(circuit::QuantumCircuit)::Integer\n\nReturns the number of gates in the circuit.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), hadamard(2));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────H────X──\n                    \n\n\n\njulia> get_num_gates(c)\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.serialize_job","page":"Quantum Circuits","title":"Snowflurry.serialize_job","text":"serialize_job(circuit::QuantumCircuit,shot_count::Integer,host::String)\n\nCreates a JSON-formatted String containing the circuit configuration to be sent  to a QPU service located at the URL specified by host, along with the number of shots requested.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)], name = \"sigma_x job\")\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \njulia> serialize_job(c, 10, \"http://example.anyonsys.com\", \"project_id\")\n\"{\\\"shotCount\\\":10,\\\"name\\\":\\\"sigma_x job\\\",\\\"machineID\\\":\\\"http://example.anyonsys.com\\\",\\\"billingaccountID\\\":\\\"project_id\\\",\\\"type\\\":\\\"circuit\\\",\\\"circuit\\\":{\\\"operations\\\":[{\\\"parameters\\\":{},\\\"type\\\":\\\"x\\\",\\\"qubits\\\":[0]}]}}\"\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.transpile","page":"Quantum Circuits","title":"Snowflurry.transpile","text":"transpile(::CompressSingleQubitGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CompressSingleQubitGatesTranspiler transpiler stage  which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single Universal gates in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler = CompressSingleQubitGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1), sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X────Y──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────Y─────────P(1.0472)──\n                                 \nq[2]:────────────*───────────────\n                 |               \nq[3]:────────────X───────────────\n                                 \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────\n                                            \nq[2]:────────────────────────────────────*──\n                                         |  \nq[3]:────────────────────────────────────X──\n                                            \n\n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastSwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastSwapToCZGateTranspiler transpiler stage which expands all Swap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler = CastSwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [swap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──☒──\n       |\nq[2]:──☒──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────\n                |                     |                     |          \nq[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──\n                                              \n\n\n\n\n\n\ntranspile(::CastCXToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastCXToCZGateTranspiler transpiler stage which expands all CX gates into CZ and Hadamard gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler = CastCXToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──*──\n       |\nq[2]:──X──\n\njulia> transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:───────*───────\n            |\nq[2]:──H────Z────H──\n\n\n\n\n\ntranspile(::CastISwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastISwapToCZGateTranspiler transpiler stage which expands all ISwap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler = CastISwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [iswap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──x──\n       |\nq[2]:──x──\n\njulia> transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────\n                         |                     |                  \nq[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──\n                                                                  \n\n\n\n\n\n\ntranspile(::CastToffoliToCXGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastToffoliToCXGateTranspiler transpiler stage which expands all Toffoli gates into CX gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler = CastToffoliToCXGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 3, instructions = [toffoli(1, 2, 3)])\nQuantum Circuit Object:\n   qubit_count: 3\n   bit_count: 3\nq[1]:──*──\n       |\nq[2]:──*──\n       |\nq[3]:──X──\n\njulia> transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──────────────────*────────────────────*──────────────*─────────T──────────*──\n                       |                    |              |                    |  \nq[2]:───────*──────────|─────────*──────────|────T─────────X──────────────T†────X──\n            |          |         |          |                                      \nq[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──────────────────\n                                                                                   \n\n\n\n\n\n\ntranspile(::CastToPhaseShiftAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastToPhaseShiftAndHalfRotationXTranspiler transpiler stage  which converts all single-qubit gates in an input circuit and converts them  into combinations of PhaseShift and RotationX with angle π/2 in an output  circuit. For any gate in the input circuit, the number of gates in the  output varies between zero and 5. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler = CastToPhaseShiftAndHalfRotationXTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z────X_90────Z────X_m90──\n                                                 \nq[2]:───────────────────────────\n                                                 \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Y──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2\n   bit_count: 2\nq[1]:──X_90────Z────X_m90──\n\nq[2]:──────────────────────\n                                           \n\n\n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0., 0., 0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastUniversalToRzRxRzTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastUniversalToRzRxRzTranspiler transpiler stage  which finds Universal gates in an input circuit and casts  them into a sequence of PhaseShift (Rz), RotationX (Rx) and  PhaseShift (Rz) gates in a new circuit. The result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler = CastUniversalToRzRxRzTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, π/2, π/4, π/8)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──U(θ=1.5708,ϕ=0.7854,λ=0.3927)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(-1.1781)────Rx(1.5708)────P(2.3562)──\n                                              \nq[2]:─────────────────────────────────────────\n                                              \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0, π/4, 0)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.7854,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(-1.5708)────Rx(0.0000)────P(2.3562)──\n                                              \nq[2]:─────────────────────────────────────────\n                                              \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastRxToRzAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastRxToRzAndHalfRotationXTranspiler transpiler stage  which finds RotationX(θ) gates in an input circuit and converts (casts)  them into a sequence of gates: Z90,X90,PhaseShift(θ),XM90,ZM90 in a new circuit. The result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastRxToRzAndHalfRotationXTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1,π/8)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Rx(0.3927)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z_90────X_90────P(0.3927)────X_m90────Z_m90──\n                                                    \nq[2]:───────────────────────────────────────────────\n                                                    \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SimplifyRxGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyRxGatesTranspiler transpiler stage  which finds RotationX gates in an input circuit and according to its  angle theta, casts them to one of the right-angle RotationX gates,  e.g., SigmaX, X90, or XM90. In the case where theta≈0., the gate is removed. The result of the input and output circuit on any arbitrary state Ket is  unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler = SimplifyRxGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, pi/2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Rx(1.5708)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X_90──\n             \nq[2]:────────\n             \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, pi)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Rx(3.1416)──\n                   \nq[2]:──────────────\n                   \n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [rotation_x(1, 0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Rx(0.0000)──\n                   \nq[2]:──────────────\n                   \n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SwapQubitsForAdjacencyTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SwapQubitsForAdjacencyTranspiler transpiler stage  which adds Swap gates around multi-qubit gates so that the  final Operator acts on adjacent qubits. The result of the input  and output circuit on any arbitrary state Ket is unchanged  (up to a global phase).\n\nExamples\n\njulia> transpiler = SwapQubitsForAdjacencyTranspiler(LineConnectivity(6));\n\njulia> circuit = QuantumCircuit(qubit_count = 6, instructions = [toffoli(4, 6, 1)])\nQuantum Circuit Object:\n   qubit_count: 6 \n   bit_count: 6 \nq[1]:──X──\n       |  \nq[2]:──|──\n       |  \nq[3]:──|──\n       |  \nq[4]:──*──\n       |  \nq[5]:──|──\n       |  \nq[6]:──*──\n          \n\n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 6 \n   bit_count: 6 \nq[1]:───────────────────────────X───────────────────────────\n                                |                           \nq[2]:───────☒───────────────────*───────────────────☒───────\n            |                   |                   |       \nq[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──\n       |                   |         |                   |  \nq[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──\n                      |                   |                 \nq[5]:────────────☒────☒───────────────────☒────☒────────────\n                 |                             |            \nq[6]:────────────☒─────────────────────────────☒────────────\n                                                            \n\n\n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SimplifyRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyRzGatesTranspiler transpiler stage  which finds PhaseShift gates in an input circuit and according to its  phase angle phi, casts them to one of the right-angle RotationZ gates,  e.g., SigmaZ, Z90, ZM90, Pi8 or Pi8Dagger. In the case where phi≈0., the  gate is removed. The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyRzGatesTranspiler(1.0e-10)\n\nExamples\n\njulia> transpiler = SimplifyRzGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, pi/2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(1.5708)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z_90──\n             \nq[2]:────────\n             \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, pi)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(3.1416)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z──\n          \nq[2]:─────\n          \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, 0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(0.0000)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CompressRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CompressRzGatesTranspiler transpiler stage  which gathers all Rz-type gates sharing a common target in an input  circuit and combines them into single PhaseShift gate in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler = CompressRzGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [sigma_z(1), z_90(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──Z────Z_90──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(-1.5708)──\n                   \nq[2]:──────────────\n                   \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 3, instructions = [sigma_z(1), pi_8(1), control_x(2,3), z_minus_90(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──Z────T─────────Z_m90──\n                             \nq[2]:────────────*───────────\n                 |           \nq[3]:────────────X───────────\n                             \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──P(2.3562)───────\n                       \nq[2]:───────────────*──\n                    |  \nq[3]:───────────────X──\n                       \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::RemoveSwapBySwappingGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nRemoves the Swap gates from the circuit assuming all-to-all connectivity.\n\nwarning: The initial state must be the ground state!\nThis transpiler stage assumes that the input state is 0rangle^otimes N where N is the number of qubits. The stage should not be used on sub-circuits where the input state is not 0rangle^otimes N.\n\nThis transpiler stage eliminates Swap gates by moving the gates preceding each Swap gate.\n\nExamples\n\njulia> transpiler = RemoveSwapBySwappingGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [hadamard(1), swap(1, 2), sigma_x(2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────☒───────\n            |       \nq[2]:───────☒────X──\n                    \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──────────\n               \nq[2]:──H────X──\n               \n\n\n\n\n\n\n\n\ntranspile(::SimplifyTrivialGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyTrivialGatesTranspiler transpiler stage  which finds gates which have no effect on the state Ket, such as Identity, and  parameterized gates with null parameters such as rotation_x(target, 0.). The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyTrivialGatesTranspiler(1.0e-10)\n\nExamples\n\njulia> transpiler = SimplifyTrivialGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [identity_gate(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──I──\n          \nq[2]:─────\n          \njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [phase_shift(1, 0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──P(0.0000)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, instructions = [universal(1, 0., 0., 0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                             \njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit, transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::ReadoutsAreFinalInstructionsTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nEnsures that each Readout Instruction is the last operation  on each qubit where readouts are present, and that repeated readouts  on the same qubit do not occur, or throws an error.  It leaves the QuantumCircuit unchanged.\n\nExamples\n\njulia> transpiler = ReadoutsAreFinalInstructionsTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1), sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲────X──\n                    \nq[2]:───────────────\n                    \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nERROR: AssertionError: Cannot perform `Gate` following `Readout` on qubit: 1\n[...]\n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [readout(1,1), readout(1,2)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──✲────✲──\n               \nq[2]:──────────\n               \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nERROR: AssertionError: Found multiple `Readouts` on qubit: 1\n[...]\n\n\n\n\n\ntranspile(::CircuitContainsAReadoutTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nEnsures that at least one Readout Instruction is  present on the QuantumCircuit,  or throws an error.  It leaves the QuantumCircuit unchanged.\n\nExamples\n\njulia> transpiler = CircuitContainsAReadoutTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nERROR: ArgumentError: QuantumCircuit is missing a `Readout`. Would not return any result.\n[...]\n\n\n\n\n\ntranspile(::ReadoutsDoNotConflictTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nEnsures that each Readout Instruction present on the QuantumCircuit  do not have conflicting destination bit, or throws an error.  It leaves the QuantumCircuit unchanged.\n\nExamples\n\njulia> transpiler = ReadoutsDoNotConflictTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [hadamard(1), readout(1,1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──H────✲──\n               \nq[2]:──────────\n               \n\njulia> circuit = QuantumCircuit(qubit_count=2, instructions = [readout(1,1), readout(2,1)])\nQuantum Circuit Object:\n   qubit_count: 2 \n   bit_count: 2 \nq[1]:──✲───────\n               \nq[2]:───────✲──\n               \n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nERROR: ArgumentError: `Readouts` in `QuantumCircuit` have conflicting destination bit: 1\n[...]\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.compare_circuits","page":"Quantum Circuits","title":"Snowflurry.compare_circuits","text":"compare_circuits(c0::QuantumCircuit, c1::QuantumCircuit)::Bool\n\nTests for equivalence of two QuantumCircuit based on their effect on an  arbitrary input state (a Ket). QuantumCircuit are equivalent if they both  yield the same output for any input, up to a global phase. QuantumCircuit with different ordering of gates that apply on different  targets can also be equivalent. \n\nnote: Note\nIf there are Readouts are present on either QuantumCircuit,  compare_circuits checks that both circuits have readouts targeting the same qubits, and that no operations exist on those qubits following readouts.\n\nExamples\n\njulia> c0 = QuantumCircuit(qubit_count = 1, instructions = [sigma_x(1), sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──X────Y──\n               \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 1, instructions = [phase_shift(1, π)])\nQuantum Circuit Object:\n   qubit_count: 1  \n   bit_count: 1  \nq[1]:──P(3.1416)──\n                  \n\n\n\njulia> compare_circuits(c0, c1)\ntrue            \n\njulia> c0 = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1), sigma_y(1), control_x(2, 3)])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────Y───────\n                    \nq[2]:────────────*──\n                 |  \nq[3]:────────────X──\n                    \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 3, instructions = [control_x(2, 3), sigma_x(1), sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:───────X────Y──\n                    \nq[2]:──*────────────\n       |            \nq[3]:──X────────────\n                    \n\n\n\njulia> compare_circuits(c0, c1)\ntrue    \n\njulia> c2 = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1), readout(1, 1)])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────✲──\n               \nq[2]:──────────\n               \nq[3]:──────────\n               \njulia> c3 = QuantumCircuit(qubit_count = 3, instructions = [sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X──\n          \nq[2]:─────\n          \nq[3]:─────\n          \n\njulia> compare_circuits(c2,c3)\nfalse    \n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.circuit_contains_gate_type","page":"Quantum Circuits","title":"Snowflurry.circuit_contains_gate_type","text":"circuit_contains_gate_type(circuit::QuantumCircuit, gate_type::Type{<: AbstractGateSymbol})::Bool\n\nDetermines whether a type of gate is present in a circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 1, instructions = [sigma_x(1), sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \n   bit_count: 1 \nq[1]:──X────Y──\n               \njulia> circuit_contains_gate_type(circuit, Snowflurry.SigmaX)\ntrue\n               \njulia> circuit_contains_gate_type(circuit, Snowflurry.ControlZ)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.permute_qubits!","page":"Quantum Circuits","title":"Snowflurry.permute_qubits!","text":"permute_qubits!(circuit::QuantumCircuit,\n    qubit_mapping::AbstractDict{T,T}) where T<:Integer\n\nModifies a circuit by moving the gates to other qubits based on a qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.\n\nFor instance, Dict(1 => 2) is not a valid qubit_mapping, but Dict(1 => 2, 2 => 1) is valid.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 3);\n\njulia> push!(c, sigma_x(1), hadamard(2), sigma_y(3))\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────────────\n                    \nq[2]:───────H───────\n                    \nq[3]:────────────Y──                    \n\n\n\njulia> permute_qubits!(c, Dict(1 => 3, 3 => 1))\n\njulia> show(c)\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:────────────Y──\n                    \nq[2]:───────H───────\n                    \nq[3]:──X────────────\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library/quantum_circuit.html#Snowflurry.permute_qubits","page":"Quantum Circuits","title":"Snowflurry.permute_qubits","text":"permute_qubits(circuit::QuantumCircuit,\n    qubit_mapping::AbstractDict{T,T})::QuantumCircuit where {T<:Integer}\n\nReturns a QuantumCircuit that is a copy of circuit but where the gates have been moved to other qubits based on a qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.\n\nFor instance, Dict(1=>2) is not a valid qubit_mapping, but Dict(1=>2, 2=>1) is valid.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 3);\n\njulia> push!(c, sigma_x(1), hadamard(2), sigma_y(3))\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:──X────────────\n                    \nq[2]:───────H───────\n                    \nq[3]:────────────Y──\n                    \n\n\n\njulia> permute_qubits(c, Dict(1 => 3, 3 => 1))\nQuantum Circuit Object:\n   qubit_count: 3 \n   bit_count: 3 \nq[1]:────────────Y──\n                    \nq[2]:───────H───────\n                    \nq[3]:──X────────────\n                    \n\n\n\n\n\n\n\n\n","category":"function"}]
}
