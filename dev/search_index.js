var documenterSearchIndex = {"docs":
[{"location":"tutorials/advanced/async_jobs.html#Asynchronous-jobs","page":"Asynchronous Jobs","title":"Asynchronous jobs","text":"","category":"section"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"DocTestSetup = quote\n    ENV[\"ANYON_QUANTUM_USER\"] = \"test-user\"\n    ENV[\"ANYON_QUANTUM_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"ANYON_QUANTUM_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"In this tutorial we will learn how to run jobs asynchronously using Julia tasks. Asynchronous jobs allow for the code to continue with other computation while waiting for the quantum resources.","category":"page"},{"location":"tutorials/advanced/async_jobs.html#Julia-tasks","page":"Asynchronous Jobs","title":"Julia tasks","text":"","category":"section"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"Practical applications of quantum computing typically involve both classical and quantum computation. A quantum processor is indeed a hardware accelerator in this paradigm. In such scenarios, it might take some time for the quantum computer to run the circuit that was submitted to it.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"In many cases, it is desirable to be able to continue with some classical computation while the program waits for the quantum hardware to complete its task. This is an example of asynchronous programming. We recommend you consult Julia's page on asynchronous programming if you are unfamiliar with this concept.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"In Snowflake, communicating with a quantum processor will yield execution every time it waits for a response from the quantum computer. This gives you the opportunity to perform work while the quantum computer is running your job.","category":"page"},{"location":"tutorials/advanced/async_jobs.html#Code","page":"Asynchronous Jobs","title":"Code","text":"","category":"section"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"To provide maximum flexibility, Snowflake does not impose any restrictions on how you parallelize your code. We cannot know what will be best for your code. That is up to you!","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"We will start by importing Snowflake, building our circuit, and defining our QPU as demonstrated in the Running a Circuit on a Real Hardware tutorial.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"using Snowflake\n\ncircuit = QuantumCircuit(qubit_count=2, gates=[\n    hadamard(1),\n    control_x(1, 2),\n])\n\nuser = ENV[\"ANYON_QUANTUM_USER\"]\ntoken = ENV[\"ANYON_QUANTUM_TOKEN\"]\nhost = ENV[\"ANYON_QUANTUM_HOST\"]\n\nqpu = AnyonYukonQPU(host=host, user=user, access_token=token)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"Next, we are going to define and schedule our task.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"shot_count = 200\ntask = Task(() -> run_job(qpu, circuit, shot_count))\nschedule(task)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"warning: Warning\nNote the last line above. It is important to schedule the task; otherwise, Julia will not know that it should start it!","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"Next, we need to yield execution of the current thread to the newly scheduled task to ensure that the scheduler starts with the task. Otherwise, the task will be scheduled, but it might not submit a job to the quantum computer any time soon! After yielding once, we can continue to do work before we fetch the results from that task.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"yieldto(task)\n\n# Simulate work by calculating the nth Fibonacci number slowly\nfunction fibonacci(n)\n  if n <= 2\n    return 1\n  end\n  return fibonacci(n - 1) + fibonacci(n - 2)\nend\n\nfibonacci(30)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"After we are done with our work, we can fetch the result of our job.","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"result = fetch(task)\nprintln(result)","category":"page"},{"location":"tutorials/advanced/async_jobs.html","page":"Asynchronous Jobs","title":"Asynchronous Jobs","text":"The full code is available at tutorials/asynchronous_jobs.jl","category":"page"},{"location":"getting_started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"DocTestSetup = quote\n    ENV[\"ANYON_QUANTUM_USER\"] = \"test-user\"\n    ENV[\"ANYON_QUANTUM_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"ANYON_QUANTUM_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"getting_started.html#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The following installation steps are for people interested in using Snowflake in their own applications. If you are interested in helping to develop Snowflake, head right over to our Developing Snowflake page.","category":"page"},{"location":"getting_started.html#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Make sure your system has Julia installed. If not, download the latest version from https://julialang.org/downloads/.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We officially support the latest stable release and the latest Long-term support release. Any release in-between should work (please file a bug if they don't), but we only actively test against the LTS and the latest stable version.","category":"page"},{"location":"getting_started.html#Installing-the-Snowflake-package","page":"Getting Started","title":"Installing the Snowflake package","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Snowflake is still in pre-release phase. Therefore, and for the time being, we recommand installing it by checking out the main branch from github. This can be achieved by typing the following commands in the Julia REPL:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(url=\"https://github.com/anyonlabs/Snowflake.jl\", rev=\"main\")","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"This will add the Snowflake  package to the current Julia Environment.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Once Snowflake.jl is released, you can install the latest release using the following command:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(\"Snowflake\")","category":"page"},{"location":"getting_started.html#Installing-the-SnowflakePlots-package","page":"Getting Started","title":"Installing the SnowflakePlots package","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Multiple visualization tools are available in the SnowflakePlots package. After installing Snowflake, the SnowflakePlots package can be installed by entering the following in the Julia REPL:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(url=\"https://github.com/anyonlabs/SnowflakePlots.jl\", rev=\"main\")","category":"page"},{"location":"getting_started.html#Typical-workflow","page":"Getting Started","title":"Typical workflow","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"A typical workflow to execute a quantum circuit on a quantum service consists of these three steps.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Create: Build the circuit using quantum gates.\nTranspile: Transpile the circuit to improve performance and make the circuit compatible with the quantum service.\nExecute: Run the compiled circuits on the specified quantum service. The quantum service could be a remote quantum hardware or a local simulator.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Now is the time to start with Snowflake and go over the tutorials. You could also consult with the Library reference page.","category":"page"},{"location":"library.html#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"DocTestSetup = :(using Snowflake, SnowflakePlots)","category":"page"},{"location":"library.html#Quantum-Circuit","page":"Library","title":"Quantum Circuit","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"QuantumCircuit\npush!\npop!\nappend!\nprepend!\nsimulate\nsimulate_shots\nget_measurement_probabilities(circuit::QuantumCircuit)\ninv(circuit::QuantumCircuit)\nget_num_gates_per_type\nget_num_gates\nserialize_job\ntranspile\ncompare_circuits\ncircuit_contains_gate_type\npermute_qubits!\npermute_qubits","category":"page"},{"location":"library.html#Snowflake.QuantumCircuit","page":"Library","title":"Snowflake.QuantumCircuit","text":"QuantumCircuit(qubit_count)\n\nA data structure to represent a quantum circuit.  \n\nFields\n\nqubit_count::Int – number of qubits (i.e. quantum register size).\ngates::Vector{AbstractGate} – the sequence of gates to operate on qubits.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n\n\n\n\n\n","category":"type"},{"location":"library.html#Base.push!","page":"Library","title":"Base.push!","text":"push!(circuit::QuantumCircuit, gates::AbstractGate...)\n\nInserts one or more gates at the end of a circuit.\n\nA Vector of AbstractGate objects can be passed to this function by using splatting. More details about splatting are provided here.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> gate_list = [sigma_x(1), hadamard(2)];\n\njulia> push!(c, gate_list...)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*────X───────\n                 |            \nq[2]:───────X────X─────────H──\n                              \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.pop!","page":"Library","title":"Base.pop!","text":"pop!(circuit::QuantumCircuit)\n\nRemoves the last gate from circuit.gates. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> pop!(c)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.append!","page":"Library","title":"Base.append!","text":"append!(base_circuit::QuantumCircuit, circuits_to_append::QuantumCircuit...)\n\nAppends one or more circuits_to_append to the base_circuit.\n\nThe circuits_to_append cannot contain more qubits than the base_circuit.\n\nExamples\n\njulia> base = QuantumCircuit(qubit_count=2, gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> append_1 = QuantumCircuit(qubit_count=1, gates=[sigma_z(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──Z──\n          \n\n\n\njulia> append_2 = QuantumCircuit(qubit_count=2, gates=[control_x(1,2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──X──\n          \n\n\n\njulia> append!(base, append_1, append_2)\n\njulia> print(base)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────Z────*──\n                 |  \nq[2]:────────────X──\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.prepend!","page":"Library","title":"Base.prepend!","text":"prepend!(base_circuit::QuantumCircuit, circuits_to_prepend::QuantumCircuit...)\n\nPrepends one or more circuits_to_prepend to the base_circuit.\n\nThe order of the circuits_to_prepend is maintained (i.e. circuits_to_prepend[1] will appear leftmost in base_circuit). The circuits_to_prepend cannot contain more qubits than the base_circuit.\n\nExamples\n\njulia> base = QuantumCircuit(qubit_count=2, gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> prepend_1 = QuantumCircuit(qubit_count=1, gates=[sigma_z(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──Z──\n          \n\n\n\njulia> prepend_2 = QuantumCircuit(qubit_count=2, gates=[control_x(1,2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──X──\n          \n\n\n\njulia> prepend!(base, prepend_1, prepend_2)\n\njulia> print(base)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────*────X──\n            |       \nq[2]:───────X───────\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.simulate","page":"Library","title":"Snowflake.simulate","text":"simulate(circuit::QuantumCircuit)\n\nSimulates and returns the wavefunction of the quantum device after running circuit,  assuming an initial state Ket ψ corresponding to the 0th Fock basis, i.e.:  ψ=fock(0,2^get_num_qubits(circuit)). \n\nEmploys the approach described in Listing 5 of Suzuki et. al. (2021).\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> ket = simulate(c)\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.simulate_shots","page":"Library","title":"Snowflake.simulate_shots","text":"simulate_shots(c::QuantumCircuit, shots_count::Int = 100)\n\nEmulates a quantum computer by running a circuit for a given number of shots and returning measurement results.  The distribution of measured states corresponds to the coefficients in the resulting state Ket. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> simulate_shots(c, 99)\n99-element Vector{String}:\n \"11\"\n \"00\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"00\"\n \"00\"\n \"11\"\n ⋮\n \"00\"\n \"00\"\n \"11\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_measurement_probabilities-Tuple{QuantumCircuit}","page":"Library","title":"Snowflake.get_measurement_probabilities","text":"get_measurement_probabilities(circuit::QuantumCircuit,\n    [target_qubits::Vector{<:Integer}])::AbstractVector{<:Real}\n\nReturns a vector listing the measurement probabilities for the target_qubits in the circuit.\n\nIf no target_qubits are provided, the probabilities are computed for all the qubits.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit QuantumCircuit, the probabilities are listed for 00, 01, 10, and 11.\n\nExamples\n\nThe following example constructs a QuantumCircuit where the probability of measuring 01 is 50% and the probability of measuring 11 is also 50%.\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> get_measurement_probabilities(circuit)\n4-element Vector{Float64}:\n 0.0\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n\n\nFor the same circuit, the probability of measuring qubit 2 and finding 1 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(circuit, target_qubit)\n2-element Vector{Float64}:\n 0.0\n 0.9999999999999998\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Base.inv-Tuple{QuantumCircuit}","page":"Library","title":"Base.inv","text":"inv(circuit::QuantumCircuit)\n\nReturn a QuantumCircuit which is the inverse of the input circuit.  Each gate is replaced by it's corresponding inverse, and the order of gates is reversed.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, rotation_y(1, pi/4));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Ry(0.7854)────*──\n                     |  \nq[2]:────────────────X──\n                        \n\n\n\njulia> inv(c)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*────Ry(-0.7854)──\n       |                 \nq[2]:──X─────────────────\n                         \n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_gates_per_type","page":"Library","title":"Snowflake.get_num_gates_per_type","text":"get_num_gates_per_type(circuit::QuantumCircuit)::AbstractDict{<:AbstractString, <:Integer}\n\nReturns a dictionary listing the number of gates of each type found in the circuit.\n\nThe dictionary keys are the instruction_symbol of the gates while the values are the number of gates found.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, hadamard(1), hadamard(2));\n\njulia> push!(c, control_x(1, 2));\n\njulia> push!(c, hadamard(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*───────\n                 |       \nq[2]:───────H────X────H──\n                         \n\n\n\njulia> get_num_gates_per_type(c)\nDict{String, Int64} with 2 entries:\n  \"h\"  => 3\n  \"cx\" => 1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_gates","page":"Library","title":"Snowflake.get_num_gates","text":"get_num_gates(circuit::QuantumCircuit)::Integer\n\nReturns the number of gates in the circuit.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, hadamard(1), hadamard(2));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────H────X──\n                    \n\n\n\njulia> get_num_gates(c)\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.serialize_job","page":"Library","title":"Snowflake.serialize_job","text":"serialize_job(circuit::QuantumCircuit,shot_count::Integer)\n\nCreates a JSON-formatted String containing the circuit configuration to be sent  to a QPU service, along with the number of shots requested.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2,gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> serialize_job(c,10)\n\"{\\\"shot_count\\\":10,\\\"circuit\\\":{\\\"operations\\\":[{\\\"parameters\\\":{},\\\"type\\\":\\\"x\\\",\\\"qubits\\\":[0]}]}}\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.transpile","page":"Library","title":"Snowflake.transpile","text":"transpile(::CompressSingleQubitGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CompressSingleQubitGatesTranspiler transpiler stage  which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single Universal gates in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CompressSingleQubitGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────Y──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y─────────Rz(1.0472)──\n                                  \nq[2]:────────────*────────────────\n                 |                \nq[3]:────────────X────────────────\n                                  \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────\n                                            \nq[2]:────────────────────────────────────*──\n                                         |  \nq[3]:────────────────────────────────────X──\n                                            \n\n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastSwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastSwapToCZGateTranspiler transpiler stage which expands all Swap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastSwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[swap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──☒──\n       |\nq[2]:──☒──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────\n                |                     |                     |          \nq[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──\n                                              \n\n\n\n\n\n\ntranspile(::CastCXToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastCXToCZGateTranspiler transpiler stage which expands all CX gates into CZ and Hadamard gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastCXToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──*──\n       |\nq[2]:──X──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:───────*───────\n            |\nq[2]:──H────Z────H──\n\n\n\n\n\ntranspile(::CastISwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastISwapToCZGateTranspiler transpiler stage which expands all ISwap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastISwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[iswap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──x──\n       |\nq[2]:──x──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────\n                         |                     |                  \nq[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──\n                                                                  \n\n\n\n\n\n\ntranspile(::CastToffoliToCXGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastToffoliToCXGateTranspiler transpiler stage which expands all Toffoli gates into CX gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastToffoliToCXGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[toffoli(1, 2, 3)])\nQuantum Circuit Object:\n   qubit_count: 3\nq[1]:──*──\n       |\nq[2]:──*──\n       |\nq[3]:──X──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──────────────────*────────────────────*──────────────*─────────T──────────*──\n                       |                    |              |                    |  \nq[2]:───────*──────────|─────────*──────────|────T─────────X──────────────T†────X──\n            |          |         |          |                                      \nq[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──────────────────\n                                                                                   \n\n\n\n\n\n\ntranspile(::CastToPhaseShiftAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastToPhaseShiftAndHalfRotationXTranspiler transpiler stage  which converts all single-qubit gates in an input circuit and converts them  into combinations of PhaseShift and RotationX with angle π/2 in an output  circuit. For any gate in the input circuit, the number of gates in the  output varies between zero and 5. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastToPhaseShiftAndHalfRotationXTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────X_90────Z────X_m90──\n                                                 \nq[2]:───────────────────────────\n                                                 \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Y──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90────X_90────Z────X_m90────Z_90──\n                                           \nq[2]:──────────────────────────────────────\n                                           \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastUniversalToRzRxRzTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastUniversalToRzRxRzTranspiler transpiler stage  which finds Universal gates in an input circuit and converst casts  them into a sequence of PhaseShift (Rz), RotationX (Rx) and  PhaseShift (Rz) gates in a new circuit. The result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastUniversalToRzRxRzTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,π/2,π/4,π/8)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=1.5708,ϕ=0.7854,λ=0.3927)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rz(-1.1781)────Rx(1.5708)────Rz(2.3562)──\n                                                \nq[2]:───────────────────────────────────────────\n                                                \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0,π/4,0)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.7854,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rz(-1.5708)────Rx(0.0000)────Rz(2.3562)──\n                                                \nq[2]:───────────────────────────────────────────\n                                                \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastRxToRzAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastRxToRzAndHalfRotationXTranspiler transpiler stage  which finds RotationX(θ) gates in an input circuit and converts (casts)  them into a sequence of gates: Z90,X90,PhaseShift(θ),XM90,ZM90 in a new circuit. The result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastRxToRzAndHalfRotationXTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,π/8)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(0.3927)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90────X_90────Rz(0.3927)────X_m90────Z_m90──\n                                                     \nq[2]:────────────────────────────────────────────────\n                                                     \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SimplifyRxGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyRxGatesTranspiler transpiler stage  which finds RotationX gates in an input circuit and according to it's  angle theta, casts them to one of the right-angle RotationX gates,  e.g. SigmaX, X90, or XM90. In the case where theta≈0., the gate is removed. The result of the input and output circuit on any arbitrary state Ket is  unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=SimplifyRxGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi/2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(1.5708)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X_90──\n             \nq[2]:────────\n             \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(3.1416)──\n                   \nq[2]:──────────────\n                   \n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(0.0000)──\n                   \nq[2]:──────────────\n                   \n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SwapQubitsForLineConnectivityTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SwapQubitsForLineConnectivityTranspiler transpiler stage  which adds Swap gates around multi-qubit gates so that the  final Operator acts on adjacent qubits. The result of the input  and output circuit on any arbitrary state Ket is unchanged  (up to a global phase).\n\nExamples\n\njulia> transpiler=SwapQubitsForLineConnectivityTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 6, gates=[toffoli(4,6,1)])\nQuantum Circuit Object:\n   qubit_count: 6 \nq[1]:──X──\n       |  \nq[2]:──|──\n       |  \nq[3]:──|──\n       |  \nq[4]:──*──\n       |  \nq[5]:──|──\n       |  \nq[6]:──*──\n          \n\n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 6 \nq[1]:───────────────────────────X───────────────────────────\n                                |                           \nq[2]:───────☒───────────────────*───────────────────☒───────\n            |                   |                   |       \nq[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──\n       |                   |         |                   |  \nq[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──\n                      |                   |                 \nq[5]:────────────☒────☒───────────────────☒────☒────────────\n                 |                             |            \nq[6]:────────────☒─────────────────────────────☒────────────\n                                                            \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SimplifyRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyRzGatesTranspiler transpiler stage  which finds PhaseShift gates in an input circuit and according to it's  phase angle phi, casts them to one of the right-angle RotationZ gates,  e.g. SigmaZ, Z90, ZM90, Pi8 or Pi8Dagger. In the case where phi≈0., the  gate is removed. The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyRzGatesTranspiler(1.0e-10)\n\nExamples\n\njulia> transpiler=SimplifyRzGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,pi/2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rz(1.5708)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90──\n             \nq[2]:────────\n             \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,pi)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rz(3.1416)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z──\n          \nq[2]:─────\n          \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rz(0.0000)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CompressRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CompressRzGatesTranspiler transpiler stage  which gathers all Rz-type gates sharing a common target in an input  circuit and combines them into single PhaseShift gate in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CompressRzGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_z(1),z_90(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────Z_90──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rz(-1.5708)──\n                    \nq[2]:───────────────\n                    \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_z(1),pi_8(1),control_x(2,3),z_minus_90(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──Z────T─────────Z_m90──\n                             \nq[2]:────────────*───────────\n                 |           \nq[3]:────────────X───────────\n                             \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──Rz(2.3562)───────\n                        \nq[2]:────────────────*──\n                     |  \nq[3]:────────────────X──\n                        \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::RemoveSwapBySwappingGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nRemoves the Swap gates from the circuit assuming all-to-all connectivity.\n\nwarning: The initial state must be the ground state!\nThis transpiler stage assumes that the input state is 0rangle^otimes N where N is the number of qubits. The stage should not be used on sub-circuits where the input state is not 0rangle^otimes N.\n\nThis transpiler stage eliminates Swap gates by moving the gates preceding each Swap gate.\n\nExamples\n\njulia> transpiler = RemoveSwapBySwappingGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count=2, gates=[hadamard(1), swap(1,2), sigma_x(2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────☒───────\n            |       \nq[2]:───────☒────X──\n                    \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──────────\n               \nq[2]:──H────X──\n               \n\n\n\n\n\n\n\n\ntranspile(::SimplifyTrivialGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyTrivialGatesTranspiler transpiler stage  which finds gates which have no effect on the state Ket, such as Identity, and  parameterized gates with null parameters such as rotation_x(target, 0.). The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyTrivialGatesTranspiler(1.0e-10)\n\nExamples\n\njulia> transpiler=SimplifyTrivialGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[identity_gate(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──I──\n          \nq[2]:─────\n          \njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rz(0.0000)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                             \njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.compare_circuits","page":"Library","title":"Snowflake.compare_circuits","text":"compare_circuits(c0::QuantumCircuit,c1::QuantumCircuit)::Bool\n\nTests for equivalence of two circuits based on their effect on an  arbitrary input state (a Ket). Circuits are equivalent if they both  yield the same output for any input, up to a global phase. Circuits with different ordering of gates that apply on different  targets can also be equivalent.\n\nExamples\n\njulia> c0 = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Y──\n               \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 1, gates=[phase_shift(1,π)])\nQuantum Circuit Object:\n   qubit_count: 1  \nq[1]:──Rz(3.1416)──\n                   \n\n\n\njulia> compare_circuits(c0,c1)\ntrue            \n\njulia> c0 = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y───────\n                    \nq[2]:────────────*──\n                 |  \nq[3]:────────────X──\n                    \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 3, gates=[control_x(2,3),sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:───────X────Y──\n                    \nq[2]:──*────────────\n       |            \nq[3]:──X────────────\n                    \n\n\n\njulia> compare_circuits(c0,c1)\ntrue    \n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.circuit_contains_gate_type","page":"Library","title":"Snowflake.circuit_contains_gate_type","text":"circuit_contains_gate_type(circuit::QuantumCircuit, gate_type::Type{<:AbstractGate})::Bool\n\nDetermined whether or not a type of gate is present in a circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Y──\n               \njulia> circuit_contains_gate_type(circuit, Snowflake.SigmaX)\ntrue\n               \njulia> circuit_contains_gate_type(circuit, Snowflake.ControlZ)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.permute_qubits!","page":"Library","title":"Snowflake.permute_qubits!","text":"permute_qubits!(circuit::QuantumCircuit,\n    qubit_mapping::AbstractDict{T,T}) where T<:Integer\n\nModifies a circuit by moving the gates to other qubits based on a qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.\n\nFor instance, Dict(1=>2) is not a valid qubit_mapping, but Dict(1=>2, 2=>1) is valid.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=3);\n\njulia> push!(c, sigma_x(1), hadamard(2), sigma_y(3))\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────────────\n                    \nq[2]:───────H───────\n                    \nq[3]:────────────Y──                    \n\n\n\njulia> permute_qubits!(c, Dict(1=>3, 3=>1))\n\njulia> show(c)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:────────────Y──\n                    \nq[2]:───────H───────\n                    \nq[3]:──X────────────\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.permute_qubits","page":"Library","title":"Snowflake.permute_qubits","text":"permute_qubits(circuit::QuantumCircuit,\n    qubit_mapping::AbstractDict{T,T})::QuantumCircuit where T<:Integer\n\nReturns a QuantumCircuit that is a copy of circuit but where the gates have been moved to other qubits based on a qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.\n\nFor instance, Dict(1=>2) is not a valid qubit_mapping, but Dict(1=>2, 2=>1) is valid.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=3);\n\njulia> push!(c, sigma_x(1), hadamard(2), sigma_y(3))\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────────────\n                    \nq[2]:───────H───────\n                    \nq[3]:────────────Y──\n                    \n\n\n\njulia> permute_qubits(c, Dict(1=>3, 3=>1))\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:────────────Y──\n                    \nq[2]:───────H───────\n                    \nq[3]:──X────────────\n                    \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Quantum-Gates","page":"Library","title":"Quantum Gates","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"AbstractGate\nControlledGate\neye\nidentity_gate\nsigma_p\nsigma_m\nsigma_x\nsigma_y\nsigma_z\nhadamard\npi_8\npi_8_dagger\nx_90\nx_minus_90\ny_90\ny_minus_90\nz_90\nz_minus_90\nrotation\nrotation_x\nrotation_y\nphase_shift\nuniversal\ncontrol_z\ncontrol_x\niswap\nswap\ntoffoli\niswap_dagger\nBase.:*(M::AbstractGate, x::Ket)\napply_gate!\nget_operator\ninv(gate::AbstractGate)\nis_gate_type\nget_gate_type\nmove_gate","category":"page"},{"location":"library.html#Snowflake.AbstractGate","page":"Library","title":"Snowflake.AbstractGate","text":"AbstractGate\n\nA Gate is an instantiation of an AbstractGate, which can be added to a QuantumCircuit in order to apply an operator to one or more target qubits. AbstractGate is useful to dispatch all Gates to default implementation of functions such as getconnectedqubits().  Those functions are then specialized for Gates requiring a different implementation. \n\nAbstractGate is an abstract type, which means that it cannot be instantiated.  Instead, each concrete type of Gate is a struct which is a subtype of AbstractGate. Each descendant of AbstractGate must have at least the following fields:\n\ntarget::Int: the qubit number to which the Gate is applied. Some gates have multiple targets.\nparameter::Real: for parameterized gates, determines which operation is applied (e.g. rotation angles), i.e., is used in the construction of the matrix used in the application of its Operator.\n\nExamples\n\nA struct must be defined for each new Gate type, such as the following X_45 Gate which applies a 45° rotation about the X axis:\n\njulia> struct X45 <: AbstractGate\n           target::Int\n       end;\n\n\nA Gate constructor must be defined as:\n\njulia> x_45(target::Integer) = X45(target);\n\n\nalong with an Operator constructor, with default precision ComplexF64, defined as:\n\njulia> x_45(T::Type{<:Complex}=ComplexF64)=rotation_x(π/4, T);\n\n\nTo simulate the effect of the gate in a QuantumCircuit or when applied to a Ket, the function get_operator must be extended.\n\njulia> Snowflake.get_operator(gate::X45, T::Type{<:Complex}=ComplexF64) = rotation_x(π/4, T);\n\n\nThe gate inverse can also be specified by extending the inv function.\n\njulia> inv(gate::X45) = rotation_x(gate.target, -π/4);\n\n\nAn instance of the X_45 Gate can now be created, along with its inverse:\n\njulia> x_45_gate = x_45(1)\nGate Object: X45\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im\n0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\njulia> inv(x_45_gate)\nGate Object: Snowflake.RotationX\nParameters: \ntheta\t: -0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    -0.0 + 0.3826834323650898im\n-0.0 + 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\n\nTo enable printout of a QuantumCircuit containing our new Gate type, a display symbol  must be defined as follows.\n\njulia> Snowflake.gates_display_symbols[X45]=[\"X45\"];\n\n\nIf this Gate is to be sent as an instruction to a hardware QPU,  an instruction String must be defined.\n\njulia> Snowflake.gates_instruction_symbols[X45]=\"x45\";\n\n\nA circuit containing this Gate can now be constructed:\n\njulia> circuit=QuantumCircuit(qubit_count=2,gates=[x_45_gate])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──X45──\n\nq[2]:───────\n\n\nIn addition, a ControlledGate{X45} can be constructed using:\n\njulia> control=1; target=2;\n\njulia> ControlledGate(x_45(target),control)\nGate Object: ControlledGate{X45}\nConnected_qubits\t: [1, 2]\nOperator:\n(4, 4)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im\n0.0 + 0.0im    0.0 + 0.0im    0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.ControlledGate","page":"Library","title":"Snowflake.ControlledGate","text":"ControlledGate{G<:AbstractGate}<:AbstractGate\n\nThe ControlledGate object allows the construction of a controlled Gate using an Operator  (the kernel) and the corresponding control and target qubits,  specified as control_qubit::Int target_qubit::Int for single-target single-control, or control_qubit::Vector{Int} target_qubit::{Int} in the general case. In the case of single-control single-target ControlledGate, apply_gate() dispatches to  an optimized routine, otherwise the fall-back case casts a equivalent DenseOperator and  applies it. \n\nExamples\n\nWhereas a Hadamard Gate with target=1 is constructed by calling hadamard(target), a  controlled Hadamard gate is constructed using the hadamard() Function. For instance, the construction  of a ControlledGate{Hadamard} with control=1 and target=2 is performed by calling:\n\njulia> controlled_hadamard=ControlledGate(hadamard(2),1)\nGate Object: ControlledGate{Snowflake.Hadamard}\nConnected_qubits\t: [1, 2]\nOperator:\n(4, 4)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.7071067811865475 + 0.0im    0.7071067811865475 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.7071067811865475 + 0.0im    -0.7071067811865475 + 0.0im\n\n\nIt can then be used in a QuantumCircuit as any other Gate, and its display symbol is  inherited from the display symbol of the single-target Hadamard Gate:\n\njulia> circuit=QuantumCircuit(qubit_count=2,gates=[controlled_hadamard])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──H──\n          \n\nIn general, a ControlledGate with an arbitraty number of targets and controls can be  constructed. For instance, the following constructs the equivalent of a Toffoli Gate,  but as a ConnectedGate{SigmaX}, with control_qubits=[1,2] and target_qubit=[3]:\n\njulia> toffoli_as_controlled_gate=ControlledGate(sigma_x(3),[1,2])\nGate Object: ControlledGate{Snowflake.SigmaX}\nConnected_qubits\t: [1, 2, 3]\nOperator:\n(8, 8)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.eye","page":"Library","title":"Snowflake.eye","text":"eye(),\neye(size::Integer)\n\nReturn the identity matrix as a DenseOperator, which is defined as:\n\nI = beginbmatrix\n    1  0 \n    0  1\n    endbmatrix\n\nCalling eye(size) will produce an identity matrix DenseOperator  of dimensions (size,size).\n\nExamples\n\njulia> eye()\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\njulia> eye(4)\n(4, 4)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.identity_gate","page":"Library","title":"Snowflake.identity_gate","text":"identity_gate(target)\n\nReturn the Identity Gate, which applies the identity_gate() IdentityOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_p","page":"Library","title":"Snowflake.sigma_p","text":"sigma_p()\n\nReturn the spin-frac12 raising Operator, which is defined as:\n\nsigma_+ = beginbmatrix\n    0  1 \n    0  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_m","page":"Library","title":"Snowflake.sigma_m","text":"sigma_m()\n\nReturn the spin-frac12 lowering Operator, which is defined as:\n\nsigma_- = beginbmatrix\n    0  0 \n    1  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_x","page":"Library","title":"Snowflake.sigma_x","text":"sigma_x()\n\nReturn the Pauli-X AntiDiagonalOperator, which is defined as:\n\nsigma_x = beginbmatrix\n    0  1 \n    1  0\n    endbmatrix\n\n\n\n\n\nsigma_x(target)\n\nReturn the Pauli-X Gate, which applies the sigma_x() AntiDiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_y","page":"Library","title":"Snowflake.sigma_y","text":"sigma_y()\n\nReturn the Pauli-Y Operator, which is defined as:\n\nsigma_y = beginbmatrix\n    0  -i \n    i  0\n    endbmatrix\n\n\n\n\n\nsigma_y(target)\n\nReturn the Pauli-Y Gate, which applies the sigma_y() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_z","page":"Library","title":"Snowflake.sigma_z","text":"sigma_z()\n\nReturn the Pauli-Z Operator, which is defined as:\n\nsigma_z = beginbmatrix\n    1  0 \n    0  -1\n    endbmatrix\n\n\n\n\n\nsigma_z(target)\n\nReturn the Pauli-Z Gate, which applies the sigma_z() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.hadamard","page":"Library","title":"Snowflake.hadamard","text":"hadamard()\n\nReturn the Hadamard Operator, which is defined as:\n\nH = frac1sqrt2beginbmatrix\n    1  1 \n    1  -1\n    endbmatrix\n\n\n\n\n\nhadamard(target)\n\nReturn the Hadamard Gate, which applies the hadamard() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.pi_8","page":"Library","title":"Snowflake.pi_8","text":"pi_8()\n\nReturn the Operator for the π/8 gate, which is defined as:\n\nT = beginbmatrix\n    1  0 \n    0  e^ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8(target)\n\nReturn a π/8 Gate (also known as a T Gate), which applies the pi_8() DiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.pi_8_dagger","page":"Library","title":"Snowflake.pi_8_dagger","text":"pi_8_dagger()\n\nReturn the adjoint DiagonalOperator of the π/8 gate, which is defined as:\n\nT^dagger = beginbmatrix\n    1  0 \n    0  e^-ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8_dagger(target)\n\nReturn an adjoint π/8 Gate (also known as a T^dagger Gate), which applies the pi_8_dagger() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.x_90","page":"Library","title":"Snowflake.x_90","text":"x_90()\n\nReturn the Operator which applies a π/2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -i \n    -i  1\n    endbmatrix\n\n\n\n\n\nx_90(target)\n\nReturn a Gate that applies a 90° rotation about the X axis as defined by the x_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.x_minus_90","page":"Library","title":"Snowflake.x_minus_90","text":"x_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  i \n    i  1\n    endbmatrix\n\n\n\n\n\nx_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the X axis as defined by the x_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.y_90","page":"Library","title":"Snowflake.y_90","text":"y_90()\n\nReturn the Operator which applies a π/2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -1 \n    1  1\n    endbmatrix\n\n\n\n\n\ny_90(target)\n\nReturn a Gate that applies a 90° rotation about the Y axis as defined by the y_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.y_minus_90","page":"Library","title":"Snowflake.y_minus_90","text":"y_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  1 \n    -1  1\n    endbmatrix\n\n\n\n\n\ny_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the Y axis as defined by the y_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.z_90","page":"Library","title":"Snowflake.z_90","text":"z_90()\n\nReturn the Operator which applies a π/2 rotation about the Z axis.\n\nThe Operator is defined as:\n\nR_zleft(fracpi2right) = beginbmatrix\n    1  0 \n    0  i\n    endbmatrix\n\n\n\n\n\nz_90(target)\n\nReturn a Gate that applies a 90° rotation about the Z axis as defined by the z_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.z_minus_90","page":"Library","title":"Snowflake.z_minus_90","text":"z_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the Z axis.\n\nThe Operator is defined as:\n\nR_zleft(-fracpi2right) = beginbmatrix\n    1  0 \n    0  -i\n    endbmatrix\n\n\n\n\n\nz_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the Z axis as defined by the z_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation","page":"Library","title":"Snowflake.rotation","text":"rotation(theta, phi)\n\nReturn the Operator which applies a rotation theta about the cos(phi)X+sin(phi)Y axis.\n\nThe Operator is defined as:\n\nR(theta phi) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -i e^-iphi mathrmsinleft(fractheta2right) 05em      \n    -i e^iphi mathrmsinleft(fractheta2right) \n        mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation(target, theta, phi)\n\nReturn a gate that applies a rotation theta to the target qubit about the cos(phi)X+sin(phi)Y axis.\n\nThe corresponding Operator is rotation(theta, phi).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation_x","page":"Library","title":"Snowflake.rotation_x","text":"rotation_x(theta)\n\nReturn the Operator which applies a rotation theta about the X axis.\n\nThe Operator is defined as:\n\nR_x(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -imathrmsinleft(fractheta2right) 05em      \n-imathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_x(target, theta)\n\nReturn a Gate that applies a rotation theta about the X axis of the target qubit.\n\nThe corresponding Operator is rotation_x(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation_y","page":"Library","title":"Snowflake.rotation_y","text":"rotation_y(theta)\n\nReturn the Operator that applies a rotation theta about the Y axis of the target qubit.\n\nThe Operator is defined as:\n\nR_y(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -mathrmsinleft(fractheta2right) 05em      \nmathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_y(target, theta)\n\nReturn a Gate that applies a rotation theta about the Y axis of the target qubit.\n\nThe corresponding Operator is rotation_y(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.phase_shift","page":"Library","title":"Snowflake.phase_shift","text":"phase_shift(phi)\n\nReturn the DiagonalOperator that applies a phase shift phi.\n\nThe DiagonalOperator is defined as:\n\nP(phi) = beginbmatrix\n    1  0 05em      \n    0  e^iphi\nendbmatrix\n\n\n\n\n\nphase_shift(target, phi)\n\nReturn a Gate that applies a phase shift phi to the target qubit as defined by the phase_shift(phi) DiagonalOperator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.universal","page":"Library","title":"Snowflake.universal","text":"universal(theta, phi, lambda)\n\nReturn the Operator which performs a rotation about the angles theta, phi, and lambda. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU\n\nThe Operator is defined as:\n\nU(theta phi lambda) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -e^ilambdamathrmsinleft(fractheta2right) 05em      \n    e^iphimathrmsinleft(fractheta2right) \n        e^ileft(phi+lambdaright)mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nuniversal(target, theta, phi, lambda)\n\nReturn a gate which rotates the target qubit given the angles theta, phi, and lambda. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU\n\nThe corresponding Operator is universal(theta, phi, lambda).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.control_z","page":"Library","title":"Snowflake.control_z","text":"control_z()\n\nReturn the controlled-Z Operator, which is defined as:\n\nCZ = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\n    endbmatrix\n\n\n\n\n\ncontrol_z(control_qubit, target_qubit)\n\nReturn a controlled-Z gate given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_z().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.control_x","page":"Library","title":"Snowflake.control_x","text":"control_x()\n\nReturn the controlled-X (or controlled NOT) Operator, which is defined as:\n\nCX = CNOT = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endbmatrix\n\n\n\n\n\ncontrol_x(control_qubit, target_qubit)\n\nReturn a controlled-X gate (also known as a controlled NOT gate) given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_x().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.iswap","page":"Library","title":"Snowflake.iswap","text":"iswap()\n\nReturn the imaginary swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap(qubit_1, qubit_2)\n\nReturn the imaginary swap Gate which applies the imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.swap","page":"Library","title":"Snowflake.swap","text":"swap()\n\nReturn the swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\nswap(qubit_1, qubit_2)\n\nReturn the swap Gate which applies the swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is swap().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.toffoli","page":"Library","title":"Snowflake.toffoli","text":"toffoli()\n\nReturn the Toffoli Operator, which is defined as:\n\nCCX = CCNOT = beginbmatrix\n    1  0  0  0  0  0  0  0 \n    0  1  0  0  0  0  0  0 \n    0  0  1  0  0  0  0  0 \n    0  0  0  1  0  0  0  0 \n    0  0  0  0  1  0  0  0 \n    0  0  0  0  0  1  0  0 \n    0  0  0  0  0  0  0  1 \n    0  0  0  0  0  0  1  0\n    endbmatrix\n\n\n\n\n\ntoffoli(control_qubit_1, control_qubit_2, target_qubit)\n\nReturn a Toffoli gate (also known as a CCNOT gate) given two control qubits and a target_qubit.\n\nThe corresponding Operator is toffoli().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.iswap_dagger","page":"Library","title":"Snowflake.iswap_dagger","text":"iswap_dagger()\n\nReturn the adjoint of the imaginary swap Operator, which is defined as:\n\niSWAP^dagger = beginbmatrix\n    1  0  0  0 \n    0  0  -i  0 \n    0  -i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap_dagger(qubit_1, qubit_2)\n\nReturn the adjoint imaginary swap Gate which applies the adjoint imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap_dagger().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.:*-Tuple{AbstractGate, Ket}","page":"Library","title":"Base.:*","text":"Base.:*(M::AbstractGate, x::Ket)\n\nReturn a Ket which results from applying Gate M to Ket x.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_1 = sigma_x(1)*ψ_0\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.apply_gate!","page":"Library","title":"Snowflake.apply_gate!","text":"apply_gate!(state::Ket, gate::Gate)\n\nUpdate the state by applying a gate to it.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> apply_gate!(ψ_0, sigma_x(1))\n\njulia> print(ψ_0)\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_operator","page":"Library","title":"Snowflake.get_operator","text":"get_operator(gate::Gate)\n\nReturns the Operator which is associated to a Gate.\n\nExamples\n\njulia> x = sigma_x(1);\n\njulia> get_operator(x)\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.inv-Tuple{AbstractGate}","page":"Library","title":"Base.inv","text":"inv(gate::AbstractGate)\n\nReturn a Gate which is the inverse of the input gate.\n\nExamples\n\njulia> u = universal(1, -pi/2, pi/3, pi/4)\nGate Object: Snowflake.Universal\nParameters: \ntheta\t: -1.5707963267948966\nphi\t: 1.0471975511965976\nlambda\t: 0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.5 + 0.4999999999999999im\n-0.3535533905932738 - 0.6123724356957945im    -0.18301270189221924 + 0.6830127018922194im\n\n\njulia> inv(u)\nGate Object: Snowflake.Universal\nParameters: \ntheta\t: 1.5707963267948966\nphi\t: -0.7853981633974483\nlambda\t: -1.0471975511965976\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    -0.3535533905932738 + 0.6123724356957945im\n0.5 - 0.4999999999999999im    -0.18301270189221924 - 0.6830127018922194im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.is_gate_type","page":"Library","title":"Snowflake.is_gate_type","text":"is_gate_type(gate::AbstractGate, type::Type)::Bool\n\nDetermines if a gate is of the specified type.\n\nwarning: Use is_gate_type instead of isa!\nFor AbstractGate objects, is_gate_type should be used instead of isa. The utilization of isa could lead to unexpected behavior (e.g. if a gate has been moved).\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Snowflake.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> is_gate_type(gate, Snowflake.SigmaX)\ntrue\n\njulia> is_gate_type(gate, Snowflake.SigmaY)\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_gate_type","page":"Library","title":"Snowflake.get_gate_type","text":"get_gate_type(gate::AbstractGate)::Type\n\nReturns the type of a gate.\n\nwarning: Use get_gate_type instead of typeof!\nFor AbstractGate objects, get_gate_type should be used instead of typeof. The utilization of typeof could lead to unexpected behavior (e.g. if a gate has been moved).\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Snowflake.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> get_gate_type(gate)\nSnowflake.SigmaX\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.move_gate","page":"Library","title":"Snowflake.move_gate","text":"move_gate(gate::AbstractGate,\n    qubit_mapping::AbstractDict{<:Integer,<:Integer})::AbstractGate\n\nReturns a copy of gate where the qubits on which the gate acts have been updated based on qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit.\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Snowflake.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> move_gate(gate, Dict(1=>2))\nGate Object: Snowflake.SigmaX\nConnected_qubits\t: [2]\nOperator:\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Quantum-Processing-Unit","page":"Library","title":"Quantum Processing Unit","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"AnyonYukonQPU\nVirtualQPU\nClient\nget_host\nsubmit_circuit\nget_status\nget_result\nrun_job\ntranspile_and_run_job\nget_transpiler\nSequentialTranspiler","category":"page"},{"location":"library.html#Snowflake.AnyonYukonQPU","page":"Library","title":"Snowflake.AnyonYukonQPU","text":"AnyonYukonQPU\n\nA data structure to represent a Anyon System's QPU.  \n\nFields\n\nclient                  ::Client – Client to the QPU server.\nstatus_request_throttle ::Function – Used to rate-limit job status requests.\n\nExample\n\njulia>  qpu = AnyonYukonQPU(host=\"example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\")\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   qubit_count:   6 \n   connectivity_type:  linear\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.VirtualQPU","page":"Library","title":"Snowflake.VirtualQPU","text":"VirtualQPU\n\nA data structure to represent a Quantum Simulator.  \n\nExample\n\njulia> qpu=VirtualQPU()\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflake.jl\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.Client","page":"Library","title":"Snowflake.Client","text":"Client\n\nA data structure to represent a Client to a QPU service.  \n\nFields\n\nhost::String – URL of the QPU server.\nuser::String – Username.\naccess_token::String – User access token.\n\nExample\n\njulia> c = Client(host=\"http://example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\")\nClient for QPU service:\n   host:         http://example.anyonsys.com\n   user:         test_user \n \n  \n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.get_host","page":"Library","title":"Snowflake.get_host","text":"get_host(Client)\n\nReturns host URL of a Client to a QPU service.  \n\nExample\n\njulia> c = Client(host=\"http://example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\");\n\njulia> get_host(c)\n\"http://example.anyonsys.com\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.submit_circuit","page":"Library","title":"Snowflake.submit_circuit","text":"submit_circuit(client::Client,circuit::QuantumCircuit,shot_count::Integer)\n\nSubmit a circuit to a Client of QPU service, requesting a number of  repetitions (shot_count). Returns circuitID.\n\nExample\n\njulia> submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_status","page":"Library","title":"Snowflake.get_status","text":"get_status(client::Client,circuitID::String)::Dict{String, String}\n\nObtain the status of a circuit computation through a Client of a QPU service. Returns status::Dict containing status[\"type\"]:      -\"queued\"   : Computation in queue.     -\"running\"  : Computation being processed.     -\"failed\"   : QPU service has returned an error message.     -\"succeeded\": Computation is completed, result is available.\n\nIn the case of status[\"type\"]==\"failed\", the server error is contained in status[\"message\"].\n\nExample\n\njulia> circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\njulia> get_status(client,circuitID)\nStatus: succeeded\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_result","page":"Library","title":"Snowflake.get_result","text":"get_result(client::Client,circuit::String)::Dict{String, Int}\n\nGet the histogram of a completed circuit calculation, through a Client of a QPU service,  by circuit identifier circuitID.\n\nExample\n\njulia> circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\njulia> get_status(client,circuitID);\n\njulia> get_result(client,circuitID)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.run_job","page":"Library","title":"Snowflake.run_job","text":"run_job(qpu::VirtualQPU, circuit::QuantumCircuit,shot_count::Integer)\n\nRun a circuit computation on a QPU simulator, repeatedly for the specified number of repetitions (shot_count). Returns the histogram of the completed circuit calculations.\n\nExample\n\njulia> qpu=VirtualQPU();\n\njulia> run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\nrun_job(qpu::AnyonYukonQPU, circuit::QuantumCircuit, shot_count::Integer)\n\nRun a circuit computation on a QPU service, repeatedly for the specified number of repetitions (shot_count).\n\nReturns the histogram of the completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=AnyonYukonQPU(client);\n\njulia> run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.transpile_and_run_job","page":"Library","title":"Snowflake.transpile_and_run_job","text":"transpile_and_run_job(qpu::VirtualQPU, circuit::QuantumCircuit,shot_count::Integer;transpiler::Transpiler=get_transpiler(qpu))\n\nThis method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a key-word argument. The transpiled circuit is then run on a QPU simulator, repeatedly for the specified number of repetitions (shot_count). Returns the histogram of the completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=VirtualQPU();\n\njulia> transpile_and_run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\ntranspile_and_run_job(qpu::AnyonYukonQPU, circuit::QuantumCircuit,shot_count::Integer;transpiler::Transpiler=get_transpiler(qpu))\n\nThis method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a key-word argument. The transpiled circuit is then run on the AnyonYukonQPU, repeatedly for the specified number of repetitions (shot_count).\n\nReturns the histogram of the completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=AnyonYukonQPU(client_anyon);\n\njulia> transpile_and_run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_transpiler","page":"Library","title":"Snowflake.get_transpiler","text":"get_transpiler(qpu::AnyonYukonQPU)::Transpiler\n\nReturns the transpiler associated with this QPU.\n\nExample\n\njulia> qpu=AnyonYukonQPU(client);\n\njulia> get_transpiler(qpu)\nSequentialTranspiler(Transpiler[CastToffoliToCXGateTranspiler(), CastCXToCZGateTranspiler(), CastISwapToCZGateTranspiler(), SwapQubitsForLineConnectivityTranspiler(), CastSwapToCZGateTranspiler(), CompressSingleQubitGatesTranspiler(), SimplifyTrivialGatesTranspiler(1.0e-6), CastUniversalToRzRxRzTranspiler(), SimplifyRxGatesTranspiler(1.0e-6), CastRxToRzAndHalfRotationXTranspiler(), CompressRzGatesTranspiler(), SimplifyRzGatesTranspiler(1.0e-6), UnsupportedGatesTranspiler()])\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.SequentialTranspiler","page":"Library","title":"Snowflake.SequentialTranspiler","text":"SequentialTranspiler(Vector{<:Transpiler})\n\nComposite transpiler object which is constructed from an array  of Transpilerstages. Callingtranspile(::SequentialTranspiler,::QuantumCircuit)will apply each stage in sequence to the input circuit, and return a transpiled output circuit. The result of the input and output  circuit on any arbitrary stateKet` is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=SequentialTranspiler([CompressSingleQubitGatesTranspiler(),CastToPhaseShiftAndHalfRotationXTranspiler()]);\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),hadamard(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────H──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────X_90────Z_90────X_m90────Z──\n                                                              \nq[2]:───────────────────────────────────\n                                                              \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y─────────Rz(1.0472)──\n\nq[2]:────────────*────────────────\n                 |                \nq[3]:────────────X────────────────\n                                  \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──Rz(-2.0944)───────\n                         \nq[2]:─────────────────*──\n                      |  \nq[3]:─────────────────X──\n                         \n\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Quantum-Toolkit","page":"Library","title":"Quantum Toolkit","text":"","category":"section"},{"location":"library.html#Basic-Quantum-Objects","page":"Library","title":"Basic Quantum Objects","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"There are three basic quantum objects in Snowflake to simulate a quantum system. These objects are Ket, Bra, and AbstractOperator.","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"Ket\nBra\nDiagonalOperator\nAntiDiagonalOperator\nDenseOperator\nSwapLikeOperator\nIdentityOperator\nSparseOperator\nBase.adjoint\nis_hermitian\nBase.exp(A::AbstractOperator)\nBase.getindex(A::AbstractOperator, m::Int64, n::Int64)\nexpected_value(A::AbstractOperator, psi::Ket)\nsparse\neigen\ntr\nkron\nMultiBodySystem\ncommute\nanticommute\nnormalize!\nget_measurement_probabilities(x::Ket{Complex{T}}) where T<:Real\nket2dm\nfock_dm\nwigner\nmoyal\ngenlaguerre\nget_embed_operator\nget_num_qubits(x::AbstractOperator)\nget_num_qubits(x::Union{Ket, Bra})\nget_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\nget_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\nfock\nspin_up\nspin_down\ncreate\ndestroy\nnumber_op\ncoherent\ncompare_kets","category":"page"},{"location":"library.html#Snowflake.Ket","page":"Library","title":"Snowflake.Ket","text":"A Ket represents a quantum wavefunction and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.  \n\nExamples\n\nAlthough NOT the preferred way, one can directly build a Ket object by passing a column vector as the initializer. \n\njulia> using Snowflake\n\njulia> ψ = Ket([1.0; 0.0; 0.0])\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\n\nA better way to initialize a Ket is to use a pre-built basis such as the fock basis. See fock for further information on this function. \n\njulia> ψ = fock(2, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.Bra","page":"Library","title":"Snowflake.Bra","text":"A structure representing a Bra (i.e. a row vector of complex values). A Bra is created as the complex conjugate of a Ket.\n\nExamples\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> _ψ = Bra(ψ)\n3-element Bra{ComplexF64}:\n0.0 - 0.0im\n1.0 - 0.0im\n0.0 - 0.0im\n\n\njulia> _ψ * ψ    # A Bra times a Ket is a scalar\n1.0 + 0.0im\n\njulia> ψ*_ψ     # A Ket times a Bra is an operator\n(3, 3)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.DiagonalOperator","page":"Library","title":"Snowflake.DiagonalOperator","text":"DiagonalOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a diagonal quantum Operator (i.e. a complex matrix of element type T, with non-zero elements all lying on the diagonal). The equivalent dense matrix would have size NxN.\n\nExamples\n\njulia> z = DiagonalOperator([1.0,-1.0])\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\njulia> z = DiagonalOperator([1.0+im,1.0,1.0,0.0-im])\n(4,4)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 1.0im    .    .    .\n.    1.0 + 0.0im    .    .\n.    .    1.0 + 0.0im    .\n.    .    .    0.0 - 1.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.AntiDiagonalOperator","page":"Library","title":"Snowflake.AntiDiagonalOperator","text":"AntiDiagonalOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a anti-diagonal quantum Operator (i.e. a complex matrix of element type T, with non-zero elements all lying on the cross-diagonal). The equivalent dense matrix would have size NxN.\n\nExamples\n\njulia> AntiDiagonalOperator([1,2])\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    2.0 + 0.0im    .\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.DenseOperator","page":"Library","title":"Snowflake.DenseOperator","text":"DenseOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a quantum operator with a full (dense) matrix representation of size NxN and containing elements of type T.\n\nExamples\n\njulia> z = DenseOperator([1.0 0.0;0.0 -1.0])\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    -1.0 + 0.0im\n\n\nAlternatively:\n\njulia> z = rotation(π/2,-π/4)  \n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.4999999999999999 - 0.5im\n-0.4999999999999999 - 0.5im    0.7071067811865476 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.SwapLikeOperator","page":"Library","title":"Snowflake.SwapLikeOperator","text":"SwapLikeOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a quantum operator performing a \"swap\" operation, with element type T. A phase value is applied to the swapped qubit coefficients. This operator is always of size 4x4.\n\nFor example, the iswap Operator can be built using a phase=0.0 + 1.0im by calling:\n\njulia> SwapLikeOperator(0.0 + 1.0im)\n(4, 4)-element Snowflake.SwapLikeOperator:\nUnderlying data ComplexF64:\nEquivalent DenseOperator:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.IdentityOperator","page":"Library","title":"Snowflake.IdentityOperator","text":"IdentityOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing the identity quantum operator, with element type T. This operator is always of size 2x2.\n\nExample\n\njulia> iden=IdentityOperator()\n(2, 2)-element Snowflake.IdentityOperator:\nUnderlying data ComplexF64:\nEquivalent DenseOperator:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.SparseOperator","page":"Library","title":"Snowflake.SparseOperator","text":"SparseOperator{N,T<:Complex}<:AbstractOperator\n\nA structure representing a quantum operator with a sparse (CSR) matrix representation, with element type T. The equivalent dense matrix would have size NxN.\n\nwarning: apply_operator() is not implemented for this operator type. Try using DenseOperator instead.\n\n\nExamples\n\njulia> z = SparseOperator([-1.0 1.0;0.0 -1.0])\n(2, 2)-element Snowflake.SparseOperator:\nUnderlying data ComplexF64:\n -1.0 + 0.0im   1.0 + 0.0im\n       ⋅       -1.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Base.adjoint","page":"Library","title":"Base.adjoint","text":"Base.adjoint(x)\n\nCompute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.is_hermitian","page":"Library","title":"Snowflake.is_hermitian","text":"is_hermitian(A::AbstractOperator)\n\nDetermine if Operator A is Hermitian (i.e. self-adjoint).\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> is_hermitian(Y)\ntrue\n\njulia> P = sigma_p()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    0.0 + 0.0im    .\n\n\njulia> is_hermitian(P)\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.exp-Tuple{AbstractOperator}","page":"Library","title":"Base.exp","text":"exp(A::AbstractOperator)\n\nCompute the matrix exponential of Operator A.\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> x_rotation_90_deg = exp(-im*π/4*X)\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865475 + 0.0im    0.0 - 0.7071067811865475im\n0.0 - 0.7071067811865475im    0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Base.getindex-Tuple{AbstractOperator, Int64, Int64}","page":"Library","title":"Base.getindex","text":"getindex(A::AbstractOperator, i::Integer, j::Integer)\n\nAccess the element at row i and column j in the matrix corresponding to Operator A.\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> Y[1,1]\n0.0 + 0.0im\n\njulia> Y[1,2]\n0.0 - 1.0im\n\njulia> Y[2,1]\n0.0 + 1.0im\n\njulia> Y[2,2]\n0.0 + 0.0im\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.expected_value-Tuple{AbstractOperator, Ket}","page":"Library","title":"Snowflake.expected_value","text":"expected_value(A::AbstractOperator, psi::Ket)\n\nCompute the expectation value ⟨ψ|A|ψ⟩ given Operator A and Ket |ψ⟩.\n\nExamples\n\njulia> ψ = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> A = sigma_z()\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\n\njulia> expected_value(A, ψ)\n-1.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"library.html#SparseArrays.sparse","page":"Library","title":"SparseArrays.sparse","text":"sparse(x::AbstractOperator)\n\nReturns a SparseOperator representation of x.\n\nExamples\n\n```jldoctest julia> z = sparse(sigma_z()) (2, 2)-element Snowflake.SparseOperator: Underlying data ComplexF64:  1.0 + 0.0im        ⋅            ⋅       -1.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.eigen","page":"Library","title":"LinearAlgebra.eigen","text":"eigen(A::AbstractOperator)\n\nCompute the eigenvalue decomposition of Operator A and return an Eigen factorization object F. Eigenvalues are found in F.values while eigenvectors are found in the matrix F.vectors. Each column of this matrix corresponds to an eigenvector. The ith eigenvector is extracted by calling F.vectors[:, i].\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> F = eigen(X);\n\njulia> eigenvalues = F.values\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> eigenvector_1 = F.vectors[:, 1]\n2-element Vector{ComplexF64}:\n -0.7071067811865475 + 0.0im\n  0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.tr","page":"Library","title":"LinearAlgebra.tr","text":"tr(A::AbstractOperator)\n\nCompute the trace of Operator A.\n\nExamples\n\njulia> I = eye()\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\n\njulia> trace = tr(I)\n2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.kron","page":"Library","title":"Base.kron","text":"kron(x, y)\n\nCompute the Kronecker product of two Kets or two  DenseOperator , DiagonalOperator, AntiDiagonalOperator. More details about the Kronecker product can be found here. \n\nExamples\n\njulia> ψ_0 = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> ψ_1 = Ket([1.0; 0.0])\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_0_1 = kron(ψ_0, ψ_1)\n4-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> kron(sigma_x(), sigma_y())\n(4, 4)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.MultiBodySystem","page":"Library","title":"Snowflake.MultiBodySystem","text":"A structure representing a quantum multi-body system.\n\nFields\n\nhilbert_space_structure – a vector of integers specifying the local Hilbert space size for each \"body\" within the multi-body system. \n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.commute","page":"Library","title":"Snowflake.commute","text":"commute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the commutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> σ_y = sigma_y()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> commute(σ_x,σ_y)\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n0.0 + 2.0im    .\n.    0.0 - 2.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.anticommute","page":"Library","title":"Snowflake.anticommute","text":"anticommute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the anticommutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> anticommute(σ_x,σ_x)\n(2,2)-element Snowflake.DiagonalOperator:\nUnderlying data type: ComplexF64:\n2.0 + 0.0im    .\n.    2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.normalize!","page":"Library","title":"LinearAlgebra.normalize!","text":"normalize!(x::Ket)\n\nNormalizes Ket x such that its magnitude becomes unity.\n\njulia> ψ=Ket([1.,2.,4.])\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n4.0 + 0.0im\n\njulia> normalize!(ψ)\n3-element Ket{ComplexF64}:\n0.2182178902359924 + 0.0im\n0.4364357804719848 + 0.0im\n0.8728715609439696 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T<:Real","page":"Library","title":"Snowflake.get_measurement_probabilities","text":"get_measurement_probabilities(x::Ket{Complex{T}},\n    [target_bodies::Vector{U},\n    hspace_size_per_body::Union{U,Vector{U}}=2])::AbstractVector{T}\n    where {T<:Real, U<:Integer}\n\nReturns a vector listing the measurement probabilities of the target_bodies of Ket x.\n\nThe Hilbert space size per body can be specified by providing a Vector of Integer for the hspace_size_per_body argument. The Vector must specify the Hilbert space size for each body. If the space size is uniform, a single Integer can be given instead. If only x is provided, the probabilities are provided for all the bodies.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit Ket, the probabilities are listed for 00, 01, 10, and 11.\n\nExamples\n\nThe following example constructs a Ket, where the probability of measuring 00 is 50% and the probability of measuring 10 is also 50%.\n\njulia> ψ = 1/sqrt(2)*Ket([1, 0, 1, 0])\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_measurement_probabilities(ψ)\n4-element Vector{Float64}:\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n 0.0\n\n\nFor the same Ket, the probability of measuring qubit 2 and finding 0 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(ψ, target_qubit)\n2-element Vector{Float64}:\n 0.9999999999999998\n 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.ket2dm","page":"Library","title":"Snowflake.ket2dm","text":"ket2dm(ψ::Ket)\n\nReturns the density matrix corresponding to the pure state ψ.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.fock_dm","page":"Library","title":"Snowflake.fock_dm","text":"fock_dm(i::Int64, hspace_size::Int64)\n\nReturns the density matrix corresponding to the Fock base i defined in a Hilbert space of size hspace_size.\n\njulia> dm=fock_dm(0,2)\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.wigner","page":"Library","title":"Snowflake.wigner","text":"wigner(ρ::AbstractOperator, p::Real, q::Real)\n\nComputes the Wigner function of the density matrix ρ at the point (p,q).\n\njulia> using Printf\n\njulia> alpha = 0.25;\n\njulia> hspace_size = 8;\n\njulia> Ψ = coherent(alpha, hspace_size);\n\njulia> prob = wigner(ket2dm(Ψ), 0, 0);\n\njulia> @printf \"prob: %.6f\" prob\nprob: -0.561815\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.moyal","page":"Library","title":"Snowflake.moyal","text":"moyal(m, n)\n\nReturns the Moyal function w_mn(eta) for Fock states m and n.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.genlaguerre","page":"Library","title":"Snowflake.genlaguerre","text":"genlaguerre(x, alpha, n)\n\nReturns the generalized Laguerre polynomial of degree n for x using a recursive method. See https://en.wikipedia.org/wiki/Laguerre_polynomials.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_embed_operator","page":"Library","title":"Snowflake.get_embed_operator","text":"get_embed_operator(op::DenseOperator, target_body_index::Int, system::MultiBodySystem)\n\nUses a local operator (op), which is defined for a particular body (e.g. qubit) with index target_body_index, to build the corresponding operator for the Hilbert space of the multi-body system given by system. \n\nExamples\n\njulia> system = MultiBodySystem(3,2)\nSnowflake.Multibody system with 3 bodies\n   Hilbert space structure:\n   [2, 2, 2]\n\njulia> x = sigma_x()\n(2,2)-element Snowflake.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> X_1=get_embed_operator(x,1,system)\n(8, 8)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_qubits-Tuple{AbstractOperator}","page":"Library","title":"Snowflake.get_num_qubits","text":"get_num_qubits(x::AbstractOperator)\n\nReturns the number of qubits associated with an Operator.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0.\n                     0. 0.])\n(2, 2)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_qubits(ρ)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_qubits-Tuple{Union{Bra, Ket}}","page":"Library","title":"Snowflake.get_num_qubits","text":"get_num_qubits(x::Union{Ket, Bra})\n\nReturns the number of qubits associated with a Ket or a Bra.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_qubits(ψ)\n2\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_bodies","page":"Library","title":"Snowflake.get_num_bodies","text":"get_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with an Operator given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0. 0.\n                     0. 0. 0.\n                     0. 0. 0.])\n(3, 3)-element Snowflake.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_bodies(ρ, 3)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_bodies-2","page":"Library","title":"Snowflake.get_num_bodies","text":"get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with a Ket or a Bra given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0., 0., 0., 0., 0., 0.])\n9-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_bodies(ψ, 3)\n2\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.fock","page":"Library","title":"Snowflake.fock","text":"fock(i, hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the ith Fock basis of a Hilbert space with size hspace_size as a Ket.\n\nThe Ket contains values of type T, which by default is ComplexF64.\n\nExamples\n\njulia> ψ = fock(0, 3)\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3,ComplexF32) # specifying a type other than ComplexF64\n3-element Ket{ComplexF32}:\n0.0f0 + 0.0f0im\n1.0f0 + 0.0f0im\n0.0f0 + 0.0f0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.spin_up","page":"Library","title":"Snowflake.spin_up","text":"spin_up(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-up state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_up()\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.spin_down","page":"Library","title":"Snowflake.spin_down","text":"spin_down(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-down state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_down()\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.create","page":"Library","title":"Snowflake.create","text":"create(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic creation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.destroy","page":"Library","title":"Snowflake.destroy","text":"destroy(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic annhilation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.number_op","page":"Library","title":"Snowflake.number_op","text":"number_op(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the number operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.coherent","page":"Library","title":"Snowflake.coherent","text":"coherent(alpha, hspace_size)\n\nReturns a coherent state for the parameter alpha in a Fock space of size hspace_size. Note that |alpha|^2 is equal to the photon number of the coherent state. \n\n# Examples\n\njulia> ψ = coherent(2.0,20)\n20-element Ket{ComplexF64}:\n0.1353352832366127 + 0.0im\n0.2706705664732254 + 0.0im\n0.3827859860416437 + 0.0im\n0.44200318416631873 + 0.0im\n0.44200318416631873 + 0.0im\n0.3953396664268989 + 0.0im\n0.3227934859426707 + 0.0im\n0.24400893961026582 + 0.0im\n0.17254037586855772 + 0.0im\n0.11502691724570517 + 0.0im\n0.07274941014482605 + 0.0im\n0.043869544940011405 + 0.0im\n0.025328093580341972 + 0.0im\n0.014049498479026656 + 0.0im\n0.007509772823502764 + 0.0im\n0.003878030010563634 + 0.0im\n0.001939015005281817 + 0.0im\n0.000940560432521708 + 0.0im\n0.0004433844399679012 + 0.0im\n0.00020343873336404819 + 0.0im\n\n\njulia> expected_value(number_op(20),ψ)\n3.99999979364864 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.compare_kets","page":"Library","title":"Snowflake.compare_kets","text":"compare_kets(ψ_0::Ket,ψ_1::Ket)\n\nChecks for equivalence allowing for a global phase difference between two input kets.\n\nExamples\n\njulia> ψ_0 = Ket([1.,2.,3.,4.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n3.0 + 0.0im\n4.0 + 0.0im\n\n\njulia> δ=π/3 # phase offset\n1.0471975511965976\n\njulia> ψ_1 = exp(im*δ)*ψ_0\n4-element Ket{ComplexF64}:\n0.5000000000000001 + 0.8660254037844386im\n1.0000000000000002 + 1.7320508075688772im\n1.5000000000000004 + 2.598076211353316im\n2.0000000000000004 + 3.4641016151377544im\n\n\njulia> compare_kets(ψ_0,ψ_1)\ntrue\n\njulia> apply_gate!(ψ_1,sigma_x(1))\n\njulia> compare_kets(ψ_0,ψ_1) # no longer equivalent after SigmaX gate\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Visualization","page":"Library","title":"Visualization","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"The SnowflakePlots package provides multiple visualization tools for Snowflake.jl. Please see the documentation of SnowflakePlots for more details. ","category":"page"},{"location":"library.html#Pauli-Simulator","page":"Library","title":"Pauli Simulator","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"Snowflake provides tools for the efficient storage and manipulation of Pauli group elements.","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"Snowflake.PauliGroupElement\nget_pauli\nBase.:*(p1::Snowflake.PauliGroupElement, p2::Snowflake.PauliGroupElement)\nget_quantum_circuit\nget_negative_exponent\nget_imaginary_exponent","category":"page"},{"location":"library.html#Snowflake.PauliGroupElement","page":"Library","title":"Snowflake.PauliGroupElement","text":"PauliGroupElement\n\nA Pauli group element which is represented using the approach of Dehaene and De Moor (2003).\n\nThe get_pauli functions should be used to generate PauliGroupElement objects.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.get_pauli","page":"Library","title":"Snowflake.get_pauli","text":"get_pauli(circuit::QuantumCircuit; imaginary_exponent::Integer=0,\n    negative_exponent::Integer=0)::PauliGroupElement\n\nReturns a PauliGroupElement given a circuit containing Pauli gates.\n\nA Pauli group element corresponds to i^delta (-1)^epsilon sigma_a, where delta and epsilon are set by specifying imaginary_exponent and negative_exponent, respectively. The exponents must be 0 or 1. Their default value is 0. As for sigma_a, it is a tensor product of Pauli operators. The Pauli operators are specified in the circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, sigma_x(1), sigma_y(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\njulia> get_pauli(circuit, imaginary_exponent=1, negative_exponent=1)\nPauli Group Element:\n-1.0im*X(1)*Y(2)\n\n\n\n\nIf multiple Pauli gates are applied to the same qubit in the circuit, the gates are multiplied with the first gate in the circuit being the rightmost gate in the multiplication.\n\njulia> circuit = QuantumCircuit(qubit_count=1);\n\njulia> push!(circuit, sigma_x(1), sigma_z(1))\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Z──\n               \n\n\n\njulia> get_pauli(circuit)\nPauli Group Element:\n1.0im*Y(1)\n\n\n\n\n\n\n\n\nget_pauli(gate::AbstractGate, num_qubits::Integer; imaginary_exponent::Integer=0,\n    negative_exponent::Integer=0)::PauliGroupElement\n\nReturns a PauliGroupElement given a gate and the number of qubits.\n\nA Pauli group element corresponds to i^delta (-1)^epsilon sigma_a, where delta and epsilon are set by specifying imaginary_exponent and negative_exponent, respectively. The exponents must be 0 or 1. Their default value is 0. As for sigma_a, it is a tensor product of Pauli operators. In this variant of the get_pauli function, a single Pauli operator is set by providing a gate. The number of qubits is specified by num_qubits.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> get_pauli(gate, num_qubits)\nPauli Group Element:\n1.0*X(2)\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.:*-Tuple{Snowflake.PauliGroupElement, Snowflake.PauliGroupElement}","page":"Library","title":"Base.:*","text":"Base.:*(p1::PauliGroupElement, p2::PauliGroupElement)::PauliGroupElement\n\nReturns the product of two PauliGroupElement objects.\n\nThe PauliGroupElement objects must be associated with the same number of qubits.\n\nExamples\n\njulia> pauli_z = get_pauli(sigma_z(1), 1)\nPauli Group Element:\n1.0*Z(1)\n\n\n\njulia> pauli_y = get_pauli(sigma_y(1), 1)\nPauli Group Element:\n1.0*Y(1)\n\n\n\njulia> pauli_z*pauli_y\nPauli Group Element:\n-1.0im*X(1)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_quantum_circuit","page":"Library","title":"Snowflake.get_quantum_circuit","text":"get_quantum_circuit(pauli::PauliGroupElement)::QuantumCircuit\n\nReturns the Pauli gates of a PauliGroupElement as a QuantumCircuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, sigma_x(1), sigma_y(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\njulia> pauli = get_pauli(circuit, imaginary_exponent=1, negative_exponent=1)\nPauli Group Element:\n-1.0im*X(1)*Y(2)\n\n\n\njulia> get_quantum_circuit(pauli)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_negative_exponent","page":"Library","title":"Snowflake.get_negative_exponent","text":"get_negative_exponent(pauli::PauliGroupElement)::Int\n\nReturns the negative exponent of a PauliGroupElement.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> pauli = get_pauli(gate, num_qubits, negative_exponent=1)\nPauli Group Element:\n-1.0*X(2)\n\n\n\njulia> get_negative_exponent(pauli)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_imaginary_exponent","page":"Library","title":"Snowflake.get_imaginary_exponent","text":"get_imaginary_exponent(pauli::PauliGroupElement)::Int\n\nReturns the imaginary exponent of a PauliGroupElement.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> pauli = get_pauli(gate, num_qubits, imaginary_exponent=1)\nPauli Group Element:\n1.0im*X(2)\n\n\n\njulia> get_imaginary_exponent(pauli)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html","page":"Library","title":"Library","text":"DocTestSetup = nothing","category":"page"},{"location":"development.html#Snowflake-development","page":"Developing","title":"Snowflake development","text":"","category":"section"},{"location":"development.html#Installing-Snowflake-for-local-development","page":"Developing","title":"Installing Snowflake for local development","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"When developing Snowflake, you must ensure that you are using a local copy of Snowflake, not the latest released version. The easiest way to achieve that is to set the project to the local directory.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If you are starting a new instance of Julia, then you can activate the Snowflake project with","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Or, if you are inside a script or REPL, you can use","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If the current directory is not the Snowflake project, replace . with the Snowflake project path.","category":"page"},{"location":"development.html#Running-tests","page":"Developing","title":"Running tests","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"First open a julia REPL in the current project","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"and run the tests","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.test()","category":"page"},{"location":"development.html#Build-the-documentation","page":"Developing","title":"Build the documentation","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"First open a julia REPL using the docs project","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=./docs","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If it is the first time building the docs, you need to instantiate the Julia project and add the Snowflake project as a development dependency. This means the version of the Snowflake package loaded is the one at the path specified, pwd(), and not the one registered at JuliaHub.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.develop(PackageSpec(path=pwd()))\nPkg.instantiate()","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"At which point, the project status should be similar to the one below. The versions might be slightly different, but what is important is that the Status line refers to the docs/Project.toml and that Snowflake refers to <pwd()>/Snowflake.jl.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Pkg.status()\n\n# output\n      Status `<pwd()>/Snowflake.jl/docs/Project.toml`\n  [e30172f5] Documenter v0.27.24\n  [cd3eb016] HTTP v1.7.4\n  [682c06a0] JSON v0.21.4\n  [7bd9edc1] Snowflake v0.1.0 `<pwd()>/Snowflake.jl`\n  [90137ffa] StaticArrays v1.5.21\n  [2913bbd2] StatsBase v0.33.21\n  [de0858da] Printf","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Then you can run","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"include(\"./docs/make.jl\")","category":"page"},{"location":"development.html#Run-coverage-locally","page":"Developing","title":"Run coverage locally","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"If you haven't already, instantiate the project with Julia's package manager.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=. -e 'using Pkg; Pkg.Instantiate()'","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":".","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"You can run coverage locally from the project directory using","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=. coverage.jl","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"The script returns the covered and total line as output. An example output is shown below","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Covered lines: 1373\nTotal lines: 1383\nCoverage percentage: 0.9927693420101229","category":"page"},{"location":"tutorials/basics.html#Basic-Concepts","page":"Basics","title":"Basic Concepts","text":"","category":"section"},{"location":"tutorials/basics.html#Quantum-Circuits","page":"Basics","title":"Quantum Circuits","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In quantum computing, a quantum circuit represents a sequence of operations that are intended to be applied to qubits.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's start by an example. We are going to start by importing Snowflake.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"using Snowflake","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can then create an empty quantum circuit by specifying the number of qubits the circuit will involve:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"c=QuantumCircuit(qubit_count=2)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"You can visualize a QuantumCircuit object at any point by simply printing it:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"print(c)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We have not yet added any quantum operation to our circuit and it looks empty! So, let's add some quantum operations!","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"note: Note\nIn Snowflake, we assume all qubits are initialized to be in state 0 (ground state). ","category":"page"},{"location":"tutorials/basics.html#Quantum-Gates","page":"Basics","title":"Quantum Gates","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Basic logical operations on qubits are commonly called quantum logic gates or simply gates. We will quite often talk about single-qubit gates, two-qubit gates or multiple-qubit gates in quantum information theory.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's start by adding a single-qubit gate called the Hadamard gate to our circuit, c, and specify that it will only operate on qubit '1'. The Hadamard gate is one of the most frequently used gates in quantum computing as it puts its target qubit into a perfect superposition of state 0 and 1. ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can add this gate by calling the push! function:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"push!(c,hadamard(1))","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"note: Note\nUnlike C++ or Python, indexing in Julia starts from \"1\" and not \"0\"!","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Note the exclamation mark at the end of push! which emphasizes the fact that we have called a mutating function that will change the argument c (our quantum circuit). ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"If we now print circuit c, we will see the following output","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"print(c)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Now let's add a famous two-qubit gate, control_x, also known as the CNOT gate in the quantum information community: ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"push!(c,control_x(1,2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Voila! You just made your first quantum circuit with Snowflake that does something interesting:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"It puts a two-qubit register in a maximally-entangled quantum state (fracleft00rightrangle+left11rightranglesqrt2). This state is one of the four celebrated Bell State or the EPR states. These states do not have classical counterparts and are are among the building blocks of many interesting ideas in quantum computing and quantum communication.","category":"page"},{"location":"tutorials/basics.html#Circuit-Simulation","page":"Basics","title":"Circuit Simulation","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"You can verify what your circuit will ideally do on a real computer by simulating the circuit on your own local machine:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"simulate(c)\n# output\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"The output of simulate function is a Ket object. Ket is a complex vector that represents the wavefunction of a quantum object such as our two-qubit system. ","category":"page"},{"location":"tutorials/basics.html#Histogram","page":"Basics","title":"Histogram","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In the previous section, we used the simulate function to calculate the wavefunction of a two-qubit quantum register, after the circuit, c, is applied to it. However, in the real world, we do not have direct access to the wavefunction of a quantum register. Rather, we need to run the quantum circuit many many times (shots) on the quantum processor and measure the qubits states at the end of each shot. The result of each shot is a bitstring that tells us which qubits were measured to be in state 0 and which qubits were measured to be in state 1. The probability of getting a bitstring then depends on the wavefunction. ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can indeed mimick this behaviour in our simulations as well. This can be achieved by using the plot_histogram function from the SnowflakePlots library. For example, we can generate a histogram which shows the measurement output distribution after taking running the circuit c for a given number of shots, let's say 100 times, on a quantum computer simulator:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"using SnowflakePlots\nplot_histogram(c, 100)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"(Image: Measurement results histogram)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In the next tutorial, we will discuss how to run the above circuit on a real quantum processor. ","category":"page"},{"location":"tutorials/run_circuit_anyon.html#Running-a-Circuit-on-a-Real-Hardware","page":"Real hardware","title":"Running a Circuit on a Real Hardware","text":"","category":"section"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"using Snowflake\n\nDocTestSetup = quote\n    ENV[\"ANYON_QUANTUM_USER\"] = \"test-user\"\n    ENV[\"ANYON_QUANTUM_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"ANYON_QUANTUM_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"In the previous tutorial, we learnt how to run a quantum circuit on a virtual QPU. We also learnt that every QPU driver should adhere to the AbstractQPU.","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"In this tutorial, we will learn how to submit a job to a real hardware. At the moment, we have only implemented the driver for Anyon's quantum processors but we welcome contributions from other members of the community, as well as other hardware vendors to use Snowflake with a variety of machines. ","category":"page"},{"location":"tutorials/run_circuit_anyon.html#Anyon-QPU","page":"Real hardware","title":"Anyon QPU","text":"","category":"section"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"The current release of Snowflake supports Anyon's Yukon quantum processor which is made from an array of 6 tunable superconducting transmon qubits interleaved with 5 tunable couplers. ","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"We can start by defining a qpu variable to point to the host computer that will queue jobs on the quantum processor and provide it with user credentials:","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"using Snowflake\n\nqpu=AnyonYukonQPU(host=\"yukon.anyonsys.com\",user=\"USER_NAME\", access_token=\"API_KEY\")","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"warning: Warning\nIf you plan to make your code public or work in a shared envrinoment, it is best to use environment variables to set the user credentials rather than hardcoding them!","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"We can now print the qpu object to print further information about the hardware:","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"println(qpu)\n\n# output\n\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   qubit_count:   6\n   connectivity_type:  linear","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"Alternatively, one can use the get_metadata function to obtain a Dict object corresponding to the QPU information:","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"get_metadata(qpu)\n\n# output\n\nDict{String, Union{Int64, String}} with 5 entries:\n  \"qubit_count\"       => 6\n  \"generation\"        => \"Yukon\"\n  \"manufacturer\"      => \"Anyon Systems Inc.\"\n  \"serial_number\"     => \"ANYK202201\"\n  \"connectivity_type\" => \"linear\"","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"We now continue to build a small circuit to create a Bell state as was presented in the previous tutorials:","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"c=QuantumCircuit(qubit_count=2)\npush!(c,hadamard(1),control_x(1,2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──","category":"page"},{"location":"tutorials/run_circuit_anyon.html#Circuit-Transpilation","page":"Real hardware","title":"Circuit Transpilation","text":"","category":"section"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"The circuit above cannot be directly executed on the quantum processor. This is because the quantum processor only implements a set of native gates. This means that any arbitrary gate should first be transpiled into a set of native gates that can run on the QPU. ","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"If you examine the src/anyon/qpu_interface.jl file, you notice that Anyon Yukon Processor implements the following set of native gates:","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":" set_of_native_gates=[\n        PhaseShift,\n        Pi8,\n        Pi8Dagger,\n        SigmaX,\n        SigmaY,\n        SigmaZ,\n        X90,\n        XM90,\n        Y90,\n        YM90,\n        Z90,\n        ZM90,\n        ControlZ,\n    ]","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"Snowflake is designed to allow users to design and use their own transpilers for different QPUs. Alternatively, a use may opt out to use the default transpilers that are implemented for each QPU driver. ","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"Let's see how can we transpile the above circuit, c, to a circuit that can run on Anyon's QPU. We first define a transpiler object that refers to the default transpiler for AnyonYukonQPU which shipped with Snowflake:","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"transpiler=get_transpiler(qpu)","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"Next, let's transpile the original circuit:","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"c_transpiled=transpile(transpiler,c)\n\n# output\n\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90────────────X_90────Z_90────────────────────*──────────────────────────\n                                                       |                          \nq[2]:──────────Z_90────────────────────X_90────Z_90────Z────Z_90────X_90────Z_90──","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"The final circuit c_final is now ready to be submitted to the QPU:","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"shot_count = 200\nresult = run_job(qpu, c_transpiled, shot_count)\nprintln(result)","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"which should print something like:","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"Dict(\"11\" => 97, \"00\" => 83, \"01\" => 11, \"10\" => 9)","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"The results show that the samples are mostly sampled between state left00rightrangle and left11rightrangle. We do see some finite population in left01rightrangle and left10rightrangle that are due to the error in the computation.","category":"page"},{"location":"tutorials/run_circuit_anyon.html","page":"Real hardware","title":"Real hardware","text":"note: Note\nThe user can skip the explicit transpiling step by using the transpile_and_run function. This function will use the default transpiler of the QPU and then submit the job to the machine. ","category":"page"},{"location":"tutorials/run_circuit_virtual.html#Run-a-circuit-on-a-Virtual-QPU","page":"Virtual QPU","title":"Run a circuit on a Virtual QPU","text":"","category":"section"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"In the previous tutorial, we introduced some basic concepts of quantum computing, namely the quantum circuit and quantum gates. ","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"We also learnt how to build a quantum circuit using Snowflake and simulate the result of such circuit using our local machine. ","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"In this tutorial, we will the steps involved in running a quantum circuit on a both a virtual and also a real Quantum Processing Unit (QPU). ","category":"page"},{"location":"tutorials/run_circuit_virtual.html#QPU-Object","page":"Virtual QPU","title":"QPU Object","text":"","category":"section"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"Interactions with different QPUs are facilitated using structs (objects) that represent QPU hardware.  These structures are used to implement a harmonized interface, and are derived from an abstract type called AbstractQPU. This interface gives you a unified way to write code that is agnostic of the quantum service you are using. The interface dictates how to get metadata about the QPU, how to run a quantum circuit on the QPU, and more. ","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"warning: Warning\nYou should not use AbstractQPU, rather use a QPU object which is derived from AbstractQPU. For further details on the implemented derived QPUs, see the Library page. ","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"Now that you know what QPU objects are, let's get started by importing Snowflake:","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"using Snowflake","category":"page"},{"location":"tutorials/run_circuit_virtual.html#Virtual-QPU","page":"Virtual QPU","title":"Virtual QPU","text":"","category":"section"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"Next, we are going to create a virtual QPU which will run on our local machine:","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"qpu_v=VirtualQPU()","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"We can print QPU's meta data by simply using","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"print(qpu_v)\n# output\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Snowflake.jl\n","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"or alternatively, retrieve the QPU metadata in a Dict{String,String} format through the following command:","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"get_metadata(qpu_v)\n# output\nDict{String, String} with 2 entries:\n  \"developers\" => \"Anyon Systems Inc.\"\n  \"package\"    => \"Snowflake.jl\"\n\n","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"Now, let's create a circuit to create a Bell pair as was explained in the previous tutorial:","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"c=QuantumCircuit(qubit_count=2)\npush!(c,hadamard(1),control_x(1,2))","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"We can then run this circuit on the virtual qpu for let's say 101 shots. ","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"shots_count=100\nresult=run_job(qpu_v,c,shots_count)","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"The result object is a Dict{String, Int64} that summarizes how many times each state was measured in the shots run on the QPU:","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"print(result)\n\nDict(\"00\" => 53, \"11\" => 47)","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"note: Note\nThe reason the number of measured values for states 00 and 11 are not necessarily equal is due to the fact that VirtualQPU tries to mimick the statistical nature of a real hardware. By increasing the shots_count the experiment will can confirm that the probability of 00 and 11 are equal. ","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"The virtual QPU currently mimicks an ideal hardware with no error. In future versions, we expect to add noise models and also models for other sources of error such as crosstalk, thermal noise, etc. ","category":"page"},{"location":"tutorials/run_circuit_virtual.html","page":"Virtual QPU","title":"Virtual QPU","text":"In the next tutorial, we will show how to submit a job to a real quantum processing hardware. ","category":"page"},{"location":"index.html#Snowflake.jl","page":"Home","title":"Snowflake.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A library for quantum computing using Julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Snowflake is a pure Julia quantum computing stack that allows you to easily design quantum circuits, experiments and algorithms. Snowflake can run these quantum applications on real quantum computers or classical simulators.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nSnowflake has yet to reach version 1.0, but we intend to keep compatibility with what is documented here. We will only make a breaking change if something is broken. After version 1.0, the public API will be stable and only change with major releases.","category":"page"}]
}
