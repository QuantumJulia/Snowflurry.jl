var documenterSearchIndex = {"docs":
[{"location":"library.html#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"library.html#Quantum-Circuit","page":"Library","title":"Quantum Circuit","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"QuantumCircuit\npush_gate!\npop_gate!\nsimulate\nsimulate_shots","category":"page"},{"location":"library.html#Snowflake.QuantumCircuit","page":"Library","title":"Snowflake.QuantumCircuit","text":"    QuantumCircuit(qubit_count = .., bit_count = ...)\n\nA data structure to represent a quantum circuit.  \n\nFields\n\nqubit_count::Int – number of qubits (i.e. quantum register size).\nbit_count::Int – number of classical bits (i.e. classical register size).\nid::UUID – a universally unique identifier for the circuit. A UUID is automatically generated once an instance is created. \npipeline::Array{Array{Gate}} – the pipeline of gates to operate on qubits.\n\nExamples\n\njulia> c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0)\nQuantum Circuit Object:\n   id: b2d2be56-7af2-11ec-31a6-ed9e71cb3360 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:\n     \nq[2]:\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.push_gate!","page":"Library","title":"Snowflake.push_gate!","text":"    push_gate!(circuit::QuantumCircuit, gate::Gate)\n    push_gate!(circuit::QuantumCircuit, gates::Array{Gate})\n\nPushes a single gate or an array of gates to the circuit pipeline. This function is mutable. \n\nExamples\n\njulia> c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);\n\njulia> push_gate!(c, [hadamard(1),sigma_x(2)])\nQuantum Circuit Object:\n   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H──\n          \nq[2]:──X──\n          \n\n\njulia> push_gate!(c, control_x(1,2))\nQuantum Circuit Object:\n   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H────*──\n            |  \nq[2]:──X────X──\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.pop_gate!","page":"Library","title":"Snowflake.pop_gate!","text":"    pop_gate!(circuit::QuantumCircuit)\n\nRemoves the last gate from circuit.pipeline. \n\nExamples\n\njulia> c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);\n\njulia> push_gate!(c, [hadamard(1),sigma_x(2)])\nQuantum Circuit Object:\n   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H──\n          \nq[2]:──X──\n          \n\n\njulia> push_gate!(c, control_x(1,2))\nQuantum Circuit Object:\n   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H────*──\n            |  \nq[2]:──X────X──\n\njulia> pop_gate!(c)\nQuantum Circuit Object:\n   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H──\n          \nq[2]:──X──\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.simulate","page":"Library","title":"Snowflake.simulate","text":"    simulate(circuit::QuantumCircuit)\n\nSimulates and returns the wavefunction of the quantum device after running circuit. \n\nEmploys the approach described in Listing 5 of Suzuki et. al. (2021).\n\nExamples\n\njulia> c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);\n\njulia> push_gate!(c, hadamard(1))\nQuantum Circuit Object:\n   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push_gate!(c, control_x(1,2))\nQuantum Circuit Object:\n   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> ket = simulate(c);\n\njulia> print(ket)\n4-element Ket:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.simulate_shots","page":"Library","title":"Snowflake.simulate_shots","text":"    simulate_shots(c::QuantumCircuit, shots_count::Int = 100)\n\nEmulates a quantum computer by running a circuit for a given number of shots and returning measurement results.\n\nExamples\n\njulia> c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);\n\njulia> push_gate!(c, hadamard(1))\nQuantum Circuit Object:\n   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push_gate!(c, control_x(1,2))\nQuantum Circuit Object:\n   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> simulate_shots(c, 99)\n99-element Vector{String}:\n \"11\"\n \"00\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"00\"\n \"00\"\n \"11\"\n ⋮\n \"00\"\n \"00\"\n \"11\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n\n\n\n\n\n","category":"function"},{"location":"library.html#Quantum-Gates","page":"Library","title":"Quantum Gates","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"Gate\neye\nsigma_p\nsigma_m\nsigma_x\nsigma_y\nsigma_z\nhadamard\nphase\npi_8\nx_90\nrotation\nrotation_x\nrotation_y\nrotation_z\nphase_shift\nuniversal\ncontrol_z\ncontrol_x\niswap\nBase.:*(M::Gate, x::Ket)\napply_gate!","category":"page"},{"location":"library.html#Snowflake.Gate","page":"Library","title":"Snowflake.Gate","text":"Gate(display_symbol, instruction_symbol, operator, target::Array, parameters=[])\nGate(display_symbol, instruction_symbol, operator, target::Int, parameters=[])\n\nConstructs a Gate that can be added to a QuantumCircuit in order to apply an operator to one or more target qubits.\n\nEach Gate has a display_symbol which determines how the Gate is displayed in a QuantumCircuit. The instruction_symbol is used by the quantum compiler to identify the Gate. Optionally, a Gate can contain parameters.\n\nExamples\n\njulia> pi_x_rotation_on_qubit_1 = Gate([\"Rx(π)\"], \"rx\", Operator([0.0 -im; -im 0.0]), 1, [π])\nGate Object:\ninstruction symbol: rx\nparameters: [π]\ntargets: [1]\noperator:\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n0.0 + 0.0im    0.0 - 1.0im\n0.0 - 1.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.eye","page":"Library","title":"Snowflake.eye","text":"eye()\n\nReturn the identity Operator, which is defined as:\n\nI = beginbmatrix\n    1  0 \n    0  1\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_p","page":"Library","title":"Snowflake.sigma_p","text":"sigma_p()\n\nReturn the spin-frac12 raising Operator, which is defined as:\n\nsigma_+ = beginbmatrix\n    0  1 \n    0  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_m","page":"Library","title":"Snowflake.sigma_m","text":"sigma_m()\n\nReturn the spin-frac12 lowering Operator, which is defined as:\n\nsigma_- = beginbmatrix\n    0  0 \n    1  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_x","page":"Library","title":"Snowflake.sigma_x","text":"sigma_x()\n\nReturn the Pauli-X Operator, which is defined as:\n\nsigma_x = beginbmatrix\n    0  1 \n    1  0\n    endbmatrix\n\n\n\n\n\nsigma_x(target)\n\nReturn the Pauli-X Gate, which applies the sigma_x() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_y","page":"Library","title":"Snowflake.sigma_y","text":"sigma_y()\n\nReturn the Pauli-Y Operator, which is defined as:\n\nsigma_y = beginbmatrix\n    0  -i \n    i  0\n    endbmatrix\n\n\n\n\n\nsigma_y(target)\n\nReturn the Pauli-Y Gate, which applies the sigma_y() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sigma_z","page":"Library","title":"Snowflake.sigma_z","text":"sigma_z()\n\nReturn the Pauli-Z Operator, which is defined as:\n\nsigma_z = beginbmatrix\n    1  0 \n    0  -1\n    endbmatrix\n\n\n\n\n\nsigma_z(target)\n\nReturn the Pauli-Z Gate, which applies the sigma_z() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.hadamard","page":"Library","title":"Snowflake.hadamard","text":"hadamard()\n\nReturn the Hadamard Operator, which is defined as:\n\nH = frac1sqrt2beginbmatrix\n    1  1 \n    1  -1\n    endbmatrix\n\n\n\n\n\nhadamard(target)\n\nReturn the Hadamard Gate, which applies the hadamard() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.phase","page":"Library","title":"Snowflake.phase","text":"phase()\n\nReturn the phase gate Operator, which is defined as:\n\nS = beginbmatrix\n    1  0 \n    0  i\n    endbmatrix\n\n\n\n\n\nphase(target)\n\nReturn a phase Gate (also known as an S Gate), which applies the phase() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.pi_8","page":"Library","title":"Snowflake.pi_8","text":"pi_8()\n\nReturn the Operator for the π/8 gate, which is defined as:\n\nT = beginbmatrix\n    1  0 \n    0  e^ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8(target)\n\nReturn a π/8 Gate (also known as a T Gate), which applies the pi_8() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.x_90","page":"Library","title":"Snowflake.x_90","text":"x_90()\n\nReturn the Operator which applies a π/2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -i \n    -i  1\n    endbmatrix\n\n\n\n\n\nx_90(target)\n\nReturn a Gate that applies a 90° rotation about the X axis as defined by the x_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation","page":"Library","title":"Snowflake.rotation","text":"rotation(theta, phi)\n\nReturn the Operator which applies a rotation theta about the cos(phi)X+sin(phi)Y axis.\n\nThe Operator is defined as:\n\nR(theta phi) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -i e^-iphi mathrmsinleft(fractheta2right) 05em      \n    -i e^iphi mathrmsinleft(fractheta2right) \n        mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation(target, theta, phi)\n\nReturn a gate that applies a rotation theta to the target qubit about the cos(phi)X+sin(phi)Y axis.\n\nThe corresponding Operator is rotation(theta, phi).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation_x","page":"Library","title":"Snowflake.rotation_x","text":"rotation_x(theta)\n\nReturn the Operator which applies a rotation theta about the X axis.\n\nThe Operator is defined as:\n\nR_x(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -imathrmsinleft(fractheta2right) 05em      \n-imathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_x(target, theta)\n\nReturn a Gate that applies a rotation theta about the X axis of the target qubit.\n\nThe corresponding Operator is rotation_x(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation_y","page":"Library","title":"Snowflake.rotation_y","text":"rotation_y(theta)\n\nReturn the Operator that applies a rotation theta about the Y axis of the target qubit.\n\nThe Operator is defined as:\n\nR_y(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -mathrmsinleft(fractheta2right) 05em      \nmathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_y(target, theta)\n\nReturn a Gate that applies a rotation theta about the Y axis of the target qubit.\n\nThe corresponding Operator is rotation_y(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.rotation_z","page":"Library","title":"Snowflake.rotation_z","text":"rotation_z(theta)\n\nReturn the Operator that applies a rotation theta about the Z axis.\n\nThe Operator is defined as:\n\nR_z(theta) = beginbmatrix\nmathrmexpleft(-ifractheta2right)  0 05em      \n0  mathrmexpleft(ifractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_z(target, theta)\n\nReturn a Gate that applies a rotation theta about the Z axis of the target qubit.\n\nThe corresponding Operator is rotation_z(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.phase_shift","page":"Library","title":"Snowflake.phase_shift","text":"phase_shift(phi)\n\nReturn the Operator that applies a phase shift phi.\n\nThe Operator is defined as:\n\nP(phi) = beginbmatrix\n    i  0 05em      \n    0  e^iphi\nendbmatrix\n\n\n\n\n\nphase_shift(target, phi)\n\nReturn a Gate that applies a phase shift phi to the target qubit as defined by the phase_shift(phi) Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.universal","page":"Library","title":"Snowflake.universal","text":"universal(theta, phi, lambda)\n\nReturn the Operator which performs a rotation about the angles theta, phi, and lambda.\n\nThe Operator is defined as:\n\nU(theta phi lambda) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -e^ilambdamathrmsinleft(fractheta2right) 05em      \n    e^iphimathrmsinleft(fractheta2right) \n        e^ileft(phi+lambdaright)mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nuniversal(target, theta, phi, lambda)\n\nReturn a gate which rotates the target qubit given the angles theta, phi, and lambda.\n\nThe corresponding Operator is universal(theta, phi, lambda).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.control_z","page":"Library","title":"Snowflake.control_z","text":"control_z()\n\nReturn the controlled-Z Operator, which is defined as:\n\nCZ = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\n    endbmatrix\n\n\n\n\n\ncontrol_z(control_qubit, target_qubit)\n\nReturn a controlled-Z gate given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_z().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.control_x","page":"Library","title":"Snowflake.control_x","text":"control_x()\n\nReturn the controlled-X (or controlled NOT) Operator, which is defined as:\n\nCX = CNOT = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endbmatrix\n\n\n\n\n\ncontrol_x(control_qubit, target_qubit)\n\nReturn a controlled-X gate (also known as a controlled NOT gate) given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_x().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.iswap","page":"Library","title":"Snowflake.iswap","text":"iswap()\n\nReturn the imaginary swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap(qubit_1, qubit_2)\n\nReturn the imaginary swap Gate which applies the imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.:*-Tuple{Gate, Ket}","page":"Library","title":"Base.:*","text":"Base.:*(M::Gate, x::Ket)\n\nReturn a Ket which results from applying Gate M to Ket x.\n\nExamples\n\njulia> ψ_0 = fock(0, 2);\n\njulia> print(ψ_0)\n2-element Ket:\n1.0 + 0.0im\n0.0 + 0.0im\n\njulia> ψ_1 = sigma_x(1)*ψ_0;\n\njulia> print(ψ_1)\n2-element Ket:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.apply_gate!","page":"Library","title":"Snowflake.apply_gate!","text":"apply_gate!(state::Ket, gate::Gate)\n\nUpdate the state by applying a gate to it.\n\nExamples\n\njulia> ψ_0 = fock(0, 2);\n\njulia> print(ψ_0)\n2-element Ket:\n1.0 + 0.0im\n0.0 + 0.0im\n\njulia> apply_gate!(ψ_0, sigma_x(1));\n\njulia> print(ψ_0)\n2-element Ket:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Quantum-Processing-Unit","page":"Library","title":"Quantum Processing Unit","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"QPU\ncreate_virtual_qpu","category":"page"},{"location":"library.html#Snowflake.QPU","page":"Library","title":"Snowflake.QPU","text":"Represnts a Quantum Processing Unit (QPU). Fields\n\nmanufacturer:: String – qpu manufacturer (e.g. \"anyon\")\ngeneration:: String – qpu generation (e.g. \"yukon\")\nserial_number:: String – qpu serial_number (e.g. \"ANYK202201\")\nhost:: String – the remote host url address to send the jobs to\nqubit_count:: Int – number of physical qubits on the machine\nconnectivity::SparseArrays.SparseMatrixCSC{Int} – a matrix describing the connectivity between qubits\nnative_gates:: Vector{String} – the vector of native gates symbols supported by the qpu architecture\n\n```\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.create_virtual_qpu","page":"Library","title":"Snowflake.create_virtual_qpu","text":"create_virtual_qpu(qubit_count::Int, connectivity::Matrix{Int},\n    native_gates::Vector{String}, host = \"localhost:5600\")\n\nCreates a virtual quantum processor with qubit_count number of qubits, a connectivity matrix, and a vector of native_gates.  The return value is a QPU stucture (see  QPU).\n\nExamples\n\nTo generate a QPU structure, the connectivity must be specified. Let's assume that we have a 3-qubit device where there is connectivity between qubits 2 and 1 as well as between qubits 2 and 3. If qubit 2 can only be a control qubit, the connectivity matrix corresponds to:\n\njulia> connectivity = [1 0 0\n                       1 1 1\n                       0 0 1]\n3×3 Matrix{Int64}:\n 1  0  0\n 1  1  1\n 0  0  1\n\nHere, the ones in the diagonal indicate that all qubits can perform single-qubit gates. If there is a one in an off-diagonal entry with row i and column j, it indicates that a two-qubit gate with control qubit i and target qubit j can be applied.\n\nIf the native gates are the Pauli-X gate, the Hadamard gate, and the control-X gate, the QPU can be created as follows: \n\njulia> qpu = create_virtual_qpu(3, connectivity, [\"x\", \"h\", \"cx\"]);\n\njulia> qpu.qubit_count\n3\n\njulia> qpu.native_gates\n3-element Vector{String}:\n \"x\"\n \"h\"\n \"cx\"\n\njulia> qpu.connectivity\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 5 stored entries:\n 1  ⋅  ⋅\n 1  1  1\n ⋅  ⋅  1\n\njulia> qpu.host\n\"localhost:5600\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Quantum-Toolkit","page":"Library","title":"Quantum Toolkit","text":"","category":"section"},{"location":"library.html#Basic-Quantum-Objects","page":"Library","title":"Basic Quantum Objects","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"There are three basic quantum objects in Snowflake to simulate a quantum system. These objects are Ket, Bra, and Operator.","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"Ket\nBra\nOperator\nBase.adjoint\nBase.getindex(A::Operator, m::Int64, n::Int64)\neigen\ntr\nexpected_value\nkron\nMultiBodySystem\ncommute\nanticommute\nnormalize!\nket2dm\nfock_dm\nSnowflake.moyal\nSnowflake.genlaguerre\nget_embed_operator\nget_num_qubits(x::Operator)\nget_num_qubits(x::Union{Ket, Bra})\nget_num_bodies(x::Operator, hilbert_space_size_per_body=2)\nget_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\nfock\ncreate\ndestroy\nnumber_op\ncoherent\nsesolve\nmesolve","category":"page"},{"location":"library.html#Snowflake.Ket","page":"Library","title":"Snowflake.Ket","text":"A Ket represents a quantum wavefunction and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.  \n\nFields\n\ndata – the stored values.\n\nExamples\n\nAlthough NOT the preferred way, one can directly build a Ket object by passing a column vector as the initializer. \n\njulia> using Snowflake\n\njulia> ψ = Snowflake.Ket([1.0; 0.0; 0.0]);\n\njulia> print(ψ)\n3-element Ket:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\nA better way to initialize a Ket is to use a pre-built basis such as the fock basis. See fock for further information on this function. \n\njulia> ψ = Snowflake.fock(2, 3);\n\njulia> print(ψ)\n3-element Ket:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.Bra","page":"Library","title":"Snowflake.Bra","text":"A structure representing a Bra (i.e. a row vector of complex values). A Bra is created as the complex conjugate of a Ket.\n\nFields\n\ndata – the stored values.\n\nExamples\n\njulia> ψ = Snowflake.fock(1, 3);\n\njulia> print(ψ)\n3-element Ket:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\njulia> _ψ = Snowflake.Bra(ψ);\n\njulia> print(_ψ)\nBra(Any[0.0 - 0.0im 1.0 - 0.0im 0.0 - 0.0im])\n\n\njulia> _ψ * ψ    # A Bra times a Ket is a scalar\n1.0 + 0.0im\n\njulia> ψ*_ψ     # A Ket times a Bra is an operator\n(3, 3)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}: \n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.Operator","page":"Library","title":"Snowflake.Operator","text":"A structure representing a quantum operator (i.e. a complex matrix).\n\nFields\n\ndata – the complex matrix.\n\nExamples\n\njulia> z = Snowflake.Operator([1.0 0.0;0.0 -1.0])\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}: \n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    -1.0 + 0.0im\n\n\nAlternatively:\n\njulia> z = Snowflake.sigma_z()  #sigma_z is a defined function in Snowflake\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}: \n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    -1.0 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"library.html#Base.adjoint","page":"Library","title":"Base.adjoint","text":"Base.adjoint(x)\n\nCompute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.getindex-Tuple{Operator, Int64, Int64}","page":"Library","title":"Base.getindex","text":"Base.getindex(A::Operator, m::Int64, n::Int64)\n\nReturn the element at row m and column n of Operator A.\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.eigen","page":"Library","title":"Snowflake.eigen","text":"eigen(A::Operator)\n\nCompute the eigenvalue decomposition of Operator A and return an Eigen factorization object F. Eigenvalues are found in F.values while eigenvectors are found in the matrix F.vectors. Each column of this matrix corresponds to an eigenvector. The ith eigenvector is extracted by calling F.vectors[:, i].\n\nExamples\n\njulia> X = sigma_x()\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im\n\njulia> F = eigen(X);\n\njulia> eigenvalues = F.values\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> eigenvector_1 = F.vectors[:, 1]\n2-element Vector{ComplexF64}:\n -0.7071067811865475 + 0.0im\n  0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.tr","page":"Library","title":"Snowflake.tr","text":"tr(A::Operator)\n\nCompute the trace of Operator A.\n\nExamples\n\njulia> I = eye()\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n1.0 + 0.0im    0 + 0im\n0 + 0im    1.0 + 0.0im\n\n\njulia> trace = tr(I)\n2.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.expected_value","page":"Library","title":"Snowflake.expected_value","text":"expected_value(A::Operator, psi::Ket)\n\nCompute the expectation value ⟨ψ|A|ψ⟩ given Operator A and Ket |ψ⟩.\n\nExamples\n\njulia> ψ = Ket([0.0; 1.0]);\n\njulia> print(ψ)\n2-element Ket:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> A = sigma_z()\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    -1.0 + 0.0im\n\n\njulia> expected_value(A, ψ)\n-1.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.kron","page":"Library","title":"Base.kron","text":"kron(x, y)\n\nCompute the Kronecker product of two Kets or two Operators. More details about the Kronecker product can be found here. \n\nExamples\n\njulia> ψ_0 = Ket([0.0; 1.0]);\n\njulia> print(ψ_0)\n2-element Ket:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> ψ_1 = Ket([1.0; 0.0]);\n\njulia> print(ψ_1)\n2-element Ket:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_0_1 = kron(ψ_0, ψ_1);\n\njulia> print(ψ_0_1)\n4-element Ket:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> kron(sigma_x(), sigma_y())\n(4, 4)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.MultiBodySystem","page":"Library","title":"Snowflake.MultiBodySystem","text":"A structure representing a quantum multi-body system.\n\nFields\n\nhilbert_space_structure – a vector of integers specifying the local Hilbert space size for each \"body\" within the multi-body system. \n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.commute","page":"Library","title":"Snowflake.commute","text":"Snowflake.commute(A::Operator, B::Operator)\n\nReturns the commutation of A and B.\n\njulia> σ_x = sigma_x()\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}: \n0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im\n\n\njulia> σ_y = sigma_y()\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}: \n0.0 + 0.0im    0.0 - 1.0im\n0.0 + 1.0im    0.0 + 0.0im\n\n\njulia> Snowflake.commute(σ_x,σ_y)\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}: \n0.0 + 2.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 - 2.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.anticommute","page":"Library","title":"Snowflake.anticommute","text":"Snowflake.anticommute(A::Operator, B::Operator)\n\nReturns the anticommutation of A and B.\n\njulia> σ_x = Snowflake.sigma_x()\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}: \n0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im\n\n\njulia> Snowflake.anticommute(σ_x,σ_x)\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}: \n2.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    2.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.normalize!","page":"Library","title":"Snowflake.normalize!","text":"Snowflake.normalize!(x::Ket)\n\nNormalizes Ket x such that its magnitude becomes unity.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.ket2dm","page":"Library","title":"Snowflake.ket2dm","text":"Snowflake.ket2dm(ψ)\n\nReturns the density matrix corresponding to the pure state ψ.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.fock_dm","page":"Library","title":"Snowflake.fock_dm","text":"Snowflake.fock_dm(i, hspace_size)\n\nReturns the density matrix corresponding to the Fock base i defined in a Hilbert space of size hspace_size.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.moyal","page":"Library","title":"Snowflake.moyal","text":"Snowflake.moyal(m, n)\n\nReturns the Moyal function w_mn(eta) for Fock states m and n.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.genlaguerre","page":"Library","title":"Snowflake.genlaguerre","text":"Snowflake.genlaguerre(x, alpha, n)\n\nReturns the generalized Laguerre polynomial of degree n for x using a recursive method. See https://en.wikipedia.org/wiki/Laguerre_polynomials.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_embed_operator","page":"Library","title":"Snowflake.get_embed_operator","text":"get_embed_operator(op::Operator, target_body_index::Int, system::MultiBodySystem)\n\nUses a local operator (op), which is defined for a particular body (e.g. qubit) with index target_body_index, to build the corresponding operator for the Hilbert space of the multi-body system given by system. \n\nExamples\n\njulia> system = Snowflake.MultiBodySystem(3,2)\nSnowflake.Multibody system with 3 bodies\n   Hilbert space structure:\n   [2, 2, 2]\n\njulia> x = Snowflake.sigma_x()\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}: \n0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im\n\njulia> X_1=Snowflake.get_embed_operator(x,1,system)\n(8, 8)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}: \n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_qubits-Tuple{Operator}","page":"Library","title":"Snowflake.get_num_qubits","text":"get_num_qubits(x::Operator)\n\nReturns the number of qubits associated with an Operator.\n\nExamples\n\njulia> ρ = Operator([1 0\n                     0 0])\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n1 + 0im    0 + 0im\n0 + 0im    0 + 0im\n\njulia> get_num_qubits(ρ)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_qubits-Tuple{Union{Bra, Ket}}","page":"Library","title":"Snowflake.get_num_qubits","text":"get_num_qubits(x::Union{Ket, Bra})\n\nReturns the number of qubits associated with a Ket or a Bra.\n\nExamples\n\njulia> ψ = Ket([1, 0, 0, 0]);\n\njulia> print(ψ)\n4-element Ket:\n1 + 0im\n0 + 0im\n0 + 0im\n0 + 0im\n\njulia> get_num_qubits(ψ)\n2\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.get_num_bodies","page":"Library","title":"Snowflake.get_num_bodies","text":"get_num_bodies(x::Operator, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with an Operator given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ρ = Operator([1 0 0\n                     0 0 0\n                     0 0 0])\n(3, 3)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n1 + 0im    0 + 0im    0 + 0im\n0 + 0im    0 + 0im    0 + 0im\n0 + 0im    0 + 0im    0 + 0im\n\njulia> get_num_bodies(ρ, 3)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.get_num_bodies-2","page":"Library","title":"Snowflake.get_num_bodies","text":"get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with a Ket or a Bra given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ψ = Ket([1, 0, 0, 0, 0, 0, 0, 0, 0]);\n\njulia> print(ψ)\n9-element Ket:\n1 + 0im\n0 + 0im\n0 + 0im\n0 + 0im\n0 + 0im\n0 + 0im\n0 + 0im\n0 + 0im\n0 + 0im\n\njulia> get_num_bodies(ψ, 3)\n2\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.fock","page":"Library","title":"Snowflake.fock","text":"Snowflake.fock(i, hspace_size)\n\nReturns the ith fock basis of a Hilbert space with size hspace_size as Snowflake.Ket.\n\nExamples\n\njulia> ψ = Snowflake.fock(0, 3);\n\njulia> print(ψ)\n3-element Ket:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = Snowflake.fock(1, 3);\n\njulia> print(ψ)\n3-element Ket:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.create","page":"Library","title":"Snowflake.create","text":"Snowflake.create(hspace_size)\n\nReturns the bosonic creation operator for a Fock space of size hspace_size.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.destroy","page":"Library","title":"Snowflake.destroy","text":"Snowflake.destroy(hspace_size)\n\nReturns the bosonic annhilation operator for a Fock space of size hspace_size.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.number_op","page":"Library","title":"Snowflake.number_op","text":"Snowflake.number_op(hspace_size)\n\nReturns the number operator for a Fock space of size hspace_size.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.coherent","page":"Library","title":"Snowflake.coherent","text":"Snowflake.coherent(alpha, hspace_size)\n\nReturns a coherent state for the parameter alpha in a Fock space of size hspace_size. Note that |alpha|^2 is equal to the      photon number of the coherent state. \n\n# Examples\n\njulia> ψ = Snowflake.coherent(2.0,20);\n\njulia> print(ψ)\n20-element Ket:\n0.13533528323661270231781372785917483270168304443359375 + 0.0im\n0.2706705664732254046356274557183496654033660888671875 + 0.0im\n0.3827859860416437253261507804308297496944779411605434060697044368322244814859633 + 0.0im\n0.4420031841663186705315006220668383887063770056788388080454298547413058719111879 + 0.0im\n0.4420031841663186705315006220668383887063770056788388080454298547413058719111879 + 0.0im\n0.3953396664268989033516298387998153143981494385130297054512994395645417722835952 + 0.0im\n0.3227934859426706749083446895240143309122789082442331409841890434072244670369041 + 0.0im\n0.2440089396102658373848913914105868080225858281751344102479261185426274154783478 + 0.0im\n0.1725403758685577344434702345068468523504659376126805082402433361167676595291802 + 0.0im\n0.1150269172457051562956468230045645682336439584084536721601622240778451063527861 + 0.0im\n0.07274941014482606043765122911007029674853133081310976424472247415659623989683902 + 0.0im\n0.04386954494001140575894979175461054210856445342112420740912216424244799751166167 + 0.0im\n0.02532809358034196997591593372015585816248494654573845414140041049288863525802268 + 0.0im\n0.01404949847902665677216550321294394000313011924224810466364209088409881639691112 + 0.0im\n0.007509772823502763531724947918871845905858490361570411398782773832262018118359266 + 0.0im\n0.003878030010563633897440227516084030465660984499951448370503442999620168228954113 + 0.0im\n0.001939015005281816948720113758042015232830492249975724185251721499810084114477056 + 0.0im\n0.0009405604325217079112661845386949416195293171394724978755464370121167236584289665 + 0.0im\n0.0004433844399679012093293182780011289711800019436937749734346315219336842860352511 + 0.0im\n0.0002034387333640481868882144439914691756776463670619686354629916554722074664961924 + 0.0im\n\n\njulia> Snowflake.expected_value(Snowflake.number_op(20),ψ)\n3.999999793648639261230596388008292158320219007459973469036845972185905095821291 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.sesolve","page":"Library","title":"Snowflake.sesolve","text":"Snowflake.sesolve(H::Operator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)\nSnowflake.sesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)\n\nSolves the Shrodinger equation:\n\nfracd Psid t=-i hatHPsi\n\nFields\n\nH – the Hamiltonian operator or a function that returns the Hamiltonian as a function of time.\nψ_0 – initital status of a quantum system\nt_range – time interval for which the system has to be simulated. \ne_ops – list of operators for which the expected value will be returned as a function of time. \n\n\n\n\n\n","category":"function"},{"location":"library.html#Snowflake.mesolve","page":"Library","title":"Snowflake.mesolve","text":"Snowflake.mesolve(H::Operator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)\nSnowflake.mesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)\n\nSolves the Lindblad Master equation:\n\ndotrho=-i H rho+sum_i gamma_ileft(L_i rho L^dag_i - frac12leftL^dag_i L_i rhorightright)\n\nFields\n\nH – the Hamiltonian operator or a function that returns the Hamiltonian as a function of time.\nψ_0 – initital status of a quantum system\nt_range – time interval for which the system has to be simulated. \ne_ops – list of operators for which the expected value will be returned as function of time. \nc_ops – list of collapse operators L_i's.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Visualization","page":"Library","title":"Visualization","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"Snowflake provides multiple tools for visualizing quantum computer calculations.","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"plot_bloch_sphere(circuit::QuantumCircuit; qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\nplot_bloch_sphere(ket::Ket; qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\nplot_bloch_sphere(density_matrix::Operator; qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\nBlochSphere\nplot_bloch_sphere_animation(ket_list::Vector{Ket};\n    qubit_id::Int = 1,\n    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())","category":"page"},{"location":"library.html#Snowflake.plot_bloch_sphere-Tuple{QuantumCircuit}","page":"Library","title":"Snowflake.plot_bloch_sphere","text":"plot_bloch_sphere(circuit::QuantumCircuit;\n    qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\n\nPlots the Bloch sphere of qubit qubit_id for the circuit.\n\nIf the circuit contains multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit qubit_id. The appearance of the Bloch sphere can be modified by passing a BlochSphere struct.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count=2, bit_count=0)\nQuantum Circuit Object:\n   id: c9ebdf08-f0ba-11ec-0c5e-8ff2bf2f3825 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:\n     \nq[2]:\n\n\njulia> push_gate!(circuit, [hadamard(1), sigma_x(2)])\nQuantum Circuit Object:\n   id: c9ebdf08-f0ba-11ec-0c5e-8ff2bf2f3825 \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H──\n          \nq[2]:──X──\n\n\n\njulia> plot = plot_bloch_sphere(circuit, qubit_id=2)\n\n\n(Image: Bloch sphere for circuit)\n\nThe Bloch sphere can be saved to a file by calling:\n\njulia> PlotlyJS.savefig(plot, \"bloch_sphere.png\", width=size(plot)[1],\n                        height=size(plot)[2])\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.plot_bloch_sphere-Tuple{Ket}","page":"Library","title":"Snowflake.plot_bloch_sphere","text":"plot_bloch_sphere(ket::Ket;\n    qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\n\nPlots the Bloch sphere of qubit qubit_id for the state represented by ket.\n\nIf ket is associated with multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit qubit_id. The appearance of the Bloch sphere can be modified by passing a BlochSphere struct.\n\nExamples\n\njulia> ket = Ket(1/sqrt(2)*[1, 1]);\n\njulia> print(ket)\n2-element Ket:\n0.7071067811865475 + 0.0im\n0.7071067811865475 + 0.0im\n\n\njulia> plot = plot_bloch_sphere(ket)\n\n\n(Image: Bloch sphere for ket)\n\nThe Bloch sphere can be saved to a file by calling:\n\njulia> PlotlyJS.savefig(plot, \"bloch_sphere.png\", width=size(plot)[1],\n                        height=size(plot)[2])\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.plot_bloch_sphere-Tuple{Operator}","page":"Library","title":"Snowflake.plot_bloch_sphere","text":"plot_bloch_sphere(density_matrix::Operator;\n    qubit_id::Int = 1,\n    bloch_sphere::BlochSphere = BlochSphere())\n\nPlots the Bloch sphere of qubit qubit_id given the density_matrix.\n\nIf the density_matrix is associated with multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit qubit_id. The appearance of the Bloch sphere can be modified by passing a BlochSphere struct.\n\nExamples\n\njulia> ρ = Operator([1.0 0.0;\n                     0.0 0.0])\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\n\njulia> plot = plot_bloch_sphere(ρ)\n\n\n(Image: Bloch sphere for operator)\n\nThe Bloch sphere can be saved to a file by calling:\n\njulia> PlotlyJS.savefig(plot, \"bloch_sphere.png\", width=size(plot)[1],\n                        height=size(plot)[2])\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Snowflake.BlochSphere","page":"Library","title":"Snowflake.BlochSphere","text":"BlochSphere\n\nContains fields which affect how a Bloch sphere is generated.\n\nExamples\n\njulia> ket = Ket(1/sqrt(2)*[1, 1]);\n\njulia> print(ket)\n2-element Ket:\n0.7071067811865475 + 0.0im\n0.7071067811865475 + 0.0im\n\njulia> bloch_sphere = BlochSphere(vector_color=\"green\");\n\n\njulia> plot = plot_bloch_sphere(ket, bloch_sphere=bloch_sphere)\n\n\n(Image: Bloch sphere for ket)\n\n\n\n\n\n","category":"type"},{"location":"library.html#Snowflake.plot_bloch_sphere_animation-Tuple{Vector{Ket}}","page":"Library","title":"Snowflake.plot_bloch_sphere_animation","text":"plot_bloch_sphere_animation(ket_list::Vector{Ket};\n    qubit_id::Int = 1,\n    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())\n\nPlots a Bloch sphere animation of qubit qubit_id for the states listed in ket_list.\n\nIf ket_list is associated with multiple qubits, the Bloch sphere animation is constructed from the 1-qubit reduced density matrices of qubit qubit_id. Animation settings and the appearance of the Bloch sphere can be modified by passing an AnimatedBlochSphere struct.\n\nExamples\n\njulia> ket_list = [Ket([1, 0]), Ket(1/sqrt(2)*[1, 1])];\n\njulia> plot = plot_bloch_sphere_animation(ket_list)\n\n\nThe Bloch sphere animation can be saved to an html file by calling:\n\njulia> PlotlyJS.savefig(plot, \"bloch_sphere_animation.html\")\n\n\n\n\n\n\n","category":"method"},{"location":"library.html","page":"Library","title":"Library","text":"<iframe src=\"assets/visualize/plot_bloch_sphere_animation_for_ket.html\"\nstyle=\"height:825px;width:100%;\">\n</iframe>","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"plot_bloch_sphere_animation(density_matrix_list::Vector{Operator};\n    qubit_id::Int = 1,\n    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())","category":"page"},{"location":"library.html#Snowflake.plot_bloch_sphere_animation-Tuple{Vector{Operator}}","page":"Library","title":"Snowflake.plot_bloch_sphere_animation","text":"plot_bloch_sphere_animation(density_matrix_list::Vector{Operator};\n    qubit_id::Int = 1,\n    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())\n\nPlots a Bloch sphere animation of qubit qubit_id for the states listed in density_matrix_list.\n\nIf density_matrix_list is associated with multiple qubits, the Bloch sphere animation is constructed from the 1-qubit reduced density matrices of qubit qubit_id. Animation settings and the appearance of the Bloch sphere can be modified by passing an AnimatedBlochSphere struct.\n\nExamples\n\njulia> ψ_0 = Operator([0.5 0.5; 0.5 0.5]);\n\njulia> ψ_1 = Operator([0.5 -0.5im; 0.5im 0.5]);\n\njulia> plot = plot_bloch_sphere_animation([ψ_0, ψ_1])\n\n\nThe Bloch sphere animation can be saved to an html file by calling:\n\njulia> PlotlyJS.savefig(plot, \"bloch_sphere_animation.html\")\n\n\n\n\n\n\n","category":"method"},{"location":"library.html","page":"Library","title":"Library","text":"<iframe src=\"assets/visualize/plot_bloch_sphere_animation_for_operator.html\"\nstyle=\"height:825px;width:100%;\">\n</iframe>","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"AnimatedBlochSphere","category":"page"},{"location":"library.html#Snowflake.AnimatedBlochSphere","page":"Library","title":"Snowflake.AnimatedBlochSphere","text":"AnimatedBlochSphere\n\nContains fields which affect how a Bloch sphere animation is generated.\n\nExamples\n\nBy default, additional Bloch sphere vectors are generated between each state using interpolation. The number of additional vectors can be changed by passing a value for the keyword num_interpolated_points.\n\njulia> ket_list = [Ket([1, 0]), Ket(1/sqrt(2)*[1, 1])];\n\njulia> animated_sphere = AnimatedBlochSphere(num_interpolated_points=0,\n        history_line_color=\"transparent\", frame_duration=1000);\n\njulia> plot = plot_bloch_sphere_animation(ket_list, animated_bloch_sphere=animated_sphere)\n\n\n\n\n\n\n","category":"type"},{"location":"library.html","page":"Library","title":"Library","text":"<iframe src=\"assets/visualize/plot_bloch_sphere_animation_without_interpolation.html\"\nstyle=\"height:825px;width:100%;\">\n</iframe>","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"DocTestSetup = nothing","category":"page"},{"location":"qc/basics.html#What-is-Quantum-Computing?","page":"Basics","title":"What is Quantum Computing?","text":"","category":"section"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Quantum computing is a new paradigm in high performance computing that utilizes the fundamental principles of quantum mechanics to perform calculations. Quantum computation holds great promise to outperform classical computers in some tasks such as prime factorization, quantum simulation, search, optimization, and algebraic programs such as machine learning.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"The power of quantum computing stems from two fundamental properties of quantum mechanics, namely superposition and entanglement.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Snowflake is a Julia-based SDK for performing quantum computations. Quantum computation is conducted by building and executing quantum circuits. These circuits are comprised of quantum gates, instructions, and classical control logic. Complex algorithms and applications can be expressed in terms of quantum circuits that can be executed on a quantum computer.","category":"page"},{"location":"qc/basics.html#Quantum-Circuits","page":"Basics","title":"Quantum Circuits","text":"","category":"section"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Algorithms and applications that utilize quantum mechanical resources use a concept known as a quantum circuit to represent quantum operations. A quantum circuit is a computational pipeline consisting of a quantum register and a classical register. The following figure shows an example of a 3-qubit quantum circuit:","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"(Image: Bell State generator circuit)","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"The initial state of each qubit is given on the left side of the figure. The lines correspond to the timeline of operations that are performed on the qubits. The boxes and symbols denote different single-qubit or multi-qubit gates.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"You can define a quantum circuit with Snowflake as follows:","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"julia> c = QuantumCircuit(qubit_count = 2, bit_count = 0)\nQuantum Circuit Object:\n   id: 0b7e9004-7b2f-11ec-0f56-c91274d7066f \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:\n     \nq[2]:\n  ","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"The above example creates a quantum circuit with two qubits and no classical bit. It is now ready to be used to store quantum instructions, which are also known as quantum gates. ","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"tip: Circuit UUID\nNote that the circuit object has been given a Universally Unique Identifier (UUID). This UUID can be used later to retrieve the circuit results from a remote server such as a quantum computer on the cloud.","category":"page"},{"location":"qc/basics.html#Quantum-Gates","page":"Basics","title":"Quantum Gates","text":"","category":"section"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"A quantum gate is a basic quantum operation that affects one or more qubits. Quantum gates are the building blocks of quantum circuits, like classical logic gates are for conventional digital circuits.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Unlike their classic counterparts, quantum gates are reversible. Quantum gates are unitary operators and can be represented as unitary matrices.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Now, let's add a few gates to our circuit using the push_gate command:","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"julia> push_gate!(c, [hadamard(1)])\nQuantum Circuit Object:\n   id: 0b7e9004-7b2f-11ec-0f56-c91274d7066f \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H──\n          \nq[2]:─────","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"The first command added a Hadamard gate to the quantum circuit object c. The gate will operate on qubit 1.","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"julia> push_gate!(c, [control_x(1, 2)])\nQuantum Circuit Object:\n   id: 0b7e9004-7b2f-11ec-0f56-c91274d7066f \n   qubit_count: 2 \n   bit_count: 0 \nq[1]:──H────*──\n            |  \nq[2]:───────X──","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"The second command added a CNOT gate (Control-X gate) with qubit 1 as the control and qubit 2 as the target. ","category":"page"},{"location":"qc/basics.html#Quantum-Processing-Unit-(QPU)","page":"Basics","title":"Quantum Processing Unit (QPU)","text":"","category":"section"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Usually, quantum circuits cannot be immediately executed on a quantum processor. This is because QPUs typically execute only a limited number of quantum gates directly on the hardware. Such gates are commonly referred to as native gates. This means that once a general quantum circuit is defined, it needs to be transpiled such that it only makes use of the native gates of a given QPU . ","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"Snowflake introduces QPU to represent physical or virtual quantum processors. For example, the following command creates a virtual QPU which can implement Pauli matrices and Control-Z gates:","category":"page"},{"location":"qc/basics.html","page":"Basics","title":"Basics","text":"DocTestSetup = nothing","category":"page"},{"location":"qc/overview.html#Snowflake-Overview","page":"Snowflake Overview","title":"Snowflake Overview","text":"","category":"section"},{"location":"qc/overview.html","page":"Snowflake Overview","title":"Snowflake Overview","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"qc/overview.html","page":"Snowflake Overview","title":"Snowflake Overview","text":"Snowflake is a pure Julia quantum computing stack that allows you to easily design quantum circuits, algorithms, experiments and applications and run them on real quantum computers and/or classical simulators.","category":"page"},{"location":"qc/overview.html","page":"Snowflake Overview","title":"Snowflake Overview","text":"DocTestSetup = nothing","category":"page"},{"location":"index.html#Snowflake.jl","page":"Home","title":"Snowflake.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A library for quantum computing using Julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Snowflake is a pure Julia quantum computing stack that allows you to easily design quantum circuits, algorithms, experiments and applications. Julia can then run them on real quantum computers and/or classical simulators. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nThe documentation of Snowflake is still a work in progress. That being said, a lot can be learnt from the unit tests in the test folder.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Make sure your system has Julia (v.1.6 or a more recent version) installed. If not, download the latest version from https://julialang.org/downloads/.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Launch Julia REPL and type:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Snowflake\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you intend to use a particular development branch from github repo, you can use the following commands:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/anyonlabs/Snowflake.jl\", rev=\"BRANCH_NAME\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note: Replace the BRANCH_NAME with the name of the branch you want to use. The stable release is main and the most up-to-date one is next.","category":"page"},{"location":"index.html#Get-Started","page":"Home","title":"Get Started","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Like other Julia Packages, you can use Snowflake in a Julia REPL, in a Julia script, or in a notebook.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A typical workflow to use a quantum computer consists of the following four steps:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Build: Design a quantum circuit(s) that represents the problem you are considering.\nCompile: Compile circuits for a specific quantum service, e.g. a quantum system or classical simulator.\nRun: Run the compiled circuits on the specified quantum service(s). These services can be cloud-based or local.\nPostprocess: Compute summary statistics and visualize the results of the experiments.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Now, let's try Snowflake by making a two-qubit circuit which implements a Bell/EPR state. The quantum circuit for generating a Bell state involves a Hadamard gate on one of the qubits followed by a CNOT gate (see https://en.wikipedia.org/wiki/Quantumlogicgate for an introduction to quantum logic gates). This circuit is shown below:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Bell State generator circuit)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"First import Snowflake:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Snowflake","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Then, let's define a two-qubit circuit:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"c = QuantumCircuit(qubit_count=2, bit_count=0)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you are using Julia REPL, you should see an output similar to:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Quantum Circuit Object:\n   id: 1e9c4f6e-64df-11ec-0c5b-036aab5b72cb\n   qubit_count: 2\n   bit_count: 0\nq[1]:\n\nq[2]:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note that the circuit object has been given a Universally Unique Identifier (UUID). This UUID can be used later to retrieve the circuit results from a remote server such as a quantum computer on the cloud.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Now, let's build the circuit using the following commands:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"push_gate!(c, [hadamard(1)])\npush_gate!(c, [control_x(1, 2)])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The first line adds a Hadamard gate to circuit object c which will operate on qubit 1. The second line adds a CNOT gate (Control-X gate) with qubit 1 as the control qubit and qubit 2 as the target qubit. The output in Julia REPL would look like:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Quantum Circuit Object:\n   id: 1e9c4f6e-64df-11ec-0c5b-036aab5b72cb\n   qubit_count: 2\n   bit_count: 0\nq[1]:──H────*──\n            |\nq[2]:───────X──","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note: Unlike C++ or Python, indexing in Julia starts from \"1\" and not \"0\"!","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Finally, you can simulate this circuit and obtain the final quantum state of this two-qubit register:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ψ = simulate(c)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"which would give:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"4-element Ket:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note: Snowflake always assumes a qubit is initialized in state 0.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The script below puts all the steps above together:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Snowflake\n\nc = QuantumCircuit(qubit_count=2, bit_count=0)\npush_gate!(c, [hadamard(1)])\npush_gate!(c, [control_x(1, 2)])\nψ = simulate(c)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"DocTestSetup = nothing","category":"page"},{"location":"simulating_quantum_systems.html#Simulating-Quantum-Systems","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"","category":"section"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"Snowflake provides capability to directly simulate a quantum system on a classical computer. The following sections of this page provide you with documentation and examples of how to achieve that.","category":"page"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"Note that using a quantum computer does not involve using these objects. But, simulating the operation of a quantum computer, or any quantum system for that matter, on a classical computer does!","category":"page"},{"location":"simulating_quantum_systems.html#Basic-Quantum-Objects","page":"Simulating Quantum Systems","title":"Basic Quantum Objects","text":"","category":"section"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"There are three basic quantum objects defined in Snowflake to simulate a Quantum system. These objects are Ket, Bra, and Operator.","category":"page"},{"location":"simulating_quantum_systems.html#Multibody-Systems","page":"Simulating Quantum Systems","title":"Multibody Systems","text":"","category":"section"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"MultiBodySystem structures are used to represent quantum multi-body systems. After defining a multi-body system, it is possible to build an operator for this system given a local operator (e.g. one which acts on a qubit). An operator for a multi-body system can be obtained by calling get_embed_operator.","category":"page"},{"location":"simulating_quantum_systems.html#Fock-Space","page":"Simulating Quantum Systems","title":"Fock Space","text":"","category":"section"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"A Ket which represents a bosonic Fock space can be created by calling fock.","category":"page"},{"location":"simulating_quantum_systems.html","page":"Simulating Quantum Systems","title":"Simulating Quantum Systems","text":"DocTestSetup = nothing","category":"page"}]
}
