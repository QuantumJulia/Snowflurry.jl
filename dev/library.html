<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Snowflake</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Snowflake logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Snowflake</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="getting_started.html">Getting Started</a></li><li><a class="tocitem" href="tutorials/index.html">Tutorials</a></li><li class="is-active"><a class="tocitem" href="library.html">Library</a><ul class="internal"><li><a class="tocitem" href="#Quantum-Circuit"><span>Quantum Circuit</span></a></li><li><a class="tocitem" href="#Quantum-Gates"><span>Quantum Gates</span></a></li><li><a class="tocitem" href="#Quantum-Processing-Unit"><span>Quantum Processing Unit</span></a></li><li><a class="tocitem" href="#Quantum-Toolkit"><span>Quantum Toolkit</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="library.html">Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="library.html">Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/anyonlabs/Snowflake.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Quantum-Circuit"><a class="docs-heading-anchor" href="#Quantum-Circuit">Quantum Circuit</a><a id="Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.QuantumCircuit" href="#Snowflake.QuantumCircuit"><code>Snowflake.QuantumCircuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuantumCircuit(qubit_count)</code></pre><p>A data structure to represent a <em>quantum circuit</em>.  </p><p><strong>Fields</strong></p><ul><li><code>qubit_count::Int</code> – number of qubits (i.e. quantum register size).</li><li><code>gates::Array{Array{Gate}}</code> – the sequence of gates to operate on qubits.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push!(circuit::QuantumCircuit, gates::AbstractGate...)</code></pre><p>Inserts one or more <code>gates</code> at the end of a <code>circuit</code>.</p><p>A <code>Vector</code> of <code>AbstractGate</code> objects can be passed to this function by using splatting. More details about splatting are provided <a href="https://docs.julialang.org/en/v1/manual/faq/#What-does-the-...-operator-do?">here</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; gate_list = [sigma_x(1), hadamard(2)];

julia&gt; push!(c, gate_list...)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*────X───────
                 |            
q[2]:───────X────X─────────H──
                              


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L40-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pop!(circuit::QuantumCircuit)</code></pre><p>Removes the last gate from <code>circuit.gates</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; pop!(c)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L442-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">append!(base_circuit::QuantumCircuit, circuits_to_append::QuantumCircuit...)</code></pre><p>Appends one or more <code>circuits_to_append</code> to the <code>base_circuit</code>.</p><p>The <code>circuits_to_append</code> cannot contain more qubits than the <code>base_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; base = QuantumCircuit(qubit_count=2, gates=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; append_1 = QuantumCircuit(qubit_count=1, gates=[sigma_z(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──Z──
          



julia&gt; append_2 = QuantumCircuit(qubit_count=2, gates=[control_x(1,2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──*──
       |  
q[2]:──X──
          



julia&gt; append!(base, append_1, append_2)

julia&gt; print(base)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X────Z────*──
                 |  
q[2]:────────────X──
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L95-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prepend!(base_circuit::QuantumCircuit, circuits_to_prepend::QuantumCircuit...)</code></pre><p>Prepends one or more <code>circuits_to_prepend</code> to the <code>base_circuit</code>.</p><p>The order of the <code>circuits_to_prepend</code> is maintained (i.e. <code>circuits_to_prepend[1]</code> will appear leftmost in <code>base_circuit</code>). The <code>circuits_to_prepend</code> cannot contain more qubits than the <code>base_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; base = QuantumCircuit(qubit_count=2, gates=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; prepend_1 = QuantumCircuit(qubit_count=1, gates=[sigma_z(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──Z──
          



julia&gt; prepend_2 = QuantumCircuit(qubit_count=2, gates=[control_x(1,2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──*──
       |  
q[2]:──X──
          



julia&gt; prepend!(base, prepend_1, prepend_2)

julia&gt; print(base)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────*────X──
            |       
q[2]:───────X───────
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L157-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.simulate" href="#Snowflake.simulate"><code>Snowflake.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(circuit::QuantumCircuit)</code></pre><p>Simulates and returns the wavefunction of the quantum device after running <code>circuit</code>. </p><p>Employs the approach described in Listing 5 of <a href="https://doi.org/10.22331/q-2021-10-06-559">Suzuki <em>et. al.</em> (2021)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; ket = simulate(c)
4-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L641-L680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.simulate_shots" href="#Snowflake.simulate_shots"><code>Snowflake.simulate_shots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_shots(c::QuantumCircuit, shots_count::Int = 100)</code></pre><p>Emulates a quantum computer by running a circuit for a given number of shots and returning measurement results.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; simulate_shots(c, 99)
99-element Vector{String}:
 &quot;11&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 ⋮
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L691-L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_measurement_probabilities-Tuple{QuantumCircuit}" href="#Snowflake.get_measurement_probabilities-Tuple{QuantumCircuit}"><code>Snowflake.get_measurement_probabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_measurement_probabilities(circuit::QuantumCircuit,
    [target_qubits::Vector{&lt;:Integer}])::AbstractVector{&lt;:Real}</code></pre><p>Returns a vector listing the measurement probabilities for the <code>target_qubits</code> in the <code>circuit</code>.</p><p>If no <code>target_qubits</code> are provided, the probabilities are computed for all the qubits.</p><p>The measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit <code>QuantumCircuit</code>, the probabilities are listed for 00, 01, 10, and 11.</p><p><strong>Examples</strong></p><p>The following example constructs a <code>QuantumCircuit</code> where the probability of measuring 01 is 50% and the probability of measuring 11 is also 50%.</p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count=2);

julia&gt; push!(circuit, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; get_measurement_probabilities(circuit)
4-element Vector{Float64}:
 0.0
 0.4999999999999999
 0.0
 0.4999999999999999
</code></pre><p>For the same <code>circuit</code>, the probability of measuring qubit 2 and finding 1 is 100%.</p><pre><code class="language-julia-repl hljs">julia&gt; target_qubit = [2];

julia&gt; get_measurement_probabilities(circuit, target_qubit)
2-element Vector{Float64}:
 0.0
 0.9999999999999998
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L765-L811">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{QuantumCircuit}" href="#Base.inv-Tuple{QuantumCircuit}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(circuit::QuantumCircuit)</code></pre><p>Return a <code>QuantumCircuit</code> which is the inverse of the input <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, rotation_y(1, pi/4));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Ry(0.7854)────*──
                     |  
q[2]:────────────────X──
                        



julia&gt; inv(c)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──*────Ry(-0.7854)──
       |                 
q[2]:──X─────────────────
                         


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L824-L856">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_gates_per_type" href="#Snowflake.get_num_gates_per_type"><code>Snowflake.get_num_gates_per_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_gates_per_type(circuit::QuantumCircuit)::AbstractDict{&lt;:AbstractString, &lt;:Integer}</code></pre><p>Returns a dictionary listing the number of gates of each type found in the <code>circuit</code>.</p><p>The dictionary keys are the instruction_symbol of the gates while the values are the number of gates found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, hadamard(1), hadamard(2));

julia&gt; push!(c, control_x(1, 2));

julia&gt; push!(c, hadamard(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*───────
                 |       
q[2]:───────H────X────H──
                         



julia&gt; get_num_gates_per_type(c)
Dict{String, Int64} with 2 entries:
  &quot;h&quot;  =&gt; 3
  &quot;cx&quot; =&gt; 1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L867-L898">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_gates" href="#Snowflake.get_num_gates"><code>Snowflake.get_num_gates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_gates(circuit::QuantumCircuit)::Integer</code></pre><p>Returns the number of gates in the <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, hadamard(1), hadamard(2));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────H────X──
                    



julia&gt; get_num_gates(c)
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L912-L937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.serialize_job" href="#Snowflake.serialize_job"><code>Snowflake.serialize_job</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">serialize_job(circuit::QuantumCircuit,repetitions::Integer)</code></pre><p>Creates a JSON-formatted String containing the circuit configuration to be sent  to a <code>QPU</code> service, along with the number of repetitions requested.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2,gates=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; serialize_job(c,10)
&quot;{\&quot;num_repetitions\&quot;:10,\&quot;circuit\&quot;:{\&quot;operations\&quot;:[{\&quot;parameters\&quot;:{},\&quot;type\&quot;:\&quot;x\&quot;,\&quot;qubits\&quot;:[0]}]}}&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/qpu_interface.jl#L106-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.transpile" href="#Snowflake.transpile"><code>Snowflake.transpile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transpile(::CompressSingleQubitGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CompressSingleQubitGatesTranspiler</code> transpiler stage  which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single universal gates in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CompressSingleQubitGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X────Y──
               
q[2]:──────────
               



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y─────────P(1.0472)──
                                 
q[2]:────────────*───────────────
                 |               
q[3]:────────────X───────────────
                                 



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────
                                            
q[2]:────────────────────────────────────*──
                                         |  
q[3]:────────────────────────────────────X──
                                            




julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L299-L365">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastSwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastSwapToCZGateTranspiler</code> transpiler stage which expands all Swap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastSwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[swap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──☒──
       |
q[2]:──☒──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────
                |                     |                     |          
q[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──
                                              
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L395-L423">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastCXToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastCZToCZGateTranspiler</code> transpiler stage which expands all CX gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastCXToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──*──
       |
q[2]:──X──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2
q[1]:───────*───────
            |
q[2]:──H────Z────H──</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L454-L480">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastISwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastISwapToCZGateTranspiler</code> transpiler stage which expands all ISwap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastISwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[iswap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──x──
       |
q[2]:──x──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────
                         |                     |                  
q[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──
                                                                  
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L516-L544">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastToffoliToCXGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastToffoliToCXGateTranspiler</code> transpiler stage which expands all Toffoli gates into CX gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastToffoliToCXGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 3, gates=[toffoli(1, 2, 3)])
Quantum Circuit Object:
   qubit_count: 3
q[1]:──*──
       |
q[2]:──*──
       |
q[3]:──X──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──────────────────*────────────────────*──────────────*─────────T──────────*──
                       |                    |              |                    |  
q[2]:───────*──────────|─────────*──────────|────T─────────X──────────────T†────X──
            |          |         |          |                                      
q[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──────────────────
                                                                                   
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L593-L625">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastToPhaseShiftAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastToPhaseShiftAndHalfRotationXTranspiler</code> transpiler stage  which converts all single-qubit gates in an input circuit and converts them  into combinations of PhaseShift and RotationX with angle π/2 in an output  circuit. For any gate in the input circuit, the number of gates in the  output varies between zero and 5. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastToPhaseShiftAndHalfRotationXTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────X_90────Z────X_m90──
                                                 
q[2]:───────────────────────────
                                                 



julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Y──
          
q[2]:─────
          



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z_90────X_90────Z────X_m90────Z_90──
                                           
q[2]:──────────────────────────────────────
                                           



julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L739-L820">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastUniversalToRzRxRzTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastUniversalToRzRxRzTranspiler</code> transpiler stage  which finds Universal gates in an input circuit and converst cast)  them into a sequence of PhaseShift (Rz), RotationX (Rx) and  PhaseShift (Rz) gates in a new circuit. The result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastUniversalToRzRxRzTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,π/2,π/4,π/8)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=1.5708,ϕ=0.7854,λ=0.3927)──
                                      
q[2]:─────────────────────────────────
                                      

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(-1.1781)────Rx(1.5708)────P(2.3562)──
                                              
q[2]:─────────────────────────────────────────
                                              

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0,π/4,0)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.7854,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(-1.5708)────Rx(0.0000)────P(2.3562)──
                                              
q[2]:─────────────────────────────────────────
                                              
                                        
julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L873-L926">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastRxToRzAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastRxToRzAndHalfRotationXTranspiler</code> transpiler stage  which finds RotationX(θ) gates in an input circuit and converts (casts)  them into a sequence of gates: Z90,X90,PhaseShift(θ),XM90,ZM90 in a new circuit. The result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastRxToRzAndHalfRotationXTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,π/8)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(0.3927)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z_90────X_90────P(0.3927)────X_m90────Z_m90──
                                                    
q[2]:───────────────────────────────────────────────
                                                    

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L974-L1007">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::SimplifyRxGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyRxGatesTranspiler</code> transpiler stage  which finds RotationX gates in an input circuit and according to it&#39;s  angle theta, casts them to one of the right-angle RotationX gates,  e.g. SigmaX, X90, or XM90. In the case where theta≈0., the gate is removed. The result of the input and output circuit on any arbitrary state Ket is  unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.SimplifyRxGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(1.5708)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(3.1416)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(0.0000)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L1035-L1111">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::SwapQubitsForLineConnectivityTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SwapQubitsForLineConnectivityTranspiler</code> transpiler stage  which adds Swap gates around multi-qubit gates so that the  final operator acts on adjacent qubits. The result of the input  and output circuit on any arbitrary state Ket is unchanged  (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.SwapQubitsForLineConnectivityTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 6, gates=[toffoli(4,6,1)])
Quantum Circuit Object:
   qubit_count: 6 
q[1]:──X──
       |  
q[2]:──|──
       |  
q[3]:──|──
       |  
q[4]:──*──
       |  
q[5]:──|──
       |  
q[6]:──*──
          




julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 6 
q[1]:───────────────────────────X───────────────────────────
                                |                           
q[2]:───────☒───────────────────*───────────────────☒───────
            |                   |                   |       
q[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──
       |                   |         |                   |  
q[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──
                      |                   |                 
q[5]:────────────☒────☒───────────────────☒────☒────────────
                 |                             |            
q[6]:────────────☒─────────────────────────────☒────────────
                                                            



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L1179-L1233">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::SimplifyRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyRzGatesTranspiler</code> transpiler stage  which finds PhaseShift gates in an input circuit and according to it&#39;s  phase angle phi, casts them to one of the right-angle RotationZ gates,  e.g. SigmaZ, Z90, ZM90, Pi8 or Pi8Dagger. In the case where phi≈0., the  gate is removed. The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyRzGatesTranspiler(1.0e-10)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.SimplifyRzGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(1.5708)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,pi)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(3.1416)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(0.0000)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L1291-L1368">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CompressRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CompressRzGatesTranspiler</code> transpiler stage  which gathers all Rz-type gates sharing a common target in an input  circuit and combines them into single PhaseShift gate in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CompressRzGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_z(1),z_90(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────Z_90──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(-1.5708)──
                   
q[2]:──────────────
                   

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_z(1),pi_8(1),control_x(2,3),z_minus_90(1)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──Z────T─────────Z_m90──
                             
q[2]:────────────*───────────
                 |           
q[3]:────────────X───────────
                             

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──P(2.3562)───────
                       
q[2]:───────────────*──
                    |  
q[3]:───────────────X──
                       

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L1441-L1498">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::RemoveSwapBySwappingGates, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Removes the <code>Swap</code> gates from the <code>circuit</code> assuming all-to-all connectivity.</p><div class="admonition is-warning"><header class="admonition-header">The initial state must be the ground state!</header><div class="admonition-body"><p>This transpiler stage assumes that the input state is <span>$|0\rangle^{\otimes N}$</span> where <span>$N$</span> is the number of qubits. The stage should not be used on sub-circuits where the input state is not <span>$|0\rangle^{\otimes N}$</span>.</p></div></div><p>This transpiler stage eliminates <code>Swap</code> gates by moving the gates preceding each <code>Swap</code> gate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = RemoveSwapBySwappingGates();

julia&gt; circuit = QuantumCircuit(qubit_count=2, gates=[hadamard(1), swap(1,2), sigma_x(2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────☒───────
            |       
q[2]:───────☒────X──
                    



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──────────
               
q[2]:──H────X──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L1515-L1553">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::SimplifyTrivialGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyTrivialGatesTranspiler</code> transpiler stage  which finds gates which have no effect on the state Ket, such as Identity, and  parameterized gates with null parameters such as rotation_x(target, 0.). The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyTrivialGatesTranspiler(1.0e-10)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.SimplifyTrivialGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[identity_gate(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──I──
          
q[2]:─────
          
julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit,transpiled_circuit)
true


julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(0.0000)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                             
julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L1632-L1702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.compare_circuits" href="#Snowflake.compare_circuits"><code>Snowflake.compare_circuits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_circuits(c0::QuantumCircuit,c1::QuantumCircuit)::Bool</code></pre><p>Tests for equivalence of two circuits based on their effect on an  arbitrary input state (a Ket). Circuits are equivalent if they both  yield the same output for any input, up to a global phase. Circuits with different ordering of gates that apply on different  targets can also be equivalent.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c0 = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──X────Y──
               



julia&gt; c1 = QuantumCircuit(qubit_count = 1, gates=[phase_shift(1,π)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──P(3.1416)──
                  



julia&gt; compare_circuits(c0,c1)
true            

julia&gt; c0 = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y───────
                    
q[2]:────────────*──
                 |  
q[3]:────────────X──
                    



julia&gt; c1 = QuantumCircuit(qubit_count = 3, gates=[control_x(2,3),sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:───────X────Y──
                    
q[2]:──*────────────
       |            
q[3]:──X────────────
                    



julia&gt; compare_circuits(c0,c1)
true    
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L222-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.circuit_contains_gate_type" href="#Snowflake.circuit_contains_gate_type"><code>Snowflake.circuit_contains_gate_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circuit_contains_gate_type(circuit::QuantumCircuit, gate_type::Type{&lt;:AbstractGate})::Bool</code></pre><p>Determined whether or not a type of gate is present in a circuit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──X────Y──
               
julia&gt; circuit_contains_gate_type(circuit, Snowflake.SigmaX)
true
               
julia&gt; circuit_contains_gate_type(circuit, Snowflake.ControlZ)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_circuit.jl#L305-L323">source</a></section></article><h2 id="Quantum-Gates"><a class="docs-heading-anchor" href="#Quantum-Gates">Quantum Gates</a><a id="Quantum-Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Gates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.AbstractGate" href="#Snowflake.AbstractGate"><code>Snowflake.AbstractGate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGate</code></pre><p>A <code>Gate</code> is an instantiation of an <code>AbstractGate</code>, which can be added to a <code>QuantumCircuit</code> in order to apply an operator to one or more <code>target</code> qubits. <code>AbstractGate</code> is useful to dispatch all <code>Gates</code> to default implementation of functions such as get<em>connected</em>qubits().  Those functions are then specialized for <code>Gates</code> requiring a different implementation. </p><p><code>AbstractGate</code> is an abstract type, which means that it cannot be instantiated.  Instead, each concrete type of <code>Gate</code> is a struct which is a subtype of <code>AbstractGate</code>. Each descendant of <code>AbstractGate</code> must have at least the following fields:</p><ul><li><code>target::Int</code>: the qubit number to which the <code>Gate</code> is applied. Some gates have multiple targets.</li><li><code>parameter::Real</code>: for parameterized gates, determines which operation is applied (e.g. rotation angles), i.e., is used in the construction of the matrix used in the application of its <code>Operator</code>.</li></ul><p><strong>Examples</strong></p><p>A struct must be defined for each new gate type, such as the following X_45 gate which applies a 45° rotation about the X axis:</p><pre><code class="language-julia-repl hljs">julia&gt; struct X45 &lt;: AbstractGate
           target::Int
       end;
</code></pre><p>For convenience, a constructor can be defined:</p><pre><code class="language-julia-repl hljs">julia&gt; x_45(target::Integer) = X45(target);
</code></pre><p>To simulate the effect of the gate in a <code>QuantumCircuit</code> or when applied to a <code>Ket</code>, the function <code>get_operator</code> must be extended.</p><pre><code class="language-julia-repl hljs">julia&gt; Snowflake.get_operator(gate::X45, T::Type{&lt;:Complex}=ComplexF64) = rotation_x(π/4, T);
</code></pre><p>The gate inverse can also be specified by extending the <code>inv</code> function.</p><pre><code class="language-julia-repl hljs">julia&gt; inv(gate::X45) = rotation_x(gate.target, -π/4);
</code></pre><p>An instance of the X_45 gate can now be created:</p><pre><code class="language-julia-repl hljs">julia&gt; x_45_gate = x_45(1)
Gate Object: X45
Connected_qubits	: [1]
Operator:
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im
0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im


julia&gt; inv(x_45_gate)
Gate Object: Snowflake.RotationX
Parameters: 
theta	: -0.7853981633974483

Connected_qubits	: [1]
Operator:
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.9238795325112867 + 0.0im    -0.0 + 0.3826834323650898im
-0.0 + 0.3826834323650898im    0.9238795325112867 + 0.0im

</code></pre><p>To enable printout of a circuit containing our new gate type, a symbol  must be defined as follows.</p><pre><code class="language-julia-repl hljs">julia&gt; Snowflake.gates_display_symbols[X45]=[&quot;X45&quot;];
</code></pre><p>If this gate is to be sent as an instruction to a hardware QPU,  an instruction string must be defined.</p><pre><code class="language-julia-repl hljs">julia&gt; Snowflake.gates_instruction_symbols[X45]=&quot;x45&quot;;
</code></pre><p>A circuit containing this gate can now be constructed:</p><pre><code class="language-julia-repl hljs">julia&gt; circuit=QuantumCircuit(qubit_count=2,gates=[x_45_gate])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──X45──

q[2]:───────</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.eye" href="#Snowflake.eye"><code>Snowflake.eye</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eye(),
eye(size::Integer)</code></pre><p>Return the identity matrix as a <code>DenseOperator</code>, which is defined as:</p><p class="math-container">\[I = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; 1
    \end{bmatrix}.\]</p><p>Calling eye(size) will produce an identity matrix <code>DenseOperator</code>  of dimensions (size,size).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eye()
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im

julia&gt; eye(4)
(4, 4)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L995-L1028">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.identity_gate" href="#Snowflake.identity_gate"><code>Snowflake.identity_gate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">identity_gate(target)</code></pre><p>Return the Identity <code>Gate</code>, which applies the <a href="library.html#Snowflake.identity_gate"><code>identity_gate()</code></a> <code>IdentityOperator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1837-L1841">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_p" href="#Snowflake.sigma_p"><code>Snowflake.sigma_p</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_p()</code></pre><p>Return the spin-<span>$\frac{1}{2}$</span> raising <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_+ = \begin{bmatrix}
    0 &amp; 1 \\
    0 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L930-L940">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_m" href="#Snowflake.sigma_m"><code>Snowflake.sigma_m</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_m()</code></pre><p>Return the spin-<span>$\frac{1}{2}$</span> lowering <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_- = \begin{bmatrix}
    0 &amp; 0 \\
    1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L943-L953">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_x" href="#Snowflake.sigma_x"><code>Snowflake.sigma_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_x()</code></pre><p>Return the Pauli-X <code>AntiDiagonalOperator</code>, which is defined as:</p><p class="math-container">\[\sigma_x = \begin{bmatrix}
    0 &amp; 1 \\
    1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L891-L901">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_x(target)</code></pre><p>Return the Pauli-X <code>Gate</code>, which applies the <a href="library.html#Snowflake.sigma_x"><code>sigma_x()</code></a> <code>AntiDiagonalOperator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1331-L1335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_y" href="#Snowflake.sigma_y"><code>Snowflake.sigma_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_y()</code></pre><p>Return the Pauli-Y <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_y = \begin{bmatrix}
    0 &amp; -i \\
    i &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L904-L914">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_y(target)</code></pre><p>Return the Pauli-Y <code>Gate</code>, which applies the <a href="library.html#Snowflake.sigma_y"><code>sigma_y()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1362-L1366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_z" href="#Snowflake.sigma_z"><code>Snowflake.sigma_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_z()</code></pre><p>Return the Pauli-Z <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_z = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L917-L927">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_z(target)</code></pre><p>Return the Pauli-Z <code>Gate</code>, which applies the <a href="library.html#Snowflake.sigma_z"><code>sigma_z()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1376-L1380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.hadamard" href="#Snowflake.hadamard"><code>Snowflake.hadamard</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hadamard()</code></pre><p>Return the Hadamard <code>Operator</code>, which is defined as:</p><p class="math-container">\[H = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L956-L966">source</a></section><section><div><pre><code class="nohighlight hljs">hadamard(target)</code></pre><p>Return the Hadamard <code>Gate</code>, which applies the <a href="library.html#Snowflake.hadamard"><code>hadamard()</code></a> <code>Operator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1389-L1393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.pi_8" href="#Snowflake.pi_8"><code>Snowflake.pi_8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pi_8()</code></pre><p>Return the <code>Operator</code> for the π/8 gate, which is defined as:</p><p class="math-container">\[T = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\frac{\pi}{4}}
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L969-L979">source</a></section><section><div><pre><code class="nohighlight hljs">pi_8(target)</code></pre><p>Return a π/8 <code>Gate</code> (also known as a <span>$T$</span> <code>Gate</code>), which applies the <a href="library.html#Snowflake.pi_8"><code>pi_8()</code></a> <code>DiagonalOperator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1402-L1406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.pi_8_dagger" href="#Snowflake.pi_8_dagger"><code>Snowflake.pi_8_dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pi_8_dagger()</code></pre><p>Return the adjoint <code>DiagonalOperator</code> of the π/8 gate, which is defined as:</p><p class="math-container">\[T^\dagger = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; e^{-i\frac{\pi}{4}}
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L982-L992">source</a></section><section><div><pre><code class="nohighlight hljs">pi_8_dagger(target)</code></pre><p>Return an adjoint π/8 <code>Gate</code> (also known as a <span>$T^\dagger$</span> <code>Gate</code>), which applies the <a href="library.html#Snowflake.pi_8_dagger"><code>pi_8_dagger()</code></a> <code>Operator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1418-L1422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.x_90" href="#Snowflake.x_90"><code>Snowflake.x_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x_90()</code></pre><p>Return the <code>Operator</code> which applies a π/2 rotation about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; -i \\
    -i &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1034-L1046">source</a></section><section><div><pre><code class="nohighlight hljs">x_90(target)</code></pre><p>Return a <code>Gate</code> that applies a 90° rotation about the X axis as defined by the <a href="library.html#Snowflake.x_90"><code>x_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1434-L1438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.x_minus_90" href="#Snowflake.x_minus_90"><code>Snowflake.x_minus_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x_minus_90()</code></pre><p>Return the <code>Operator</code> which applies a -π/2 rotation about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x\left(-\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; i \\
    i &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1049-L1061">source</a></section><section><div><pre><code class="nohighlight hljs">x_minus_90(target)</code></pre><p>Return a <code>Gate</code> that applies a -90° rotation about the X axis as defined by the <a href="library.html#Snowflake.x_minus_90"><code>x_minus_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1449-L1453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.y_90" href="#Snowflake.y_90"><code>Snowflake.y_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y_90()</code></pre><p>Return the <code>Operator</code> which applies a π/2 rotation about the Y axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_y\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; -1 \\
    1 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1064-L1076">source</a></section><section><div><pre><code class="nohighlight hljs">y_90(target)</code></pre><p>Return a <code>Gate</code> that applies a 90° rotation about the Y axis as defined by the <a href="library.html#Snowflake.y_90"><code>y_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1464-L1468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.y_minus_90" href="#Snowflake.y_minus_90"><code>Snowflake.y_minus_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y_minus_90()</code></pre><p>Return the <code>Operator</code> which applies a -π/2 rotation about the Y axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_y\left(-\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; 1 \\
    -1 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1079-L1091">source</a></section><section><div><pre><code class="nohighlight hljs">y_minus_90(target)</code></pre><p>Return a <code>Gate</code> that applies a -90° rotation about the Y axis as defined by the <a href="library.html#Snowflake.y_minus_90"><code>y_minus_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1479-L1483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.z_90" href="#Snowflake.z_90"><code>Snowflake.z_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">z_90()</code></pre><p>Return the <code>Operator</code> which applies a π/2 rotation about the Z axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_z\left(\frac{\pi}{2}\right) = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; i
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1094-L1106">source</a></section><section><div><pre><code class="nohighlight hljs">z_90(target)</code></pre><p>Return a <code>Gate</code> that applies a 90° rotation about the Z axis as defined by the <a href="library.html#Snowflake.z_90"><code>z_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1494-L1498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.z_minus_90" href="#Snowflake.z_minus_90"><code>Snowflake.z_minus_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">z_minus_90()</code></pre><p>Return the <code>Operator</code> which applies a -π/2 rotation about the Z axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_z\left(-\frac{\pi}{2}\right) = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; -i
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1109-L1121">source</a></section><section><div><pre><code class="nohighlight hljs">z_minus_90(target)</code></pre><p>Return a <code>Gate</code> that applies a -90° rotation about the Z axis as defined by the <a href="library.html#Snowflake.z_minus_90"><code>z_minus_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1509-L1513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation" href="#Snowflake.rotation"><code>Snowflake.rotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation(theta, phi)</code></pre><p>Return the <code>Operator</code> which applies a rotation <code>theta</code> about the cos(<code>phi</code>)X+sin(<code>phi</code>)Y axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R(\theta, \phi) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -i e^{-i\phi} \mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    -i e^{i\phi} \mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1124-L1138">source</a></section><section><div><pre><code class="nohighlight hljs">rotation(target, theta, phi)</code></pre><p>Return a gate that applies a rotation <code>theta</code> to the <code>target</code> qubit about the cos(<code>phi</code>)X+sin(<code>phi</code>)Y axis.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.rotation"><code>rotation(theta, phi)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1525-L1531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation_x" href="#Snowflake.rotation_x"><code>Snowflake.rotation_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_x(theta)</code></pre><p>Return the <code>Operator</code> which applies a rotation <code>theta</code> about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x(\theta) = \begin{bmatrix}
\mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
    -i\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
-i\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
    \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1144-L1158">source</a></section><section><div><pre><code class="nohighlight hljs">rotation_x(target, theta)</code></pre><p>Return a <code>Gate</code> that applies a rotation <code>theta</code> about the X axis of the <code>target</code> qubit.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.rotation_x"><code>rotation_x(theta)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1552-L1558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation_y" href="#Snowflake.rotation_y"><code>Snowflake.rotation_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_y(theta)</code></pre><p>Return the <code>Operator</code> that applies a rotation <code>theta</code> about the Y axis of the <code>target</code> qubit.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_y(\theta) = \begin{bmatrix}
\mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
    -\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
    \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1161-L1175">source</a></section><section><div><pre><code class="nohighlight hljs">rotation_y(target, theta)</code></pre><p>Return a <code>Gate</code> that applies a rotation <code>theta</code> about the Y axis of the <code>target</code> qubit.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.rotation_y"><code>rotation_y(theta)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1572-L1578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.phase_shift" href="#Snowflake.phase_shift"><code>Snowflake.phase_shift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase_shift(phi)</code></pre><p>Return the <code>DiagonalOperator</code> that applies a phase shift <code>phi</code>.</p><p>The <code>DiagonalOperator</code> is defined as:</p><p class="math-container">\[P(\phi) = \begin{bmatrix}
    1 &amp; 0 \\[0.5em]      
    0 &amp; e^{i\phi}
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1178-L1190">source</a></section><section><div><pre><code class="nohighlight hljs">phase_shift(target, phi)</code></pre><p>Return a <code>Gate</code> that applies a phase shift <code>phi</code> to the <code>target</code> qubit as defined by the <a href="library.html#Snowflake.phase_shift"><code>phase_shift(phi)</code></a> <code>DiagonalOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1592-L1596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.universal" href="#Snowflake.universal"><code>Snowflake.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">universal(theta, phi, lambda)</code></pre><p>Return the <code>Operator</code> which performs a rotation about the angles <code>theta</code>, <code>phi</code>, and <code>lambda</code>. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[U(\theta, \phi, \lambda) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -e^{i\lambda}\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    e^{i\phi}\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        e^{i\left(\phi+\lambda\right)}\mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1193-L1208">source</a></section><section><div><pre><code class="nohighlight hljs">universal(target, theta, phi, lambda)</code></pre><p>Return a gate which rotates the <code>target</code> qubit given the angles <code>theta</code>, <code>phi</code>, and <code>lambda</code>. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.universal"><code>universal(theta, phi, lambda)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1610-L1617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.control_z" href="#Snowflake.control_z"><code>Snowflake.control_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control_z()</code></pre><p>Return the controlled-Z <code>Operator</code>, which is defined as:</p><p class="math-container">\[CZ = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1236-L1248">source</a></section><section><div><pre><code class="nohighlight hljs">control_z(control_qubit, target_qubit)</code></pre><p>Return a controlled-Z gate given a <code>control_qubit</code> and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.control_z"><code>control_z()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1640-L1646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.control_x" href="#Snowflake.control_x"><code>Snowflake.control_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control_x()</code></pre><p>Return the controlled-X (or controlled NOT) <code>Operator</code>, which is defined as:</p><p class="math-container">\[CX = CNOT = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1214-L1226">source</a></section><section><div><pre><code class="nohighlight hljs">control_x(control_qubit, target_qubit)</code></pre><p>Return a controlled-X gate (also known as a controlled NOT gate) given a <code>control_qubit</code> and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.control_x"><code>control_x()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1685-L1691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.iswap" href="#Snowflake.iswap"><code>Snowflake.iswap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswap()</code></pre><p>Return the imaginary swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; i &amp; 0 \\
    0 &amp; i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1258-L1270">source</a></section><section><div><pre><code class="nohighlight hljs">iswap(qubit_1, qubit_2)</code></pre><p>Return the imaginary swap <code>Gate</code> which applies the imaginary swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.iswap"><code>iswap()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1710-L1716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.swap" href="#Snowflake.swap"><code>Snowflake.swap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swap()</code></pre><p>Return the swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1273-L1285">source</a></section><section><div><pre><code class="nohighlight hljs">swap(qubit_1, qubit_2)</code></pre><p>Return the swap <code>Gate</code> which applies the swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.swap"><code>swap()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1733-L1739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.toffoli" href="#Snowflake.toffoli"><code>Snowflake.toffoli</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">toffoli()</code></pre><p>Return the Toffoli <code>Operator</code>, which is defined as:</p><p class="math-container">\[CCX = CCNOT = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1288-L1304">source</a></section><section><div><pre><code class="nohighlight hljs">toffoli(control_qubit_1, control_qubit_2, target_qubit)</code></pre><p>Return a Toffoli gate (also known as a CCNOT gate) given two control qubits and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.toffoli"><code>toffoli()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1754-L1760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.iswap_dagger" href="#Snowflake.iswap_dagger"><code>Snowflake.iswap_dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswap_dagger()</code></pre><p>Return the adjoint of the imaginary swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP^\dagger = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; -i &amp; 0 \\
    0 &amp; -i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1316-L1328">source</a></section><section><div><pre><code class="nohighlight hljs">iswap_dagger(qubit_1, qubit_2)</code></pre><p>Return the adjoint imaginary swap <code>Gate</code> which applies the adjoint imaginary swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.iswap_dagger"><code>iswap_dagger()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1814-L1820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractGate, Ket}" href="#Base.:*-Tuple{AbstractGate, Ket}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(M::AbstractGate, x::Ket)</code></pre><p>Return a <code>Ket</code> which results from applying <code>Gate</code> <code>M</code> to <code>Ket</code> <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = fock(0, 2)
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ_1 = sigma_x(1)*ψ_0
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1852-L1872">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.apply_gate!" href="#Snowflake.apply_gate!"><code>Snowflake.apply_gate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_gate!(state::Ket, gate::Gate)</code></pre><p>Update the <code>state</code> by applying a <code>gate</code> to it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = fock(0, 2)
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; apply_gate!(ψ_0, sigma_x(1))

julia&gt; print(ψ_0)
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L286-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_operator" href="#Snowflake.get_operator"><code>Snowflake.get_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_operator(gate::Gate)</code></pre><p>Returns the <code>Operator</code> which is associated to a <code>Gate</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = sigma_x(1);

julia&gt; get_operator(x)
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1342-L1359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{AbstractGate}" href="#Base.inv-Tuple{AbstractGate}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(gate::AbstractGate)</code></pre><p>Return a <code>Gate</code> which is the inverse of the input <code>gate</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = universal(1, -pi/2, pi/3, pi/4)
Gate Object: Snowflake.Universal
Parameters: 
theta	: -1.5707963267948966
phi	: 1.0471975511965976
lambda	: 0.7853981633974483

Connected_qubits	: [1]
Operator:
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.7071067811865476 + 0.0im    0.5 + 0.4999999999999999im
-0.3535533905932738 - 0.6123724356957945im    -0.18301270189221924 + 0.6830127018922194im


julia&gt; inv(u)
Gate Object: Snowflake.Universal
Parameters: 
theta	: 1.5707963267948966
phi	: -0.7853981633974483
lambda	: -1.0471975511965976

Connected_qubits	: [1]
Operator:
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.7071067811865476 + 0.0im    -0.3535533905932738 + 0.6123724356957945im
0.5 - 0.4999999999999999im    -0.18301270189221924 - 0.6830127018922194im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L1881-L1919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.is_gate_type" href="#Snowflake.is_gate_type"><code>Snowflake.is_gate_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_gate_type(gate::AbstractGate, type::Type)::Bool</code></pre><p>Determines if a <code>gate</code> is of the specified <code>type</code>.</p><div class="admonition is-warning"><header class="admonition-header">Use is_gate_type instead of isa!</header><div class="admonition-body"><p>For <code>AbstractGate</code> objects, <code>is_gate_type</code> should be used instead of <code>isa</code>. The utilization of <code>isa</code> could lead to unexpected behavior (e.g. if a gate has been moved).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gate = sigma_x(1)
Gate Object: Snowflake.SigmaX
Connected_qubits	: [1]
Operator:
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; is_gate_type(gate, Snowflake.SigmaX)
true

julia&gt; is_gate_type(gate, Snowflake.SigmaY)
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L104-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_gate_type" href="#Snowflake.get_gate_type"><code>Snowflake.get_gate_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_gate_type(gate::AbstractGate)::Type</code></pre><p>Returns the type of a <code>gate</code>.</p><div class="admonition is-warning"><header class="admonition-header">Use get_gate_type instead of typeof!</header><div class="admonition-body"><p>For <code>AbstractGate</code> objects, <code>get_gate_type</code> should be used instead of <code>typeof</code>. The utilization of <code>typeof</code> could lead to unexpected behavior (e.g. if a gate has been moved).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gate = sigma_x(1)
Gate Object: Snowflake.SigmaX
Connected_qubits	: [1]
Operator:
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; get_gate_type(gate)
Snowflake.SigmaX
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L135-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.move_gate" href="#Snowflake.move_gate"><code>Snowflake.move_gate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">move_gate(gate::AbstractGate,
    qubit_mapping::AbstractDict{&lt;:Integer,&lt;:Integer})::AbstractGate</code></pre><p>Returns a copy of <code>gate</code> where the qubits on which the <code>gate</code> acts have been updated based on <code>qubit_mapping</code>.</p><p>The dictionary <code>qubit_mapping</code> contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gate = sigma_x(1)
Gate Object: Snowflake.SigmaX
Connected_qubits	: [1]
Operator:
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; move_gate(gate, Dict(1=&gt;2))
Gate Object: Snowflake.SigmaX
Connected_qubits	: [2]
Operator:
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/quantum_gate.jl#L223-L257">source</a></section></article><h2 id="Quantum-Processing-Unit"><a class="docs-heading-anchor" href="#Quantum-Processing-Unit">Quantum Processing Unit</a><a id="Quantum-Processing-Unit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Processing-Unit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.AnyonQPU" href="#Snowflake.AnyonQPU"><code>Snowflake.AnyonQPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnyonQPU</code></pre><p>A data structure to represent a Anyon System&#39;s QPU.  </p><p><strong>Fields</strong></p><ul><li><code>client       ::Client</code> – Client to the QPU server.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt;  qpu = AnyonQPU(host=&quot;example.anyonsys.com&quot;,user=&quot;test_user&quot;,access_token=&quot;not_a_real_access_token&quot;)
Quantum Processing Unit:
   manufacturer:  Anyon Systems Inc.
   generation:    Yukon
   serial_number: ANYK202201
   qubit_count:   6 
   connectivity_type:  linear</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/anyon.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.VirtualQPU" href="#Snowflake.VirtualQPU"><code>Snowflake.VirtualQPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VirtualQPU</code></pre><p>A data structure to represent a Quantum Simulator.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=VirtualQPU()
Quantum Simulator:
   developers:  Anyon Systems Inc.
   package:     Snowflake.jl

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/qpu_interface.jl#L348-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Client" href="#Snowflake.Client"><code>Snowflake.Client</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Client</code></pre><p>A data structure to represent a <em>Client</em> to a QPU service.  </p><p><strong>Fields</strong></p><ul><li><code>host::String</code> – URL of the QPU server.</li><li><code>user::String</code> – Username.</li><li><code>access_token::String</code> – User access token.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Client(host=&quot;http://example.anyonsys.com&quot;,user=&quot;test_user&quot;,access_token=&quot;not_a_real_access_token&quot;)
Client for QPU service:
   host:         http://example.anyonsys.com
   user:         test_user 
 
  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/qpu_interface.jl#L155-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_host" href="#Snowflake.get_host"><code>Snowflake.get_host</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_host(Client)</code></pre><p>Returns host URL of a <code>Client</code> to a <code>QPU</code> service.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Client(host=&quot;http://example.anyonsys.com&quot;,user=&quot;test_user&quot;,access_token=&quot;not_a_real_access_token&quot;);

julia&gt; get_host(c)
&quot;http://example.anyonsys.com&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/qpu_interface.jl#L187-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.submit_circuit" href="#Snowflake.submit_circuit"><code>Snowflake.submit_circuit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">submit_circuit(client::Client,circuit::QuantumCircuit,num_repetitions::Integer)</code></pre><p>Submit a circuit to a <code>Client</code> of <code>QPU</code> service, requesting a number of  repetitions (num_repetitions). Returns circuitID.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/qpu_interface.jl#L205-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_status" href="#Snowflake.get_status"><code>Snowflake.get_status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_status(client::Client,circuitID::String)::Dict{String, String}</code></pre><p>Obtain the status of a circuit computation through a <code>Client</code> of a <code>QPU</code> service. Returns status::Dict containing status[&quot;type&quot;]:      -&quot;queued&quot;   : Computation in queue.     -&quot;running&quot;  : Computation being processed.     -&quot;failed&quot;   : QPU service has returned an error message.     -&quot;succeeded&quot;: Computation is completed, result is available.</p><p>In the case of status[&quot;type&quot;]==&quot;failed&quot;, the server error is contained in status[&quot;message&quot;].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;

julia&gt; get_status(client,circuitID)
Status: succeeded
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/qpu_interface.jl#L238-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_result" href="#Snowflake.get_result"><code>Snowflake.get_result</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_result(client::Client,circuit::String)::Dict{String, Int}</code></pre><p>Get the histogram of a completed circuit calculation, through a <code>Client</code> of a <code>QPU</code> service,  by circuit identifier circuitID.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;

julia&gt; get_status(client,circuitID);

julia&gt; get_result(client,circuitID)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/qpu_interface.jl#L288-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.run_job" href="#Snowflake.run_job"><code>Snowflake.run_job</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_job(qpu::VirtualQPU, circuit::QuantumCircuit,num_repetitions::Integer)</code></pre><p>Run a circuit computation on a <code>QPU</code> simulator, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=VirtualQPU();

julia&gt; run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/qpu_interface.jl#L432-L448">source</a></section><section><div><pre><code class="nohighlight hljs">run_job(qpu::AnyonQPU, circuit::QuantumCircuit,num_repetitions::Integer)</code></pre><p>Run a circuit computation on a <code>QPU</code> service, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations, or an error message.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=AnyonQPU(client);

julia&gt; run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/anyon.jl#L148-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.transpile_and_run_job" href="#Snowflake.transpile_and_run_job"><code>Snowflake.transpile_and_run_job</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transpile_and_run_job(qpu::VirtualQPU, circuit::QuantumCircuit,num_repetitions::Integer;transpiler::Transpiler=get_transpiler(qpu))</code></pre><p>This method first transpiles the input circuit using either the default transpiler,  or any other transpiler passed as a key-word argument.   The transpiled circuit is then run on a <code>QPU</code> simulator, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations, or an error message.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=VirtualQPU();

julia&gt; transpile_and_run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/qpu_interface.jl#L399-L417">source</a></section><section><div><pre><code class="nohighlight hljs">transpile_and_run_job(qpu::AnyonQPU, circuit::QuantumCircuit,num_repetitions::Integer;transpiler::Transpiler=get_transpiler(qpu))</code></pre><p>This method first transpiles the input circuit using either the default transpiler,  or any other transpiler passed as a key-word argument.   The transpiled circuit is then run on the AnyonQPU, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations, or an error message.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=AnyonQPU(client_anyon);

julia&gt; transpile_and_run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/anyon.jl#L109-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_transpiler" href="#Snowflake.get_transpiler"><code>Snowflake.get_transpiler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_transpiler(qpu::AnyonQPU)::Transpiler</code></pre><p>Returns the transpiler associated with this QPU.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=AnyonQPU(client);

julia&gt; get_transpiler(qpu)
SequentialTranspiler(Transpiler[CastToffoliToCXGateTranspiler(), CastCXToCZGateTranspiler(), CastISwapToCZGateTranspiler(), SwapQubitsForLineConnectivityTranspiler(), CastSwapToCZGateTranspiler(), CompressSingleQubitGatesTranspiler(), SimplifyTrivialGatesTranspiler(1.0e-6), CastUniversalToRzRxRzTranspiler(), SimplifyRxGatesTranspiler(1.0e-6), CastRxToRzAndHalfRotationXTranspiler(), CompressRzGatesTranspiler(), SimplifyRzGatesTranspiler(1.0e-6)])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/anyon/anyon.jl#L211-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.SequentialTranspiler" href="#Snowflake.SequentialTranspiler"><code>Snowflake.SequentialTranspiler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SequentialTranspiler(Vector{&lt;:Transpiler})</code></pre><p>Composite transpiler object which is constructed from an array  of Transpiler stages. Calling      <code>transpile(::SequentialTranspiler,::QuantumCircuit)</code>` will apply each stage in sequence to the input circuit, and return a transpiled output circuit. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.SequentialTranspiler([Snowflake.CompressSingleQubitGatesTranspiler(),Snowflake.CastToPhaseShiftAndHalfRotationXTranspiler()]);

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),hadamard(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X────H──
               
q[2]:──────────
               



julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────X_90────Z_90────X_m90────Z──
                                                              
q[2]:───────────────────────────────────
                                                              



julia&gt; circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y─────────P(1.0472)──  

q[2]:────────────*───────────────
                 |               
q[3]:────────────X───────────────
                                 



julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──P(-2.0944)───────
                        
q[2]:────────────────*──
                     |  
q[3]:────────────────X──
                        


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/transpile.jl#L8-L67">source</a></section></article><h2 id="Quantum-Toolkit"><a class="docs-heading-anchor" href="#Quantum-Toolkit">Quantum Toolkit</a><a id="Quantum-Toolkit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Toolkit" title="Permalink"></a></h2><h3 id="Basic-Quantum-Objects"><a class="docs-heading-anchor" href="#Basic-Quantum-Objects">Basic Quantum Objects</a><a id="Basic-Quantum-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Quantum-Objects" title="Permalink"></a></h3><p>There are three basic quantum objects in Snowflake to simulate a quantum system. These objects are Ket, Bra, and AbstractOperator.</p><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Ket" href="#Snowflake.Ket"><code>Snowflake.Ket</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Ket represents a <em>quantum wavefunction</em> and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.  </p><p><strong>Examples</strong></p><p>Although NOT the preferred way, one can directly build a Ket object by passing a column vector as the initializer. </p><pre><code class="language-julia-repl hljs">julia&gt; using Snowflake

julia&gt; ψ = Ket([1.0; 0.0; 0.0])
3-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im

</code></pre><p>A better way to initialize a Ket is to use a pre-built basis such as the <code>fock</code> basis. See <a href="library.html#Snowflake.fock"><code>fock</code></a> for further information on this function. </p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(2, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Bra" href="#Snowflake.Bra"><code>Snowflake.Bra</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a Bra (i.e. a row vector of complex values). A Bra is created as the complex conjugate of a Ket.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(1, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; _ψ = Bra(ψ)
3-element Bra{ComplexF64}:
0.0 - 0.0im
1.0 - 0.0im
0.0 - 0.0im


julia&gt; _ψ * ψ    # A Bra times a Ket is a scalar
1.0 + 0.0im

julia&gt; ψ*_ψ     # A Ket times a Bra is an operator
(3, 3)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L106-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.DiagonalOperator" href="#Snowflake.DiagonalOperator"><code>Snowflake.DiagonalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a diagonal quantum <code>Operator</code> (i.e. a complex matrix, with non-zero elements all lying on the diagonal).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = DiagonalOperator([1.0,-1.0])
(2,2)-element Snowflake.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 0.0im    .
.    -1.0 + 0.0im

julia&gt; z = DiagonalOperator([1.0+im,1.0,1.0,0.0-im])
(4,4)-element Snowflake.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 1.0im    .    .    .
.    1.0 + 0.0im    .    .
.    .    1.0 + 0.0im    .
.    .    .    0.0 - 1.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L265-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.AntiDiagonalOperator" href="#Snowflake.AntiDiagonalOperator"><code>Snowflake.AntiDiagonalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a anti-diagonal quantum <code>Operator</code> (i.e. a complex matrix, with non-zero elements all lying on the cross-diagonal).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; AntiDiagonalOperator([1,2])
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    2.0 + 0.0im    .
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L308-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.DenseOperator" href="#Snowflake.DenseOperator"><code>Snowflake.DenseOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a quantum operator with a full (dense) matrix representation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = DenseOperator([1.0 0.0;0.0 -1.0])
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    -1.0 + 0.0im
</code></pre><p>Alternatively:</p><pre><code class="language-julia-repl hljs">julia&gt; z = rotation(π/2,-π/4)  
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.7071067811865476 + 0.0im    0.4999999999999999 - 0.5im
-0.4999999999999999 - 0.5im    0.7071067811865476 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L155-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.adjoint(x)</code></pre><p>Compute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L358-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.is_hermitian" href="#Snowflake.is_hermitian"><code>Snowflake.is_hermitian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_hermitian(A::AbstractOperator)</code></pre><p>Determine if Operator <code>A</code> is Hermitian (i.e. self-adjoint).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = sigma_y()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; is_hermitian(Y)
true

julia&gt; P = sigma_p()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    0.0 + 0.0im    .


julia&gt; is_hermitian(P)
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L375-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{AbstractOperator}" href="#Base.exp-Tuple{AbstractOperator}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(A::AbstractOperator)</code></pre><p>Compute the matrix exponential of <code>Operator</code> <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = sigma_x()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; x_rotation_90_deg = exp(-im*π/4*X)
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.7071067811865475 + 0.0im    0.0 - 0.7071067811865475im
0.0 - 0.7071067811865475im    0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L479-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractOperator, Int64, Int64}" href="#Base.getindex-Tuple{AbstractOperator, Int64, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getindex(A::AbstractOperator, i::Integer, j::Integer)</p><p>Access the element at row i and column j in the matrix corresponding to <code>Operator</code> <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = sigma_y()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; Y[1,1]
0.0 + 0.0im

julia&gt; Y[1,2]
0.0 - 1.0im

julia&gt; Y[2,1]
0.0 + 1.0im

julia&gt; Y[2,2]
0.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L234-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.eigen" href="#LinearAlgebra.eigen"><code>LinearAlgebra.eigen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigen(A::AbstractOperator)</code></pre><p>Compute the eigenvalue decomposition of Operator <code>A</code> and return an <code>Eigen</code> factorization object <code>F</code>. Eigenvalues are found in <code>F.values</code> while eigenvectors are found in the matrix <code>F.vectors</code>. Each column of this matrix corresponds to an eigenvector. The <code>i</code>th eigenvector is extracted by calling <code>F.vectors[:, i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = sigma_x()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

julia&gt; F = eigen(X);

julia&gt; eigenvalues = F.values
2-element Vector{Float64}:
 -1.0
  1.0

julia&gt; eigenvector_1 = F.vectors[:, 1]
2-element Vector{ComplexF64}:
 -0.7071067811865475 + 0.0im
  0.7071067811865475 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L508-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.tr" href="#LinearAlgebra.tr"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tr(A::AbstractOperator)</code></pre><p>Compute the trace of Operator <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; I = eye()
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im


julia&gt; trace = tr(I)
2.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L542-L560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.expected_value" href="#Snowflake.expected_value"><code>Snowflake.expected_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expected_value(A::AbstractOperator, psi::Ket)</code></pre><p>Compute the expectation value ⟨<code>ψ</code>|<code>A</code>|<code>ψ</code>⟩ given Operator <code>A</code> and Ket |<code>ψ</code>⟩.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([0.0; 1.0])
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; A = sigma_z()
(2,2)-element Snowflake.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 0.0im    .
.    -1.0 + 0.0im


julia&gt; expected_value(A, ψ)
-1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L565-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kron(x, y)</code></pre><p>Compute the Kronecker product of two <a href="library.html#Snowflake.Ket"><code>Kets</code></a> or two  <a href="library.html#Snowflake.DenseOperator"><code>DenseOperator</code></a> , <a href="library.html#Snowflake.DiagonalOperator"><code>DiagonalOperator</code></a>, <a href="library.html#Snowflake.AntiDiagonalOperator"><code>AntiDiagonalOperator</code></a>. More details about the Kronecker product can be found <a href="https://en.wikipedia.org/wiki/Kronecker_product">here</a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = Ket([0.0; 1.0])
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; ψ_1 = Ket([1.0; 0.0])
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ_0_1 = kron(ψ_0, ψ_1)
4-element Ket{ComplexF64}:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; kron(sigma_x(), sigma_y())
(4, 4)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L606-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.MultiBodySystem" href="#Snowflake.MultiBodySystem"><code>Snowflake.MultiBodySystem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a quantum multi-body system.</p><p><strong>Fields</strong></p><ul><li><code>hilbert_space_structure</code> – a vector of integers specifying the local Hilbert space size for each &quot;body&quot; within the multi-body system. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L654-L658">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.commute" href="#Snowflake.commute"><code>Snowflake.commute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">commute(A::AbstractOperator, B::AbstractOperator)</code></pre><p>Returns the commutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = sigma_x()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; σ_y = sigma_y()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; commute(σ_x,σ_y)
(2,2)-element Snowflake.DiagonalOperator:
Underlying data type: ComplexF64:
0.0 + 2.0im    .
.    0.0 - 2.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1311-L1337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.anticommute" href="#Snowflake.anticommute"><code>Snowflake.anticommute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">anticommute(A::AbstractOperator, B::AbstractOperator)</code></pre><p>Returns the anticommutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = sigma_x()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; anticommute(σ_x,σ_x)
(2,2)-element Snowflake.DiagonalOperator:
Underlying data type: ComplexF64:
2.0 + 0.0im    .
.    2.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1341-L1360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize!(x::Ket)</code></pre><p>Normalizes Ket <code>x</code> such that its magnitude becomes unity.</p><pre><code class="language-julia-repl hljs">julia&gt; ψ=Ket([1.,2.,4.])
3-element Ket{ComplexF64}:
1.0 + 0.0im
2.0 + 0.0im
4.0 + 0.0im

julia&gt; normalize!(ψ)
3-element Ket{ComplexF64}:
0.2182178902359924 + 0.0im
0.4364357804719848 + 0.0im
0.8728715609439696 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1132-L1151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T&lt;:Real" href="#Snowflake.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T&lt;:Real"><code>Snowflake.get_measurement_probabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_measurement_probabilities(x::Ket{Complex{T}},
    [target_bodies::Vector{U},
    hspace_size_per_body::Union{U,Vector{U}}=2])::AbstractVector{T}
    where {T&lt;:Real, U&lt;:Integer}</code></pre><p>Returns a vector listing the measurement probabilities of the <code>target_bodies</code> of <code>Ket</code> <code>x</code>.</p><p>The Hilbert space size per body can be specified by providing a <code>Vector</code> of <code>Integer</code> for the <code>hspace_size_per_body</code> argument. The <code>Vector</code> must specify the Hilbert space size for each body. If the space size is uniform, a single <code>Integer</code> can be given instead. If only <code>x</code> is provided, the probabilities are provided for all the bodies.</p><p>The measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit <code>Ket</code>, the probabilities are listed for 00, 01, 10, and 11.</p><p><strong>Examples</strong></p><p>The following example constructs a <code>Ket</code>, where the probability of measuring 00 is 50% and the probability of measuring 10 is also 50%.</p><pre><code class="language-julia-repl hljs">julia&gt; ψ = 1/sqrt(2)*Ket([1, 0, 1, 0])
4-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im
0.0 + 0.0im


julia&gt; get_measurement_probabilities(ψ)
4-element Vector{Float64}:
 0.4999999999999999
 0.0
 0.4999999999999999
 0.0
</code></pre><p>For the same <code>Ket</code>, the probability of measuring qubit 2 and finding 0 is 100%.</p><pre><code class="language-julia-repl hljs">julia&gt; target_qubit = [2];

julia&gt; get_measurement_probabilities(ψ, target_qubit)
2-element Vector{Float64}:
 0.9999999999999998
 0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1158-L1205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.ket2dm" href="#Snowflake.ket2dm"><code>Snowflake.ket2dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ket2dm(ψ::Ket)</code></pre><p>Returns the density matrix corresponding to the pure state ψ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1364-L1368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.fock_dm" href="#Snowflake.fock_dm"><code>Snowflake.fock_dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fock_dm(i::Int64, hspace_size::Int64)</code></pre><p>Returns the density matrix corresponding to the Fock base <code>i</code> defined in a Hilbert space of size <code>hspace_size</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; dm=fock_dm(0,2)
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1373-L1388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.wigner" href="#Snowflake.wigner"><code>Snowflake.wigner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wigner(ρ::AbstractOperator, p::Real, q::Real)</code></pre><p>Computes the Wigner function of the density matrix <code>ρ</code> at the point (<code>p</code>,<code>q</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Printf

julia&gt; alpha = 0.25;

julia&gt; hspace_size = 8;

julia&gt; Ψ = coherent(alpha, hspace_size);

julia&gt; prob = wigner(ket2dm(Ψ), 0, 0);

julia&gt; @printf &quot;prob: %.6f&quot; prob
prob: -0.561815</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1391-L1410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.moyal" href="#Snowflake.moyal"><code>Snowflake.moyal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moyal(m, n)</code></pre><p>Returns the Moyal function <code>w_mn(eta)</code> for Fock states <code>m</code> and <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1427-L1433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.genlaguerre" href="#Snowflake.genlaguerre"><code>Snowflake.genlaguerre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlaguerre(x, alpha, n)</code></pre><p>Returns the generalized Laguerre polynomial of degree <code>n</code> for <code>x</code> using a recursive method. See <a href="https://en.wikipedia.org/wiki/Laguerre_polynomials">https://en.wikipedia.org/wiki/Laguerre_polynomials</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1441-L1446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_embed_operator" href="#Snowflake.get_embed_operator"><code>Snowflake.get_embed_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_embed_operator(op::DenseOperator, target_body_index::Int, system::MultiBodySystem)</code></pre><p>Uses a local operator (<code>op</code>), which is defined for a particular body (e.g. qubit) with index <code>target_body_index</code>, to build the corresponding operator for the Hilbert space of the multi-body system given by <code>system</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; system = MultiBodySystem(3,2)
Snowflake.Multibody system with 3 bodies
   Hilbert space structure:
   [2, 2, 2]

julia&gt; x = sigma_x()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

julia&gt; X_1=get_embed_operator(x,1,system)
(8, 8)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L676-L707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_qubits-Tuple{AbstractOperator}" href="#Snowflake.get_num_qubits-Tuple{AbstractOperator}"><code>Snowflake.get_num_qubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::AbstractOperator)</code></pre><p>Returns the number of qubits associated with an <code>Operator</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = DenseOperator([1. 0.
                     0. 0.])
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im

julia&gt; get_num_qubits(ρ)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L848-L865">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_qubits-Tuple{Union{Bra, Ket}}" href="#Snowflake.get_num_qubits-Tuple{Union{Bra, Ket}}"><code>Snowflake.get_num_qubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::Union{Ket, Bra})</code></pre><p>Returns the number of qubits associated with a <code>Ket</code> or a <code>Bra</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1., 0., 0., 0.])
4-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; get_num_qubits(ψ)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L879-L897">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_bodies" href="#Snowflake.get_num_bodies"><code>Snowflake.get_num_bodies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)</code></pre><p>Returns the number of bodies associated with an <code>Operator</code> given the <code>hilbert_space_size_per_body</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = DenseOperator([1. 0. 0.
                     0. 0. 0.
                     0. 0. 0.])
(3, 3)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

julia&gt; get_num_bodies(ρ, 3)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L907-L927">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_bodies" href="#Snowflake.get_num_bodies"><code>Snowflake.get_num_bodies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)</code></pre><p>Returns the number of bodies associated with a <code>Ket</code> or a <code>Bra</code> given the <code>hilbert_space_size_per_body</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1., 0., 0., 0., 0., 0., 0., 0., 0.])
9-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; get_num_bodies(ψ, 3)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L941-L965">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.fock" href="#Snowflake.fock"><code>Snowflake.fock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fock(i, hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>i</code>th fock basis of a Hilbert space with size <code>hspace_size</code> as a Ket.</p><p>The Ket contains values of type <code>T</code>, which by default is ComplexF64.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(0, 3)
3-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ = fock(1, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ = fock(1, 3,ComplexF32) # specifying a type other than ComplexF64
3-element Ket{ComplexF32}:
0.0f0 + 0.0f0im
1.0f0 + 0.0f0im
0.0f0 + 0.0f0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L975-L1003">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.spin_up" href="#Snowflake.spin_up"><code>Snowflake.spin_up</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spin_up(T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>Ket</code> representation of the spin-up state.</p><p>The <code>Ket</code> stores values of type <code>T</code>, which is <code>ComplexF64</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = spin_up()
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1010-L1026">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.spin_down" href="#Snowflake.spin_down"><code>Snowflake.spin_down</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spin_down(T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>Ket</code> representation of the spin-down state.</p><p>The <code>Ket</code> stores values of type <code>T</code>, which is <code>ComplexF64</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = spin_down()
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1029-L1045">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.create" href="#Snowflake.create"><code>Snowflake.create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the bosonic creation operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1048-L1052">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.destroy" href="#Snowflake.destroy"><code>Snowflake.destroy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">destroy(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the bosonic annhilation operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1061-L1065">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.number_op" href="#Snowflake.number_op"><code>Snowflake.number_op</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">number_op(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the number operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1074-L1078">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.coherent" href="#Snowflake.coherent"><code>Snowflake.coherent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coherent(alpha, hspace_size)</code></pre><p>Returns a coherent state for the parameter <code>alpha</code> in a Fock space of size <code>hspace_size</code>. Note that |alpha|^2 is equal to the photon number of the coherent state. </p><pre><code class="nohighlight hljs"># Examples</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ψ = coherent(2.0,20)
20-element Ket{ComplexF64}:
0.1353352832366127 + 0.0im
0.2706705664732254 + 0.0im
0.3827859860416437 + 0.0im
0.44200318416631873 + 0.0im
0.44200318416631873 + 0.0im
0.3953396664268989 + 0.0im
0.3227934859426707 + 0.0im
0.24400893961026582 + 0.0im
0.17254037586855772 + 0.0im
0.11502691724570517 + 0.0im
0.07274941014482605 + 0.0im
0.043869544940011405 + 0.0im
0.025328093580341972 + 0.0im
0.014049498479026656 + 0.0im
0.007509772823502764 + 0.0im
0.003878030010563634 + 0.0im
0.001939015005281817 + 0.0im
0.000940560432521708 + 0.0im
0.0004433844399679012 + 0.0im
0.00020343873336404819 + 0.0im


julia&gt; expected_value(number_op(20),ψ)
3.99999979364864 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L1087-L1122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sesolve" href="#Snowflake.sesolve"><code>Snowflake.sesolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sesolve(H::AbstractOperator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{AbstractOperator}=(AbstractOperator)[])
sesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[])</code></pre><p>Solves the Shrodinger equation:</p><p><span>$\frac{d \Psi}{d t}=-i \hat{H}\Psi$</span></p><p>and returns the final state Ket, and a Vector of observables evaluated at each time step. </p><p><strong>Fields</strong></p><ul><li><p><code>H</code> – the Hamiltonian operator (of any subtype of <code>AbstractOperator</code>) or a        function that returns the Hamiltonian as a function of time.</p></li><li><p><code>ψ_0</code> – initital state (<code>Ket</code>) of a quantum system</p></li><li><p><code>t_range</code> – time interval for which the system has to be simulated.        For instance:            t<em>range=0:10 evaluates the output using time            steps: 0,1,2,...,10.            t</em>range=0:0.01:1 evaluates the output using            time steps: 0,0.01,0.02,...,1.0 </p></li><li><p><code>e_ops</code> – list of operators for which the expected value    (the observables) will be evaluated at each time step in t_range. </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/dynamic_system.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.mesolve" href="#Snowflake.mesolve"><code>Snowflake.mesolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mesolve(H::AbstractOperator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{AbstractOperator}=(AbstractOperator)[])</code></pre><p>Solves the Lindblad Master equation:</p><p><span>$\dot{\rho}=-i [H, \rho]+\sum_i \gamma_i\left(L_i \rho L^{\dag}_i - \frac{1}{2}\left\{L^{\dag}_i L_i, \rho\right\}\right)$</span></p><p>and returns a Vector of observables evaluated at each time step.</p><p><strong>Fields</strong></p><ul><li><code>H</code> – the Hamiltonian operator (of any subtype of <code>AbstractOperator</code>).</li><li><code>ψ_0</code> – initital state (Ket) of a quantum system</li><li><code>t_range</code> – time interval for which the system has to be simulated.        For instance:            t<em>range=0:10 evaluates the output using time            steps: 0,1,2,...,10.            t</em>range=0:0.01:1 evaluates the output using            time steps: 0,0.01,0.02,...,1.0 </li><li><code>e_ops</code> – list of operators for which the expected value        (the observables) will be evaluated at each time step in t_range. </li><li><code>c_ops</code> – list of collapse operators <span>$L_i$</span>&#39;s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/dynamic_system.jl#L56-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.compare_kets" href="#Snowflake.compare_kets"><code>Snowflake.compare_kets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_kets(ψ_0::Ket,ψ_1::Ket)</code></pre><p>Checks for equivalence allowing for a global phase difference between two input kets.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = Ket([1.,2.,3.,4.])
4-element Ket{ComplexF64}:
1.0 + 0.0im
2.0 + 0.0im
3.0 + 0.0im
4.0 + 0.0im


julia&gt; δ=π/3 # phase offset
1.0471975511965976

julia&gt; ψ_1 = exp(im*δ)*ψ_0
4-element Ket{ComplexF64}:
0.5000000000000001 + 0.8660254037844386im
1.0000000000000002 + 1.7320508075688772im
1.5000000000000004 + 2.598076211353316im
2.0000000000000004 + 3.4641016151377544im


julia&gt; compare_kets(ψ_0,ψ_1)
true

julia&gt; apply_gate!(ψ_1,sigma_x(1))

julia&gt; compare_kets(ψ_0,ψ_1) # no longer equivalent after SigmaX gate
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/282f2fddd7469b5a749f99b4ace2f3b5bc393083/src/core/qobj.jl#L52-L88">source</a></section></article><h3 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h3><p>The <a href="https://github.com/anyonlabs/SnowflakePlots.jl">SnowflakePlots</a> package provides multiple visualization tools for Snowflake.jl. Please see the documentation of <a href="https://github.com/anyonlabs/SnowflakePlots.jl">SnowflakePlots</a> for more details. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorials/index.html">« Tutorials</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 4 May 2023 22:14">Thursday 4 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
