<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Snowflake</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Snowflake logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Snowflake</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Quantum Computing With Snowflake</span><ul><li><a class="tocitem" href="qc/basics.html">Basics</a></li></ul></li><li class="is-active"><a class="tocitem" href="library.html">Library</a><ul class="internal"><li><a class="tocitem" href="#Quantum-Circuit"><span>Quantum Circuit</span></a></li><li><a class="tocitem" href="#Quantum-Gates"><span>Quantum Gates</span></a></li><li><a class="tocitem" href="#Quantum-Processing-Unit"><span>Quantum Processing Unit</span></a></li><li><a class="tocitem" href="#Quantum-Toolkit"><span>Quantum Toolkit</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="library.html">Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="library.html">Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/anyonlabs/Snowflake.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Quantum-Circuit"><a class="docs-heading-anchor" href="#Quantum-Circuit">Quantum Circuit</a><a id="Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.QuantumCircuit" href="#Snowflake.QuantumCircuit"><code>Snowflake.QuantumCircuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">    QuantumCircuit(qubit_count = .., bit_count = ...)</code></pre><p>A data structure to represent a <em>quantum circuit</em>.  </p><p><strong>Fields</strong></p><ul><li><code>qubit_count::Int</code> – number of qubits (i.e. quantum register size).</li><li><code>bit_count::Int</code> – number of classical bits (i.e. classical register size).</li><li><code>id::UUID</code> – a universally unique identifier for the circuit. A UUID is automatically generated once an instance is created. </li><li><code>pipeline::Array{Array{Gate}}</code> – the pipeline of gates to operate on qubits.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0)
Quantum Circuit Object:
   id: b2d2be56-7af2-11ec-31a6-ed9e71cb3360 
   qubit_count: 2 
   bit_count: 0 
q[1]:
     
q[2]:</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_circuit.jl#L2-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.push_gate!" href="#Snowflake.push_gate!"><code>Snowflake.push_gate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    push_gate!(circuit::QuantumCircuit, gate::Gate)
    push_gate!(circuit::QuantumCircuit, gates::Array{Gate})</code></pre><p>Pushes a single gate or an array of gates to the <code>circuit</code> pipeline. This function is mutable. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);

julia&gt; push_gate!(c, [hadamard(1),sigma_x(2)])
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:──H──
          
q[2]:──X──
          


julia&gt; push_gate!(c, control_x(1,2))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:──H────*──
            |  
q[2]:──X────X──</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_circuit.jl#L31-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.pop_gate!" href="#Snowflake.pop_gate!"><code>Snowflake.pop_gate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    pop_gate!(circuit::QuantumCircuit)</code></pre><p>Removes the last gate from <code>circuit.pipeline</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);

julia&gt; push_gate!(c, [hadamard(1),sigma_x(2)])
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:──H──
          
q[2]:──X──
          


julia&gt; push_gate!(c, control_x(1,2))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:──H────*──
            |  
q[2]:──X────X──

julia&gt; pop_gate!(c)
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:──H──
          
q[2]:──X──</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_circuit.jl#L83-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.simulate" href="#Snowflake.simulate"><code>Snowflake.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    simulate(circuit::QuantumCircuit)</code></pre><p>Simulates and returns the wavefunction of the quantum device after running <code>circuit</code>. </p><p>Employs the approach described in Listing 5 of <a href="https://doi.org/10.22331/q-2021-10-06-559">Suzuki <em>et. al.</em> (2021)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);

julia&gt; push_gate!(c, hadamard(1))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push_gate!(c, control_x(1,2))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; ket = simulate(c);

julia&gt; print(ket)
4-element Ket:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_circuit.jl#L277-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.simulate_shots" href="#Snowflake.simulate_shots"><code>Snowflake.simulate_shots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    simulate_shots(c::QuantumCircuit, shots_count::Int = 100)</code></pre><p>Emulates a quantum computer by running a circuit for a given number of shots and returning measurement results.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);

julia&gt; push_gate!(c, hadamard(1))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push_gate!(c, control_x(1,2))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; simulate_shots(c, 99)
99-element Vector{String}:
 &quot;11&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 ⋮
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_circuit.jl#L431-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_inverse-Tuple{QuantumCircuit}" href="#Snowflake.get_inverse-Tuple{QuantumCircuit}"><code>Snowflake.get_inverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_inverse(circuit::QuantumCircuit)</code></pre><p>Return a <code>QuantumCircuit</code> which is the inverse of the input <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2, bit_count=0);

julia&gt; push_gate!(c, rotation_y(1, pi/4));

julia&gt; push_gate!(c, control_x(1, 2))
Quantum Circuit Object:
   id: 47ddf072-7293-11ed-3d64-9f4fd1e69575 
   qubit_count: 2 
   bit_count: 0 
q[1]:──Ry(0.7853981633974483)────*──
                                 |  
q[2]:────────────────────────────X──
                                    



julia&gt; get_inverse(c)
Quantum Circuit Object:
   id: 6153cc20-7293-11ed-37d4-e14a7e7df842 
   qubit_count: 2 
   bit_count: 0 
q[1]:──*────Ry(-0.7853981633974483)──
       |                             
q[2]:──X─────────────────────────────
                                     


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_circuit.jl#L509-L545">source</a></section></article><h2 id="Quantum-Gates"><a class="docs-heading-anchor" href="#Quantum-Gates">Quantum Gates</a><a id="Quantum-Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Gates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Gate" href="#Snowflake.Gate"><code>Snowflake.Gate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Gate</code></pre><p>A <code>Gate</code> can be added to a <code>QuantumCircuit</code> in order to apply an operator to one or more <code>target</code> qubits.</p><p>A <code>Gate</code> is an abstract type, which means that it cannot be instantiated. Instead, each type of gate must have a struct which is a descendant of <code>Gate</code>. Each descendant of <code>Gate</code> must have at least the following fields:</p><ul><li><code>display_symbol::Vector{String}</code>: determines how the <code>Gate</code> is displayed in a <code>QuantumCircuit</code>.</li><li><code>instruction_symbol::String</code>: used by the quantum compiler to identify the <code>Gate</code>.</li><li><code>target::Vector{Int}</code>: to which qubits the <code>Gate</code> is applied.</li><li><code>parameters::Vector</code>: affect which operation is applied (e.g. rotation angles).</li></ul><p><strong>Examples</strong></p><p>A struct must be defined for each new gate type, such as the following X_45 gate which applies a 45° rotation about the X axis:</p><pre><code class="language-julia-repl hljs">julia&gt; struct X45 &lt;: Gate
           display_symbol::Vector{String}
           instruction_symbol::String
           target::Vector{Int}
           parameters::Vector
       end;
</code></pre><p>For convenience, a constructor can be defined:</p><pre><code class="language-julia-repl hljs">julia&gt; x_45(target) = X45([&quot;X_45&quot;], &quot;x_45&quot;, [target], []);
</code></pre><p>To simulate the effect of the gate in a <code>QuantumCircuit</code> or when applied to a <code>Ket</code>, the function <code>get_operator</code> must be extended.</p><pre><code class="language-julia-repl hljs">julia&gt; Snowflake.get_operator(gate::X45) = rotation_x(π/4);
</code></pre><p>The gate inverse can also be specified by extending the <code>get_inverse</code> function.</p><pre><code class="language-julia-repl hljs">julia&gt; Snowflake.get_inverse(gate::X45) = rotation_x(gate.target[1], -π/4);
</code></pre><p>An instance of the X_45 gate can now be created:</p><pre><code class="language-julia-repl hljs">julia&gt; x_45_gate = x_45(1)
Gate Object:
instruction symbol: x_45
targets: [1]
operator:
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im
0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im


julia&gt; get_inverse(x_45_gate)
Gate Object:
instruction symbol: rx
parameters: [-0.7853981633974483]
targets: [1]
operator:
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.9238795325112867 + 0.0im    -0.0 + 0.3826834323650898im
-0.0 + 0.3826834323650898im    0.9238795325112867 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L3-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.eye" href="#Snowflake.eye"><code>Snowflake.eye</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eye()</code></pre><p>Return the identity <code>Operator</code>, which is defined as:</p><p class="math-container">\[I = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L260-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_p" href="#Snowflake.sigma_p"><code>Snowflake.sigma_p</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_p()</code></pre><p>Return the spin-<span>$\frac{1}{2}$</span> raising <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_+ = \begin{bmatrix}
    0 &amp; 1 \\
    0 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L169-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_m" href="#Snowflake.sigma_m"><code>Snowflake.sigma_m</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_m()</code></pre><p>Return the spin-<span>$\frac{1}{2}$</span> lowering <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_- = \begin{bmatrix}
    0 &amp; 0 \\
    1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L182-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_x" href="#Snowflake.sigma_x"><code>Snowflake.sigma_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_x()</code></pre><p>Return the Pauli-X <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_x = \begin{bmatrix}
    0 &amp; 1 \\
    1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L130-L140">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_x(target)</code></pre><p>Return the Pauli-X <code>Gate</code>, which applies the <a href="library.html#Snowflake.sigma_x"><code>sigma_x()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L512-L516">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_y" href="#Snowflake.sigma_y"><code>Snowflake.sigma_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_y()</code></pre><p>Return the Pauli-Y <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_y = \begin{bmatrix}
    0 &amp; -i \\
    i &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L143-L153">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_y(target)</code></pre><p>Return the Pauli-Y <code>Gate</code>, which applies the <a href="library.html#Snowflake.sigma_y"><code>sigma_y()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L548-L552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_z" href="#Snowflake.sigma_z"><code>Snowflake.sigma_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_z()</code></pre><p>Return the Pauli-Z <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_z = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L156-L166">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_z(target)</code></pre><p>Return the Pauli-Z <code>Gate</code>, which applies the <a href="library.html#Snowflake.sigma_z"><code>sigma_z()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L566-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.hadamard" href="#Snowflake.hadamard"><code>Snowflake.hadamard</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hadamard()</code></pre><p>Return the Hadamard <code>Operator</code>, which is defined as:</p><p class="math-container">\[H = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L195-L205">source</a></section><section><div><pre><code class="nohighlight hljs">hadamard(target)</code></pre><p>Return the Hadamard <code>Gate</code>, which applies the <a href="library.html#Snowflake.hadamard"><code>hadamard()</code></a> <code>Operator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L584-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.phase" href="#Snowflake.phase"><code>Snowflake.phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase()</code></pre><p>Return the phase gate <code>Operator</code>, which is defined as:</p><p class="math-container">\[S = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; i
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L208-L218">source</a></section><section><div><pre><code class="nohighlight hljs">phase(target)</code></pre><p>Return a phase <code>Gate</code> (also known as an <span>$S$</span> <code>Gate</code>), which applies the <a href="library.html#Snowflake.phase"><code>phase()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L602-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.phase_dagger" href="#Snowflake.phase_dagger"><code>Snowflake.phase_dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase_dagger()</code></pre><p>Return the adjoint phase gate <code>Operator</code>, which is defined as:</p><p class="math-container">\[S^\dagger = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; -i
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L221-L231">source</a></section><section><div><pre><code class="nohighlight hljs">phase_dagger(target)</code></pre><p>Return an adjoint phase <code>Gate</code> (also known as an <span>$S^\dagger$</span> <code>Gate</code>), which applies the <a href="library.html#Snowflake.phase_dagger"><code>phase_dagger()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L619-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.pi_8" href="#Snowflake.pi_8"><code>Snowflake.pi_8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pi_8()</code></pre><p>Return the <code>Operator</code> for the π/8 gate, which is defined as:</p><p class="math-container">\[T = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\frac{\pi}{4}}
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L234-L244">source</a></section><section><div><pre><code class="nohighlight hljs">pi_8(target)</code></pre><p>Return a π/8 <code>Gate</code> (also known as a <span>$T$</span> <code>Gate</code>), which applies the <a href="library.html#Snowflake.pi_8"><code>pi_8()</code></a> <code>Operator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L637-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.pi_8_dagger" href="#Snowflake.pi_8_dagger"><code>Snowflake.pi_8_dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pi_8_dagger()</code></pre><p>Return the adjoint <code>Operator</code> of the π/8 gate, which is defined as:</p><p class="math-container">\[T^\dagger = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; e^{-i\frac{\pi}{4}}
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L247-L257">source</a></section><section><div><pre><code class="nohighlight hljs">pi_8_dagger(target)</code></pre><p>Return an adjoint π/8 <code>Gate</code> (also known as a <span>$T^\dagger$</span> <code>Gate</code>), which applies the <a href="library.html#Snowflake.pi_8_dagger"><code>pi_8_dagger()</code></a> <code>Operator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L655-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.x_90" href="#Snowflake.x_90"><code>Snowflake.x_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x_90()</code></pre><p>Return the <code>Operator</code> which applies a π/2 rotation about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; -i \\
    -i &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L273-L285">source</a></section><section><div><pre><code class="nohighlight hljs">x_90(target)</code></pre><p>Return a <code>Gate</code> that applies a 90° rotation about the X axis as defined by the <a href="library.html#Snowflake.x_90"><code>x_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L673-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation" href="#Snowflake.rotation"><code>Snowflake.rotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation(theta, phi)</code></pre><p>Return the <code>Operator</code> which applies a rotation <code>theta</code> about the cos(<code>phi</code>)X+sin(<code>phi</code>)Y axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R(\theta, \phi) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -i e^{-i\phi} \mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    -i e^{i\phi} \mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L288-L302">source</a></section><section><div><pre><code class="nohighlight hljs">rotation(target, theta, phi)</code></pre><p>Return a gate that applies a rotation <code>theta</code> to the <code>target</code> qubit about the cos(<code>phi</code>)X+sin(<code>phi</code>)Y axis.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.rotation"><code>rotation(theta, phi)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L691-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation_x" href="#Snowflake.rotation_x"><code>Snowflake.rotation_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_x(theta)</code></pre><p>Return the <code>Operator</code> which applies a rotation <code>theta</code> about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x(\theta) = \begin{bmatrix}
\mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
    -i\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
-i\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
    \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L308-L322">source</a></section><section><div><pre><code class="nohighlight hljs">rotation_x(target, theta)</code></pre><p>Return a <code>Gate</code> that applies a rotation <code>theta</code> about the X axis of the <code>target</code> qubit.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.rotation_x"><code>rotation_x(theta)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L713-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation_y" href="#Snowflake.rotation_y"><code>Snowflake.rotation_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_y(theta)</code></pre><p>Return the <code>Operator</code> that applies a rotation <code>theta</code> about the Y axis of the <code>target</code> qubit.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_y(\theta) = \begin{bmatrix}
\mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
    -\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
    \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L325-L339">source</a></section><section><div><pre><code class="nohighlight hljs">rotation_y(target, theta)</code></pre><p>Return a <code>Gate</code> that applies a rotation <code>theta</code> about the Y axis of the <code>target</code> qubit.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.rotation_y"><code>rotation_y(theta)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L733-L739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation_z" href="#Snowflake.rotation_z"><code>Snowflake.rotation_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_z(theta)</code></pre><p>Return the <code>Operator</code> that applies a rotation <code>theta</code> about the Z axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_z(\theta) = \begin{bmatrix}
\mathrm{exp}\left(-i\frac{\theta}{2}\right) &amp; 0 \\[0.5em]      
0 &amp; \mathrm{exp}\left(i\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L342-L354">source</a></section><section><div><pre><code class="nohighlight hljs">rotation_z(target, theta)</code></pre><p>Return a <code>Gate</code> that applies a rotation <code>theta</code> about the Z axis of the <code>target</code> qubit.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.rotation_z"><code>rotation_z(theta)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L753-L759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.phase_shift" href="#Snowflake.phase_shift"><code>Snowflake.phase_shift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase_shift(phi)</code></pre><p>Return the <code>Operator</code> that applies a phase shift <code>phi</code>.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[P(\phi) = \begin{bmatrix}
    i &amp; 0 \\[0.5em]      
    0 &amp; e^{i\phi}
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L360-L372">source</a></section><section><div><pre><code class="nohighlight hljs">phase_shift(target, phi)</code></pre><p>Return a <code>Gate</code> that applies a phase shift <code>phi</code> to the <code>target</code> qubit as defined by the <a href="library.html#Snowflake.phase_shift"><code>phase_shift(phi)</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L773-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.universal" href="#Snowflake.universal"><code>Snowflake.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">universal(theta, phi, lambda)</code></pre><p>Return the <code>Operator</code> which performs a rotation about the angles <code>theta</code>, <code>phi</code>, and <code>lambda</code>.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[U(\theta, \phi, \lambda) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -e^{i\lambda}\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    e^{i\phi}\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        e^{i\left(\phi+\lambda\right)}\mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L378-L392">source</a></section><section><div><pre><code class="nohighlight hljs">universal(target, theta, phi, lambda)</code></pre><p>Return a gate which rotates the <code>target</code> qubit given the angles <code>theta</code>, <code>phi</code>, and <code>lambda</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.universal"><code>universal(theta, phi, lambda)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L791-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.control_z" href="#Snowflake.control_z"><code>Snowflake.control_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control_z()</code></pre><p>Return the controlled-Z <code>Operator</code>, which is defined as:</p><p class="math-container">\[CZ = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L422-L434">source</a></section><section><div><pre><code class="nohighlight hljs">control_z(control_qubit, target_qubit)</code></pre><p>Return a controlled-Z gate given a <code>control_qubit</code> and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.control_z"><code>control_z()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L818-L824">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.control_x" href="#Snowflake.control_x"><code>Snowflake.control_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control_x()</code></pre><p>Return the controlled-X (or controlled NOT) <code>Operator</code>, which is defined as:</p><p class="math-container">\[CX = CNOT = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L398-L410">source</a></section><section><div><pre><code class="nohighlight hljs">control_x(control_qubit, target_qubit)</code></pre><p>Return a controlled-X gate (also known as a controlled NOT gate) given a <code>control_qubit</code> and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.control_x"><code>control_x()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L856-L862">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.iswap" href="#Snowflake.iswap"><code>Snowflake.iswap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswap()</code></pre><p>Return the imaginary swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; i &amp; 0 \\
    0 &amp; i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L446-L458">source</a></section><section><div><pre><code class="nohighlight hljs">iswap(qubit_1, qubit_2)</code></pre><p>Return the imaginary swap <code>Gate</code> which applies the imaginary swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.iswap"><code>iswap()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L880-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.toffoli" href="#Snowflake.toffoli"><code>Snowflake.toffoli</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">toffoli()</code></pre><p>Return the Toffoli <code>Operator</code>, which is defined as:</p><p class="math-container">\[CCX = CCNOT = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L465-L481">source</a></section><section><div><pre><code class="nohighlight hljs">toffoli(control_qubit_1, control_qubit_2, target_qubit)</code></pre><p>Return a Toffoli gate (also known as a CCNOT gate) given two control qubits and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.toffoli"><code>toffoli()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L904-L910">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.iswap_dagger" href="#Snowflake.iswap_dagger"><code>Snowflake.iswap_dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswap_dagger()</code></pre><p>Return the adjoint of the imaginary swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP^\dagger = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; -i &amp; 0 \\
    0 &amp; -i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L493-L505">source</a></section><section><div><pre><code class="nohighlight hljs">iswap_dagger(qubit_1, qubit_2)</code></pre><p>Return the adjoint imaginary swap <code>Gate</code> which applies the adjoint imaginary swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.iswap_dagger"><code>iswap_dagger()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L928-L934">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Gate, Ket}" href="#Base.:*-Tuple{Gate, Ket}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(M::Gate, x::Ket)</code></pre><p>Return a <code>Ket</code> which results from applying <code>Gate</code> <code>M</code> to <code>Ket</code> <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = fock(0, 2);

julia&gt; print(ψ_0)
2-element Ket:
1.0 + 0.0im
0.0 + 0.0im

julia&gt; ψ_1 = sigma_x(1)*ψ_0;

julia&gt; print(ψ_1)
2-element Ket:
0.0 + 0.0im
1.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L952-L974">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.apply_gate!" href="#Snowflake.apply_gate!"><code>Snowflake.apply_gate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_gate!(state::Ket, gate::Gate)</code></pre><p>Update the <code>state</code> by applying a <code>gate</code> to it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = fock(0, 2);

julia&gt; print(ψ_0)
2-element Ket:
1.0 + 0.0im
0.0 + 0.0im

julia&gt; apply_gate!(ψ_0, sigma_x(1));

julia&gt; print(ψ_0)
2-element Ket:
0.0 + 0.0im
1.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L92-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_operator" href="#Snowflake.get_operator"><code>Snowflake.get_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_operator(gate::Gate)</code></pre><p>Returns the <code>Operator</code> which is associated to a <code>Gate</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = sigma_x(1);

julia&gt; get_operator(x)
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L526-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_inverse-Tuple{Gate}" href="#Snowflake.get_inverse-Tuple{Gate}"><code>Snowflake.get_inverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_inverse(gate::Gate)</code></pre><p>Return a <code>Gate</code> which is the inverse of the input <code>gate</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = universal(1, -pi/2, pi/3, pi/4)
Gate Object:
instruction symbol: u
parameters: [-1.5707963267948966, 1.0471975511965976, 0.7853981633974483]
targets: [1]
operator:
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.7071067811865476 + 0.0im    0.5 + 0.4999999999999999im
-0.3535533905932738 - 0.6123724356957945im    -0.18301270189221924 + 0.6830127018922194im


julia&gt; get_inverse(u)
Gate Object:
instruction symbol: u
parameters: [1.5707963267948966, -0.7853981633974483, -1.0471975511965976]
targets: [1]
operator:
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.7071067811865476 + 0.0im    -0.3535533905932738 + 0.6123724356957945im
0.5 - 0.4999999999999999im    -0.18301270189221924 - 0.6830127018922194im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/quantum_gate.jl#L983-L1015">source</a></section></article><h2 id="Quantum-Processing-Unit"><a class="docs-heading-anchor" href="#Quantum-Processing-Unit">Quantum Processing Unit</a><a id="Quantum-Processing-Unit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Processing-Unit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.QPU" href="#Snowflake.QPU"><code>Snowflake.QPU</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represnts a Quantum Processing Unit (QPU). <strong>Fields</strong></p><ul><li><code>manufacturer:: String</code> – qpu manufacturer (e.g. &quot;anyon&quot;)</li><li><code>generation:: String</code> – qpu generation (e.g. &quot;yukon&quot;)</li><li><code>serial_number:: String</code> – qpu serial_number (e.g. &quot;ANYK202201&quot;)</li><li><code>host:: String</code> – the remote host url address to send the jobs to</li><li><code>qubit_count:: Int</code> – number of physical qubits on the machine</li><li><code>connectivity::SparseArrays.SparseMatrixCSC{Int}</code> – a matrix describing the connectivity between qubits</li><li><code>native_gates:: Vector{String}</code> – the vector of native gates symbols supported by the qpu architecture</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qpu.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.create_virtual_qpu" href="#Snowflake.create_virtual_qpu"><code>Snowflake.create_virtual_qpu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_virtual_qpu(qubit_count::Int, connectivity::Matrix{Int},
    native_gates::Vector{String}, host = &quot;localhost:5600&quot;)</code></pre><p>Creates a virtual quantum processor with <code>qubit_count</code> number of qubits, a <code>connectivity</code> matrix, and a vector of <code>native_gates</code>.  The return value is a QPU stucture (see  <a href="library.html#Snowflake.QPU"><code>QPU</code></a>).</p><p><strong>Examples</strong></p><p>To generate a QPU structure, the connectivity must be specified. Let&#39;s assume that we have a 3-qubit device where there is connectivity between qubits 2 and 1 as well as between qubits 2 and 3. If qubit 2 can only be a control qubit, the connectivity matrix corresponds to:</p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = [1 0 0
                       1 1 1
                       0 0 1]
3×3 Matrix{Int64}:
 1  0  0
 1  1  1
 0  0  1</code></pre><p>Here, the ones in the diagonal indicate that all qubits can perform single-qubit gates. If there is a one in an off-diagonal entry with row i and column j, it indicates that a two-qubit gate with control qubit i and target qubit j can be applied.</p><p>If the native gates are the Pauli-X gate, the Hadamard gate, and the control-X gate, the QPU can be created as follows: </p><pre><code class="language-julia-repl hljs">julia&gt; qpu = create_virtual_qpu(3, connectivity, [&quot;x&quot;, &quot;h&quot;, &quot;cx&quot;]);

julia&gt; qpu.qubit_count
3

julia&gt; qpu.native_gates
3-element Vector{String}:
 &quot;x&quot;
 &quot;h&quot;
 &quot;cx&quot;

julia&gt; qpu.connectivity
3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 5 stored entries:
 1  ⋅  ⋅
 1  1  1
 ⋅  ⋅  1

julia&gt; qpu.host
&quot;localhost:5600&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qpu.jl#L34-L86">source</a></section></article><h2 id="Quantum-Toolkit"><a class="docs-heading-anchor" href="#Quantum-Toolkit">Quantum Toolkit</a><a id="Quantum-Toolkit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Toolkit" title="Permalink"></a></h2><h3 id="Basic-Quantum-Objects"><a class="docs-heading-anchor" href="#Basic-Quantum-Objects">Basic Quantum Objects</a><a id="Basic-Quantum-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Quantum-Objects" title="Permalink"></a></h3><p>There are three basic quantum objects in Snowflake to simulate a quantum system. These objects are Ket, Bra, and Operator.</p><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Ket" href="#Snowflake.Ket"><code>Snowflake.Ket</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Ket represents a <em>quantum wavefunction</em> and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.  </p><p><strong>Fields</strong></p><ul><li><code>data</code> – the stored values.</li></ul><p><strong>Examples</strong></p><p>Although NOT the preferred way, one can directly build a Ket object by passing a column vector as the initializer. </p><pre><code class="language-julia-repl hljs">julia&gt; using Snowflake

julia&gt; ψ = Snowflake.Ket([1.0; 0.0; 0.0]);

julia&gt; print(ψ)
3-element Ket:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im</code></pre><p>A better way to initialize a Ket is to use a pre-built basis such as the <code>fock</code> basis. See <a href="library.html#Snowflake.fock"><code>fock</code></a> for further information on this function. </p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Snowflake.fock(2, 3);

julia&gt; print(ψ)
3-element Ket:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Bra" href="#Snowflake.Bra"><code>Snowflake.Bra</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a Bra (i.e. a row vector of complex values). A Bra is created as the complex conjugate of a Ket.</p><p><strong>Fields</strong></p><ul><li><code>data</code> – the stored values.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Snowflake.fock(1, 3);

julia&gt; print(ψ)
3-element Ket:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im

julia&gt; _ψ = Snowflake.Bra(ψ);

julia&gt; print(_ψ)
Bra(Any[0.0 - 0.0im 1.0 - 0.0im 0.0 - 0.0im])


julia&gt; _ψ * ψ    # A Bra times a Ket is a scalar
1.0 + 0.0im

julia&gt; ψ*_ψ     # A Ket times a Bra is an operator
(3, 3)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L40-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Operator" href="#Snowflake.Operator"><code>Snowflake.Operator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a quantum operator (i.e. a complex matrix).</p><p><strong>Fields</strong></p><ul><li><code>data</code> – the complex matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = Snowflake.Operator([1.0 0.0;0.0 -1.0])
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    -1.0 + 0.0im
</code></pre><p>Alternatively:</p><pre><code class="language-julia-repl hljs">julia&gt; z = Snowflake.sigma_z()  #sigma_z is a defined function in Snowflake
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    -1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L78-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.adjoint(x)</code></pre><p>Compute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.is_hermitian" href="#Snowflake.is_hermitian"><code>Snowflake.is_hermitian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_hermitian(A::Operator)</code></pre><p>Determine if Operator <code>A</code> is Hermitian (i.e. self-adjoint).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = sigma_y()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.0 + 0.0im    0.0 - 1.0im
0.0 + 1.0im    0.0 + 0.0im


julia&gt; is_hermitian(Y)
true

julia&gt; P = sigma_p()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.0 + 0.0im    1.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im


julia&gt; is_hermitian(P)
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L116-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Operator, Int64, Int64}" href="#Base.getindex-Tuple{Operator, Int64, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(A::Operator, m::Int64, n::Int64)</code></pre><p>Return the element at row <code>m</code> and column <code>n</code> of Operator <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.eigen" href="#Snowflake.eigen"><code>Snowflake.eigen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigen(A::Operator)</code></pre><p>Compute the eigenvalue decomposition of Operator <code>A</code> and return an <code>Eigen</code> factorization object <code>F</code>. Eigenvalues are found in <code>F.values</code> while eigenvectors are found in the matrix <code>F.vectors</code>. Each column of this matrix corresponds to an eigenvector. The <code>i</code>th eigenvector is extracted by calling <code>F.vectors[:, i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = sigma_x()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im

julia&gt; F = eigen(X);

julia&gt; eigenvalues = F.values
2-element Vector{Float64}:
 -1.0
  1.0

julia&gt; eigenvector_1 = F.vectors[:, 1]
2-element Vector{ComplexF64}:
 -0.7071067811865475 + 0.0im
  0.7071067811865475 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L171-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.tr" href="#Snowflake.tr"><code>Snowflake.tr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tr(A::Operator)</code></pre><p>Compute the trace of Operator <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; I = eye()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
1.0 + 0.0im    0 + 0im
0 + 0im    1.0 + 0.0im


julia&gt; trace = tr(I)
2.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L202-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.expected_value" href="#Snowflake.expected_value"><code>Snowflake.expected_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expected_value(A::Operator, psi::Ket)</code></pre><p>Compute the expectation value ⟨<code>ψ</code>|<code>A</code>|<code>ψ</code>⟩ given Operator <code>A</code> and Ket |<code>ψ</code>⟩.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([0.0; 1.0]);

julia&gt; print(ψ)
2-element Ket:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; A = sigma_z()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    -1.0 + 0.0im


julia&gt; expected_value(A, ψ)
-1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L222-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kron(x, y)</code></pre><p>Compute the Kronecker product of two <a href="library.html#Snowflake.Ket"><code>Kets</code></a> or two <a href="library.html#Snowflake.Operator"><code>Operators</code></a>. More details about the Kronecker product can be found <a href="https://en.wikipedia.org/wiki/Kronecker_product">here</a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = Ket([0.0; 1.0]);

julia&gt; print(ψ_0)
2-element Ket:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; ψ_1 = Ket([1.0; 0.0]);

julia&gt; print(ψ_1)
2-element Ket:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ_0_1 = kron(ψ_0, ψ_1);

julia&gt; print(ψ_0_1)
4-element Ket:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; kron(sigma_x(), sigma_y())
(4, 4)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L257-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.MultiBodySystem" href="#Snowflake.MultiBodySystem"><code>Snowflake.MultiBodySystem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a quantum multi-body system.</p><p><strong>Fields</strong></p><ul><li><code>hilbert_space_structure</code> – a vector of integers specifying the local Hilbert space size for each &quot;body&quot; within the multi-body system. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L304-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.commute" href="#Snowflake.commute"><code>Snowflake.commute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.commute(A::Operator, B::Operator)</code></pre><p>Returns the commutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = sigma_x()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im


julia&gt; σ_y = sigma_y()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    0.0 - 1.0im
0.0 + 1.0im    0.0 + 0.0im


julia&gt; Snowflake.commute(σ_x,σ_y)
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 2.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 - 2.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L664-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.anticommute" href="#Snowflake.anticommute"><code>Snowflake.anticommute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.anticommute(A::Operator, B::Operator)</code></pre><p>Returns the anticommutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = Snowflake.sigma_x()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im


julia&gt; Snowflake.anticommute(σ_x,σ_x)
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
2.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    2.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L694-L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.normalize!" href="#Snowflake.normalize!"><code>Snowflake.normalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.normalize!(x::Ket)</code></pre><p>Normalizes Ket <code>x</code> such that its magnitude becomes unity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L653-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.ket2dm" href="#Snowflake.ket2dm"><code>Snowflake.ket2dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.ket2dm(ψ)</code></pre><p>Returns the density matrix corresponding to the pure state ψ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L717-L721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.fock_dm" href="#Snowflake.fock_dm"><code>Snowflake.fock_dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.fock_dm(i, hspace_size)</code></pre><p>Returns the density matrix corresponding to the Fock base <code>i</code> defined in a Hilbert space of size <code>hspace_size</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L726-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.moyal" href="#Snowflake.moyal"><code>Snowflake.moyal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.moyal(m, n)</code></pre><p>Returns the Moyal function <code>w_mn(eta)</code> for Fock states <code>m</code> and <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L750-L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.genlaguerre" href="#Snowflake.genlaguerre"><code>Snowflake.genlaguerre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.genlaguerre(x, alpha, n)</code></pre><p>Returns the generalized Laguerre polynomial of degree <code>n</code> for <code>x</code> using a recursive method. See <a href="https://en.wikipedia.org/wiki/Laguerre_polynomials">https://en.wikipedia.org/wiki/Laguerre_polynomials</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L762-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_embed_operator" href="#Snowflake.get_embed_operator"><code>Snowflake.get_embed_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_embed_operator(op::Operator, target_body_index::Int, system::MultiBodySystem)</code></pre><p>Uses a local operator (<code>op</code>), which is defined for a particular body (e.g. qubit) with index <code>target_body_index</code>, to build the corresponding operator for the Hilbert space of the multi-body system given by <code>system</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; system = Snowflake.MultiBodySystem(3,2)
Snowflake.Multibody system with 3 bodies
   Hilbert space structure:
   [2, 2, 2]

julia&gt; x = Snowflake.sigma_x()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im

julia&gt; X_1=Snowflake.get_embed_operator(x,1,system)
(8, 8)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L326-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_qubits-Tuple{Operator}" href="#Snowflake.get_num_qubits-Tuple{Operator}"><code>Snowflake.get_num_qubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::Operator)</code></pre><p>Returns the number of qubits associated with an <code>Operator</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = Operator([1 0
                     0 0])
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
1 + 0im    0 + 0im
0 + 0im    0 + 0im

julia&gt; get_num_qubits(ρ)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L405-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_qubits-Tuple{Union{Bra, Ket}}" href="#Snowflake.get_num_qubits-Tuple{Union{Bra, Ket}}"><code>Snowflake.get_num_qubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::Union{Ket, Bra})</code></pre><p>Returns the number of qubits associated with a <code>Ket</code> or a <code>Bra</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1, 0, 0, 0]);

julia&gt; print(ψ)
4-element Ket:
1 + 0im
0 + 0im
0 + 0im
0 + 0im

julia&gt; get_num_qubits(ψ)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L436-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_bodies" href="#Snowflake.get_num_bodies"><code>Snowflake.get_num_bodies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_bodies(x::Operator, hilbert_space_size_per_body=2)</code></pre><p>Returns the number of bodies associated with an <code>Operator</code> given the <code>hilbert_space_size_per_body</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = Operator([1 0 0
                     0 0 0
                     0 0 0])
(3, 3)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
1 + 0im    0 + 0im    0 + 0im
0 + 0im    0 + 0im    0 + 0im
0 + 0im    0 + 0im    0 + 0im

julia&gt; get_num_bodies(ρ, 3)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L465-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_bodies" href="#Snowflake.get_num_bodies"><code>Snowflake.get_num_bodies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)</code></pre><p>Returns the number of bodies associated with a <code>Ket</code> or a <code>Bra</code> given the <code>hilbert_space_size_per_body</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1, 0, 0, 0, 0, 0, 0, 0, 0]);

julia&gt; print(ψ)
9-element Ket:
1 + 0im
0 + 0im
0 + 0im
0 + 0im
0 + 0im
0 + 0im
0 + 0im
0 + 0im
0 + 0im

julia&gt; get_num_bodies(ψ, 3)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L499-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.fock" href="#Snowflake.fock"><code>Snowflake.fock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.fock(i, hspace_size)</code></pre><p>Returns the <code>i</code>th fock basis of a Hilbert space with size <code>hspace_size</code> as Snowflake.Ket.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Snowflake.fock(0, 3);

julia&gt; print(ψ)
3-element Ket:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ = Snowflake.fock(1, 3);

julia&gt; print(ψ)
3-element Ket:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L534-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.create" href="#Snowflake.create"><code>Snowflake.create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.create(hspace_size)</code></pre><p>Returns the bosonic creation operator for a Fock space of size <code>hspace_size</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L567-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.destroy" href="#Snowflake.destroy"><code>Snowflake.destroy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.destroy(hspace_size)</code></pre><p>Returns the bosonic annhilation operator for a Fock space of size <code>hspace_size</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L580-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.number_op" href="#Snowflake.number_op"><code>Snowflake.number_op</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.number_op(hspace_size)</code></pre><p>Returns the number operator for a Fock space of size <code>hspace_size</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L593-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.coherent" href="#Snowflake.coherent"><code>Snowflake.coherent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.coherent(alpha, hspace_size)</code></pre><p>Returns a coherent state for the parameter <code>alpha</code> in a Fock space of size <code>hspace_size</code>. Note that |alpha|^2 is equal to the      photon number of the coherent state. </p><pre><code class="nohighlight hljs"># Examples</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ψ = Snowflake.coherent(2.0,20);

julia&gt; print(ψ)
20-element Ket:
0.13533528323661270231781372785917483270168304443359375 + 0.0im
0.2706705664732254046356274557183496654033660888671875 + 0.0im
0.3827859860416437253261507804308297496944779411605434060697044368322244814859633 + 0.0im
0.4420031841663186705315006220668383887063770056788388080454298547413058719111879 + 0.0im
0.4420031841663186705315006220668383887063770056788388080454298547413058719111879 + 0.0im
0.3953396664268989033516298387998153143981494385130297054512994395645417722835952 + 0.0im
0.3227934859426706749083446895240143309122789082442331409841890434072244670369041 + 0.0im
0.2440089396102658373848913914105868080225858281751344102479261185426274154783478 + 0.0im
0.1725403758685577344434702345068468523504659376126805082402433361167676595291802 + 0.0im
0.1150269172457051562956468230045645682336439584084536721601622240778451063527861 + 0.0im
0.07274941014482606043765122911007029674853133081310976424472247415659623989683902 + 0.0im
0.04386954494001140575894979175461054210856445342112420740912216424244799751166167 + 0.0im
0.02532809358034196997591593372015585816248494654573845414140041049288863525802268 + 0.0im
0.01404949847902665677216550321294394000313011924224810466364209088409881639691112 + 0.0im
0.007509772823502763531724947918871845905858490361570411398782773832262018118359266 + 0.0im
0.003878030010563633897440227516084030465660984499951448370503442999620168228954113 + 0.0im
0.001939015005281816948720113758042015232830492249975724185251721499810084114477056 + 0.0im
0.0009405604325217079112661845386949416195293171394724978755464370121167236584289665 + 0.0im
0.0004433844399679012093293182780011289711800019436937749734346315219336842860352511 + 0.0im
0.0002034387333640481868882144439914691756776463670619686354629916554722074664961924 + 0.0im


julia&gt; Snowflake.expected_value(Snowflake.number_op(20),ψ)
3.999999793648639261230596388008292158320219007459973469036845972185905095821291 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/qobj.jl#L606-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sesolve" href="#Snowflake.sesolve"><code>Snowflake.sesolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.sesolve(H::Operator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)
Snowflake.sesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)</code></pre><p>Solves the Shrodinger equation:</p><p><span>$\frac{d \Psi}{d t}=-i \hat{H}\Psi$</span></p><p><strong>Fields</strong></p><ul><li><code>H</code> – the Hamiltonian operator or a function that returns the Hamiltonian as a function of time.</li><li><code>ψ_0</code> – initital status of a quantum system</li><li><code>t_range</code> – time interval for which the system has to be simulated. </li><li><code>e_ops</code> – list of operators for which the expected value will be returned as a function of time. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/dynamic_system.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.mesolve" href="#Snowflake.mesolve"><code>Snowflake.mesolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.mesolve(H::Operator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)
Snowflake.mesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)</code></pre><p>Solves the Lindblad Master equation:</p><p><span>$\dot{\rho}=-i [H, \rho]+\sum_i \gamma_i\left(L_i \rho L^{\dag}_i - \frac{1}{2}\left\{L^{\dag}_i L_i, \rho\right\}\right)$</span></p><p><strong>Fields</strong></p><ul><li><code>H</code> – the Hamiltonian operator or a function that returns the Hamiltonian as a function of time.</li><li><code>ψ_0</code> – initital status of a quantum system</li><li><code>t_range</code> – time interval for which the system has to be simulated. </li><li><code>e_ops</code> – list of operators for which the expected value will be returned as function of time. </li><li><code>c_ops</code> – list of collapse operators <span>$L_i$</span>&#39;s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/dynamic_system.jl#L34-L48">source</a></section></article><h3 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h3><p>Snowflake provides multiple tools for visualizing quantum computer calculations.</p><article class="docstring"><header><a class="docstring-binding" id="Snowflake.plot_bloch_sphere-Tuple{QuantumCircuit}" href="#Snowflake.plot_bloch_sphere-Tuple{QuantumCircuit}"><code>Snowflake.plot_bloch_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bloch_sphere(circuit::QuantumCircuit;
    qubit_id::Int = 1,
    bloch_sphere::BlochSphere = BlochSphere())</code></pre><p>Plots the Bloch sphere of qubit <code>qubit_id</code> for the <code>circuit</code>.</p><p>If the <code>circuit</code> contains multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit <code>qubit_id</code>. The appearance of the Bloch sphere can be modified by passing a <a href="library.html#Snowflake.BlochSphere"><code>BlochSphere</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count=2, bit_count=0)
Quantum Circuit Object:
   id: c9ebdf08-f0ba-11ec-0c5e-8ff2bf2f3825 
   qubit_count: 2 
   bit_count: 0 
q[1]:
     
q[2]:


julia&gt; push_gate!(circuit, [hadamard(1), sigma_x(2)])
Quantum Circuit Object:
   id: c9ebdf08-f0ba-11ec-0c5e-8ff2bf2f3825 
   qubit_count: 2 
   bit_count: 0 
q[1]:──H──
          
q[2]:──X──

</code></pre><pre><code class="nohighlight hljs">julia&gt; plot = plot_bloch_sphere(circuit, qubit_id=2)
</code></pre><p><img src="assets/visualize/plot_bloch_sphere_for_circuit.png" alt="Bloch sphere for circuit"/></p><p>The Bloch sphere can be saved to a file by calling:</p><pre><code class="nohighlight hljs">julia&gt; PlotlyJS.savefig(plot, &quot;bloch_sphere.png&quot;, width=size(plot)[1],
                        height=size(plot)[2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/visualize.jl#L73-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.plot_bloch_sphere-Tuple{Ket}" href="#Snowflake.plot_bloch_sphere-Tuple{Ket}"><code>Snowflake.plot_bloch_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bloch_sphere(ket::Ket;
    qubit_id::Int = 1,
    bloch_sphere::BlochSphere = BlochSphere())</code></pre><p>Plots the Bloch sphere of qubit <code>qubit_id</code> for the state represented by <code>ket</code>.</p><p>If <code>ket</code> is associated with multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit <code>qubit_id</code>. The appearance of the Bloch sphere can be modified by passing a <a href="library.html#Snowflake.BlochSphere"><code>BlochSphere</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ket = Ket(1/sqrt(2)*[1, 1]);

julia&gt; print(ket)
2-element Ket:
0.7071067811865475 + 0.0im
0.7071067811865475 + 0.0im
</code></pre><pre><code class="nohighlight hljs">julia&gt; plot = plot_bloch_sphere(ket)
</code></pre><p><img src="assets/visualize/plot_bloch_sphere_for_ket.png" alt="Bloch sphere for ket"/></p><p>The Bloch sphere can be saved to a file by calling:</p><pre><code class="nohighlight hljs">julia&gt; PlotlyJS.savefig(plot, &quot;bloch_sphere.png&quot;, width=size(plot)[1],
                        height=size(plot)[2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/visualize.jl#L128-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.plot_bloch_sphere-Tuple{Operator}" href="#Snowflake.plot_bloch_sphere-Tuple{Operator}"><code>Snowflake.plot_bloch_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bloch_sphere(density_matrix::Operator;
    qubit_id::Int = 1,
    bloch_sphere::BlochSphere = BlochSphere())</code></pre><p>Plots the Bloch sphere of qubit <code>qubit_id</code> given the <code>density_matrix</code>.</p><p>If the <code>density_matrix</code> is associated with multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit <code>qubit_id</code>. The appearance of the Bloch sphere can be modified by passing a <a href="library.html#Snowflake.BlochSphere"><code>BlochSphere</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = Operator([1.0 0.0;
                     0.0 0.0])
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im
</code></pre><pre><code class="nohighlight hljs">julia&gt; plot = plot_bloch_sphere(ρ)
</code></pre><p><img src="assets/visualize/plot_bloch_sphere_for_operator.png" alt="Bloch sphere for operator"/></p><p>The Bloch sphere can be saved to a file by calling:</p><pre><code class="nohighlight hljs">julia&gt; PlotlyJS.savefig(plot, &quot;bloch_sphere.png&quot;, width=size(plot)[1],
                        height=size(plot)[2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/visualize.jl#L169-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.BlochSphere" href="#Snowflake.BlochSphere"><code>Snowflake.BlochSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlochSphere</code></pre><p>Contains fields which affect how a Bloch sphere is generated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ket = Ket(1/sqrt(2)*[1, 1]);

julia&gt; print(ket)
2-element Ket:
0.7071067811865475 + 0.0im
0.7071067811865475 + 0.0im

julia&gt; bloch_sphere = BlochSphere(vector_color=&quot;green&quot;);
</code></pre><pre><code class="nohighlight hljs">julia&gt; plot = plot_bloch_sphere(ket, bloch_sphere=bloch_sphere)
</code></pre><p><img src="assets/visualize/plot_green_bloch_sphere.png" alt="Bloch sphere for ket"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/visualize.jl#L25-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.plot_bloch_sphere_animation-Tuple{Vector{Ket}}" href="#Snowflake.plot_bloch_sphere_animation-Tuple{Vector{Ket}}"><code>Snowflake.plot_bloch_sphere_animation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bloch_sphere_animation(ket_list::Vector{Ket};
    qubit_id::Int = 1,
    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())</code></pre><p>Plots a Bloch sphere animation of qubit <code>qubit_id</code> for the states listed in <code>ket_list</code>.</p><p>If <code>ket_list</code> is associated with multiple qubits, the Bloch sphere animation is constructed from the 1-qubit reduced density matrices of qubit <code>qubit_id</code>. Animation settings and the appearance of the Bloch sphere can be modified by passing an <a href="library.html#Snowflake.AnimatedBlochSphere"><code>AnimatedBlochSphere</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ket_list = [Ket([1, 0]), Ket(1/sqrt(2)*[1, 1])];

julia&gt; plot = plot_bloch_sphere_animation(ket_list)
</code></pre><p>The Bloch sphere animation can be saved to an html file by calling:</p><pre><code class="nohighlight hljs">julia&gt; PlotlyJS.savefig(plot, &quot;bloch_sphere_animation.html&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/visualize.jl#L424-L449">source</a></section></article><iframe src="assets/visualize/plot_bloch_sphere_animation_for_ket.html"
style="height:825px;width:100%;">
</iframe><article class="docstring"><header><a class="docstring-binding" id="Snowflake.plot_bloch_sphere_animation-Tuple{Vector{Operator}}" href="#Snowflake.plot_bloch_sphere_animation-Tuple{Vector{Operator}}"><code>Snowflake.plot_bloch_sphere_animation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bloch_sphere_animation(density_matrix_list::Vector{Operator};
    qubit_id::Int = 1,
    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())</code></pre><p>Plots a Bloch sphere animation of qubit <code>qubit_id</code> for the states listed in <code>density_matrix_list</code>.</p><p>If <code>density_matrix_list</code> is associated with multiple qubits, the Bloch sphere animation is constructed from the 1-qubit reduced density matrices of qubit <code>qubit_id</code>. Animation settings and the appearance of the Bloch sphere can be modified by passing an <a href="library.html#Snowflake.AnimatedBlochSphere"><code>AnimatedBlochSphere</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ψ_0 = Operator([0.5 0.5; 0.5 0.5]);

julia&gt; ψ_1 = Operator([0.5 -0.5im; 0.5im 0.5]);

julia&gt; plot = plot_bloch_sphere_animation([ψ_0, ψ_1])
</code></pre><p>The Bloch sphere animation can be saved to an html file by calling:</p><pre><code class="nohighlight hljs">julia&gt; PlotlyJS.savefig(plot, &quot;bloch_sphere_animation.html&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/visualize.jl#L458-L486">source</a></section></article><iframe src="assets/visualize/plot_bloch_sphere_animation_for_operator.html"
style="height:825px;width:100%;">
</iframe><article class="docstring"><header><a class="docstring-binding" id="Snowflake.AnimatedBlochSphere" href="#Snowflake.AnimatedBlochSphere"><code>Snowflake.AnimatedBlochSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnimatedBlochSphere</code></pre><p>Contains fields which affect how a Bloch sphere animation is generated.</p><p><strong>Examples</strong></p><p>By default, additional Bloch sphere vectors are generated between each state using interpolation. The number of additional vectors can be changed by passing a value for the keyword <code>num_interpolated_points</code>.</p><pre><code class="nohighlight hljs">julia&gt; ket_list = [Ket([1, 0]), Ket(1/sqrt(2)*[1, 1])];

julia&gt; animated_sphere = AnimatedBlochSphere(num_interpolated_points=0,
        history_line_color=&quot;transparent&quot;, frame_duration=1000);

julia&gt; plot = plot_bloch_sphere_animation(ket_list, animated_bloch_sphere=animated_sphere)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/732ffa5abdfa0e0df4af58adcfdc4099327d557c/src/core/visualize.jl#L395-L414">source</a></section></article><iframe src="assets/visualize/plot_bloch_sphere_animation_without_interpolation.html"
style="height:825px;width:100%;">
</iframe></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="qc/basics.html">« Basics</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 15 February 2023 14:19">Wednesday 15 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
