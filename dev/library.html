<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Snowflake</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Snowflake logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Snowflake</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Quantum Computing With Snowflake</span><ul><li><a class="tocitem" href="qc/basics.html">Basics</a></li></ul></li><li class="is-active"><a class="tocitem" href="library.html">Library</a><ul class="internal"><li><a class="tocitem" href="#Quantum-Circuit"><span>Quantum Circuit</span></a></li><li><a class="tocitem" href="#Quantum-Gates"><span>Quantum Gates</span></a></li><li><a class="tocitem" href="#Quantum-Processing-Unit"><span>Quantum Processing Unit</span></a></li><li><a class="tocitem" href="#Quantum-Toolkit"><span>Quantum Toolkit</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="library.html">Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="library.html">Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/anyonlabs/Snowflake.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Quantum-Circuit"><a class="docs-heading-anchor" href="#Quantum-Circuit">Quantum Circuit</a><a id="Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.QuantumCircuit" href="#Snowflake.QuantumCircuit"><code>Snowflake.QuantumCircuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">    QuantumCircuit(qubit_count = .., bit_count = ...)</code></pre><p>A data structure to represent a <em>quantum circuit</em>.  </p><p><strong>Fields</strong></p><ul><li><code>qubit_count::Int</code> – number of qubits (i.e. quantum register size).</li><li><code>bit_count::Int</code> – number of classical bits (i.e. classical register size).</li><li><code>id::UUID</code> – a universally unique identifier for the circuit. A UUID is automatically generated once an instance is created. </li><li><code>pipeline::Array{Array{Gate}}</code> – the pipeline of gates to operate on qubits.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0)
Quantum Circuit Object:
   id: b2d2be56-7af2-11ec-31a6-ed9e71cb3360 
   qubit_count: 2 
   bit_count: 0 
q[1]:
     
q[2]:</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_circuit.jl#L2-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.push_gate!" href="#Snowflake.push_gate!"><code>Snowflake.push_gate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    push_gate!(circuit::QuantumCircuit, gate::Gate)
    push_gate!(circuit::QuantumCircuit, gates::Array{Gate})</code></pre><p>Pushes a single gate or an array of gates to the <code>circuit</code> pipeline. This function is mutable. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);

julia&gt; push_gate!(c, [hadamard(1),sigma_x(2)])
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:--H--
          
q[2]:--X--
          


julia&gt; push_gate!(c, control_x(1,2))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:--H----*--
            |  
q[2]:--X----X--</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_circuit.jl#L31-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.pop_gate!" href="#Snowflake.pop_gate!"><code>Snowflake.pop_gate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    pop_gate!(circuit::QuantumCircuit)</code></pre><p>Removes the last gate from <code>circuit.pipeline</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);

julia&gt; push_gate!(c, [hadamard(1),sigma_x(2)])
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:--H--
          
q[2]:--X--
          


julia&gt; push_gate!(c, control_x(1,2))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:--H----*--
            |  
q[2]:--X----X--

julia&gt; pop_gate!(c)
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:--H--
          
q[2]:--X--</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_circuit.jl#L83-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.simulate" href="#Snowflake.simulate"><code>Snowflake.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    simulate(circuit::QuantumCircuit)</code></pre><p>Simulates and returns the wavefunction of the quantum device after running <code>circuit</code>. </p><p>Employs the approach described in Listing 5 of <a href="https://doi.org/10.22331/q-2021-10-06-559">Suzuki <em>et. al.</em> (2021)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);

julia&gt; push_gate!(c, hadamard(1))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:--H--
          
q[2]:-----
          


julia&gt; push_gate!(c, control_x(1,2))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:--H----*--
            |  
q[2]:-------X--
               


julia&gt; ket = simulate(c);

julia&gt; print(ket)
4-element Ket:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_circuit.jl#L233-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.simulate_shots" href="#Snowflake.simulate_shots"><code>Snowflake.simulate_shots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    simulate_shots(c::QuantumCircuit, shots_count::Int = 100)</code></pre><p>Emulates a quantum computer by running a circuit for a given number of shots and returning measurement results.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Snowflake.QuantumCircuit(qubit_count = 2, bit_count = 0);

julia&gt; push_gate!(c, hadamard(1))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:--H--
          
q[2]:-----
          


julia&gt; push_gate!(c, control_x(1,2))
Quantum Circuit Object:
   id: 57cf5de2-7ba7-11ec-0e10-05c6faaf91e9 
   qubit_count: 2 
   bit_count: 0 
q[1]:--H----*--
            |  
q[2]:-------X--
               


julia&gt; simulate_shots(c, 99)
99-element Vector{String}:
 &quot;11&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 ⋮
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_circuit.jl#L387-L441">source</a></section></article><h2 id="Quantum-Gates"><a class="docs-heading-anchor" href="#Quantum-Gates">Quantum Gates</a><a id="Quantum-Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Gates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_x" href="#Snowflake.sigma_x"><code>Snowflake.sigma_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_x(target)</code></pre><p>Apply the Pauli X gate to the <code>target</code> qubit.</p><p>The Pauli X operator is</p><p class="math-container">\[\sigma_x = \begin{bmatrix}
    0 &amp; 1 \\      
    1 &amp; 0
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L126-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_y" href="#Snowflake.sigma_y"><code>Snowflake.sigma_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_y(target)</code></pre><p>Apply the Pauli Y gate to the <code>target</code> qubit.</p><p>The Pauli Y operator is</p><p class="math-container">\[\sigma_y = \begin{bmatrix}
    0 &amp; -i \\      
    i &amp; 0
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L141-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_z" href="#Snowflake.sigma_z"><code>Snowflake.sigma_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_z(target)</code></pre><p>Apply the Pauli Z gate to the <code>target</code> qubit.</p><p>The Pauli Z operator is</p><p class="math-container">\[\sigma_z = \begin{bmatrix}
    1 &amp; 0 \\      
    0 &amp; -1
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L156-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.hadamard" href="#Snowflake.hadamard"><code>Snowflake.hadamard</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hadamard(target)</code></pre><p>Apply the Hadamard gate to the <code>target</code> qubit.</p><p>The Hadamard operator is</p><p class="math-container">\[H = \frac{1}{\sqrt{2}} \begin{bmatrix}
    1 &amp; 1 \\      
    1 &amp; -1
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L171-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.phase" href="#Snowflake.phase"><code>Snowflake.phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase(target)</code></pre><p>Apply the phase gate (also known as the S gate) to the <code>target</code> qubit.</p><p>The phase operator is</p><p class="math-container">\[S = \begin{bmatrix}
    1 &amp; 0 \\      
    0 &amp; i
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L186-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.pi_8" href="#Snowflake.pi_8"><code>Snowflake.pi_8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pi_8(target)</code></pre><p>Apply the π/8 gate (also known as the T gate) to the <code>target</code> qubit.</p><p>The π/8 operator is</p><p class="math-container">\[T = \begin{bmatrix}
    1 &amp; 0 \\      
    0 &amp; e^{i\frac{\pi}{4}}
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L201-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.x_90" href="#Snowflake.x_90"><code>Snowflake.x_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x_90(target)</code></pre><p>Apply a 90° rotation about the X axis to the <code>target</code> qubit.</p><p>The corresponding operator is</p><p class="math-container">\[R_x(\pi) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\pi}{2}\right) &amp;
        -i\mathrm{sin}\left(\frac{\pi}{2}\right) \\[0.5em]      
    -i\mathrm{sin}\left(\frac{\pi}{2}\right) &amp;
        \mathrm{cos}\left(\frac{\pi}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L216-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation" href="#Snowflake.rotation"><code>Snowflake.rotation</code></a> — <span class="docstring-category">Function</span></header><section><div><p>rotation(target, theta, phi)</p><p>Apply a rotation <code>theta</code> to the <code>target</code> qubit about the cos(<code>phi</code>)X+sin(<code>phi</code>)Y axis.</p><p>The corresponding operator is</p><p class="math-container">\[R(\theta, \phi) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -i e^{-i\phi} \mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    -i e^{i\phi} \mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L233-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation_x" href="#Snowflake.rotation_x"><code>Snowflake.rotation_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_x(target, theta)</code></pre><p>Apply a rotation of <code>theta</code> about the X axis to the <code>target</code> qubit.</p><p>The corresponding operator is</p><p class="math-container">\[R_x(\theta) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -i\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    -i\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L251-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation_y" href="#Snowflake.rotation_y"><code>Snowflake.rotation_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_y(target, theta)</code></pre><p>Apply a rotation of <code>theta</code> about the Y axis to the <code>target</code> qubit.</p><p>The corresponding operator is</p><p class="math-container">\[R_y(\theta) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    \mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L269-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation_z" href="#Snowflake.rotation_z"><code>Snowflake.rotation_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_z(target, theta)</code></pre><p>Apply a rotation of <code>theta</code> about the Z axis to the <code>target</code> qubit.</p><p>The corresponding operator is</p><p class="math-container">\[R_z(\theta) = \begin{bmatrix}
    \mathrm{exp}\left(-i\frac{\theta}{2}\right) &amp; 0 \\[0.5em]      
    0 &amp; \mathrm{exp}\left(i\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L287-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.phase_shift" href="#Snowflake.phase_shift"><code>Snowflake.phase_shift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase_shift(target, phi)</code></pre><p>Apply a phase shift gate with phase shift <code>phi</code> to the <code>target</code> qubit.</p><p>The corresponding operator is</p><p class="math-container">\[P(\phi) = \begin{bmatrix}
    i &amp; 0 \\[0.5em]      
    0 &amp; e^{i\phi}
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L302-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.universal" href="#Snowflake.universal"><code>Snowflake.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">universal(target, theta, phi, lambda)</code></pre><p>Apply a gate which rotates the <code>target</code> qubit given the angles <code>theta</code>, <code>phi</code>, and <code>lambda</code>.</p><p>The corresponding operator is</p><p class="math-container">\[U(\theta, \phi, \lambda) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -e^{i\lambda}\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    e^{i\phi}\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        e^{i\left(\phi+\lambda\right)}\mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L317-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.control_z" href="#Snowflake.control_z"><code>Snowflake.control_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control_z(control_qubit, target_qubit)</code></pre><p>Apply a controlled-Z gate given a <code>control_qubit</code> and a <code>target_qubit</code>.</p><p>The controlled-Z operator is</p><p class="math-container">\[CZ = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\     
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1 \\  
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L340-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.control_x" href="#Snowflake.control_x"><code>Snowflake.control_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control_x(control_qubit, target_qubit)</code></pre><p>Apply a controlled-X gate (also known as a controlled NOT gate) given a <code>control_qubit</code> and a <code>target_qubit</code>.</p><p>The controlled-X operator is</p><p class="math-container">\[CX = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\     
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\  
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L358-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.iswap" href="#Snowflake.iswap"><code>Snowflake.iswap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswap(qubit_1, qubit_2)</code></pre><p>Apply an imaginary swap gate to <code>qubit_1</code> and <code>qubit_2</code>.</p><p>The imaginary swap operator is</p><p class="math-container">\[i\mathrm{SWAP} = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; i &amp; 0 \\     
    0 &amp; i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\  
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/quantum_gate.jl#L377-L391">source</a></section></article><h2 id="Quantum-Processing-Unit"><a class="docs-heading-anchor" href="#Quantum-Processing-Unit">Quantum Processing Unit</a><a id="Quantum-Processing-Unit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Processing-Unit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.QPU" href="#Snowflake.QPU"><code>Snowflake.QPU</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represnts a Quantum Processing Unit (QPU). <strong>Fields</strong></p><ul><li><code>manufacturer:: String</code> – qpu manufacturer (e.g. &quot;anyon&quot;)</li><li><code>generation:: String</code> – qpu generation (e.g. &quot;yukon&quot;)</li><li><code>serial_number:: String</code> – qpu serial_number (e.g. &quot;ANYK202201&quot;)</li><li><code>host:: String</code> – the remote host url address to send the jobs to</li><li><code>qubit_count:: Int</code> – number of physical qubits on the machine</li><li><code>connectivity::SparseArrays.SparseMatrixCSC{Int}</code> – a matrix describing the connectivity between qubits</li><li><code>native_gates:: Vector{String}</code> – the vector of native gates symbols supported by the qpu architecture</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qpu.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.create_virtual_qpu" href="#Snowflake.create_virtual_qpu"><code>Snowflake.create_virtual_qpu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_virtual_qpu(qubit_count::Int, connectivity::Matrix{Int},
    native_gates::Vector{String}, host = &quot;localhost:5600&quot;)</code></pre><p>Creates a virtual quantum processor with <code>qubit_count</code> number of qubits, a <code>connectivity</code> matrix, and a vector of <code>native_gates</code>.  The return value is a QPU stucture (see  <a href="library.html#Snowflake.QPU"><code>QPU</code></a>).</p><p><strong>Examples</strong></p><p>To generate a QPU structure, the connectivity must be specified. Let&#39;s assume that we have a 3-qubit device where there is connectivity between qubits 2 and 1 as well as between qubits 2 and 3. If qubit 2 can only be a control qubit, the connectivity matrix corresponds to:</p><pre><code class="language-julia-repl hljs">julia&gt; connectivity = [1 0 0
                       1 1 1
                       0 0 1]
3×3 Matrix{Int64}:
 1  0  0
 1  1  1
 0  0  1</code></pre><p>Here, the ones in the diagonal indicate that all qubits can perform single-qubit gates. If there is a one in an off-diagonal entry with row i and column j, it indicates that a two-qubit gate with control qubit i and target qubit j can be applied.</p><p>If the native gates are the Pauli-X gate, the Hadamard gate, and the control-X gate, the QPU can be created as follows: </p><pre><code class="language-julia-repl hljs">julia&gt; qpu = create_virtual_qpu(3, connectivity, [&quot;x&quot;, &quot;h&quot;, &quot;cx&quot;])
Quantum Processing Unit:
   manufacturer: none
   generation: none 
   serial_number: 00 
   host: localhost:5600 
   qubit_count: 3 
   native_gates: [&quot;x&quot;, &quot;h&quot;, &quot;cx&quot;] 
   connectivity = sparse([1, 2, 2, 2, 3], [1, 1, 2, 3, 3], [1, 1, 1, 1, 1], 3, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qpu.jl#L34-L75">source</a></section></article><h2 id="Quantum-Toolkit"><a class="docs-heading-anchor" href="#Quantum-Toolkit">Quantum Toolkit</a><a id="Quantum-Toolkit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Toolkit" title="Permalink"></a></h2><h3 id="Basic-Quantum-Objects"><a class="docs-heading-anchor" href="#Basic-Quantum-Objects">Basic Quantum Objects</a><a id="Basic-Quantum-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Quantum-Objects" title="Permalink"></a></h3><p>There are three basic quantum objects in Snowflake to simulate a quantum system. These objects are Ket, Bra, and Operator.</p><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Ket" href="#Snowflake.Ket"><code>Snowflake.Ket</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Ket represents a <em>quantum wavefunction</em> and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.  </p><p><strong>Fields</strong></p><ul><li><code>data</code> – the stored values.</li></ul><p><strong>Examples</strong></p><p>Although NOT the preferred way, one can directly build a Ket object by passing a column vector as the initializer. </p><pre><code class="language-julia-repl hljs">julia&gt; using Snowflake

julia&gt; ψ = Snowflake.Ket([1.0; 0.0; 0.0]);

julia&gt; print(ψ)
3-element Ket:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im</code></pre><p>A better way to initialize a Ket is to use a pre-built basis such as the <code>fock</code> basis. See <a href="library.html#Snowflake.fock"><code>fock</code></a> for further information on this function. </p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Snowflake.fock(2, 3);

julia&gt; print(ψ)
3-element Ket:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Bra" href="#Snowflake.Bra"><code>Snowflake.Bra</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a Bra (i.e. a row vector of complex values). A Bra is created as the complex conjugate of a Ket.</p><p><strong>Fields</strong></p><ul><li><code>data</code> – the stored values.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Snowflake.fock(1, 3);

julia&gt; print(ψ)
3-element Ket:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im

julia&gt; _ψ = Snowflake.Bra(ψ);

julia&gt; print(_ψ)
Bra(Any[0.0 - 0.0im 1.0 - 0.0im 0.0 - 0.0im])


julia&gt; _ψ * ψ    # A Bra times a Ket is a scalar
1.0 + 0.0im

julia&gt; ψ*_ψ     # A Ket times a Bra is an operator
(3, 3)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L40-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Operator" href="#Snowflake.Operator"><code>Snowflake.Operator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a quantum operator (i.e. a complex matrix).</p><p><strong>Fields</strong></p><ul><li><code>data</code> – the complex matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = Snowflake.Operator([1.0 0.0;0.0 -1.0])
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    -1.0 + 0.0im
</code></pre><p>Alternatively:</p><pre><code class="language-julia-repl hljs">julia&gt; z = Snowflake.sigma_z()  #sigma_z is a defined function in Snowflake
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    -1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L78-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.adjoint(x)</code></pre><p>Compute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Operator, Int64, Int64}" href="#Base.getindex-Tuple{Operator, Int64, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(A::Operator, m::Int64, n::Int64)</code></pre><p>Return the element at row <code>m</code> and column <code>n</code> of Operator <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.eigen" href="#Snowflake.eigen"><code>Snowflake.eigen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigen(A::Operator)</code></pre><p>Compute the eigenvalue decomposition of Operator <code>A</code> and return an <code>Eigen</code> factorization object <code>F</code>. Eigenvalues are found in <code>F.values</code> while eigenvectors are found in the matrix <code>F.vectors</code>. Each column of this matrix corresponds to an eigenvector. The <code>i</code>th eigenvector is extracted by calling <code>F.vectors[:, i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = sigma_x()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im

julia&gt; F = eigen(X);

julia&gt; eigenvalues = F.values
2-element Vector{Float64}:
 -1.0
  1.0

julia&gt; eigenvector_1 = F.vectors[:, 1]
2-element Vector{ComplexF64}:
 -0.7071067811865475 + 0.0im
  0.7071067811865475 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L138-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.tr" href="#Snowflake.tr"><code>Snowflake.tr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tr(A::Operator)</code></pre><p>Compute the trace of Operator <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; I = eye()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
1.0 + 0.0im    0 + 0im
0 + 0im    1.0 + 0.0im


julia&gt; trace = tr(I)
2.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L169-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.expected_value" href="#Snowflake.expected_value"><code>Snowflake.expected_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expected_value(A::Operator, psi::Ket)</code></pre><p>Compute the expectation value ⟨<code>ψ</code>|<code>A</code>|<code>ψ</code>⟩ given Operator <code>A</code> and Ket |<code>ψ</code>⟩.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([0.0; 1.0]);

julia&gt; print(ψ)
2-element Ket:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; A = sigma_z()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    -1.0 + 0.0im


julia&gt; expected_value(A, ψ)
-1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L189-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kron(x, y)</code></pre><p>Compute the Kronecker product of two <a href="library.html#Snowflake.Ket"><code>Kets</code></a> or two <a href="library.html#Snowflake.Operator"><code>Operators</code></a>. More details about the Kronecker product can be found <a href="https://en.wikipedia.org/wiki/Kronecker_product">here</a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = Ket([0.0; 1.0]);

julia&gt; print(ψ_0)
2-element Ket:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; ψ_1 = Ket([1.0; 0.0]);

julia&gt; print(ψ_1)
2-element Ket:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ_0_1 = kron(ψ_0, ψ_1);

julia&gt; print(ψ_0_1)
4-element Ket:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; kron(sigma_x(), sigma_y())
(4, 4)-element Snowflake.Operator:
Underlying data Matrix{Complex}:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L224-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.MultiBodySystem" href="#Snowflake.MultiBodySystem"><code>Snowflake.MultiBodySystem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a quantum multi-body system.</p><p><strong>Fields</strong></p><ul><li><code>hilbert_space_structure</code> – a vector of integers specifying the local Hilbert space size for each &quot;body&quot; within the multi-body system. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.commute" href="#Snowflake.commute"><code>Snowflake.commute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.commute(A::Operator, B::Operator)</code></pre><p>Returns the commutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = sigma_x()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im


julia&gt; σ_y = sigma_y()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    0.0 - 1.0im
0.0 + 1.0im    0.0 + 0.0im


julia&gt; Snowflake.commute(σ_x,σ_y)
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 2.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 - 2.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L501-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.anticommute" href="#Snowflake.anticommute"><code>Snowflake.anticommute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.anticommute(A::Operator, B::Operator)</code></pre><p>Returns the anticommutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = Snowflake.sigma_x()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im


julia&gt; Snowflake.anticommute(σ_x,σ_x)
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
2.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    2.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L531-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.normalize!" href="#Snowflake.normalize!"><code>Snowflake.normalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.normalize!(x::Ket)</code></pre><p>Normalizes Ket <code>x</code> such that its magnitude becomes unity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L490-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.ket2dm" href="#Snowflake.ket2dm"><code>Snowflake.ket2dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.ket2dm(ψ)</code></pre><p>Returns the density matrix corresponding to the pure state ψ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L554-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.fock_dm" href="#Snowflake.fock_dm"><code>Snowflake.fock_dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.fock_dm(i, hspace_size)</code></pre><p>Returns the density matrix corresponding to the Fock base <code>i</code> defined in a Hilbert space of size <code>hspace_size</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L563-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.moyal" href="#Snowflake.moyal"><code>Snowflake.moyal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.moyal(m, n)</code></pre><p>Returns the Moyal function <code>w_mn(eta)</code> for Fock states <code>m</code> and <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L587-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.genlaguerre" href="#Snowflake.genlaguerre"><code>Snowflake.genlaguerre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.genlaguerre(x, alpha, n)</code></pre><p>Returns the generalized Laguerre polynomial of degree <code>n</code> for <code>x</code> using a recursive method. See <a href="https://en.wikipedia.org/wiki/Laguerre_polynomials">https://en.wikipedia.org/wiki/Laguerre_polynomials</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L599-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_embed_operator" href="#Snowflake.get_embed_operator"><code>Snowflake.get_embed_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_embed_operator(op::Operator, target_body_index::Int, system::MultiBodySystem)</code></pre><p>Uses a local operator (<code>op</code>), which is defined for a particular body (e.g. qubit) with index <code>target_body_index</code>, to build the corresponding operator for the Hilbert space of the multi-body system given by <code>system</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; system = Snowflake.MultiBodySystem(3,2)
Snowflake.Multibody system with 3 bodies
   Hilbert space structure:
   [2, 2, 2]

julia&gt; x = Snowflake.sigma_x()
(2, 2)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im

julia&gt; X_1=Snowflake.get_embed_operator(x,1,system)
(8, 8)-element Snowflake.Operator:
Underlying data Matrix{Complex}: 
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L293-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.fock" href="#Snowflake.fock"><code>Snowflake.fock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.fock(i, hspace_size)</code></pre><p>Returns the <code>i</code>th fock basis of a Hilbert space with size <code>hspace_size</code> as Snowflake.Ket.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Snowflake.fock(0, 3);

julia&gt; print(ψ)
3-element Ket:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ = Snowflake.fock(1, 3);

julia&gt; print(ψ)
3-element Ket:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L371-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.create" href="#Snowflake.create"><code>Snowflake.create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.create(hspace_size)</code></pre><p>Returns the bosonic creation operator for a Fock space of size <code>hspace_size</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L404-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.destroy" href="#Snowflake.destroy"><code>Snowflake.destroy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.destroy(hspace_size)</code></pre><p>Returns the bosonic annhilation operator for a Fock space of size <code>hspace_size</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L417-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.number_op" href="#Snowflake.number_op"><code>Snowflake.number_op</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.number_op(hspace_size)</code></pre><p>Returns the number operator for a Fock space of size <code>hspace_size</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L430-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.coherent" href="#Snowflake.coherent"><code>Snowflake.coherent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.coherent(alpha, hspace_size)</code></pre><p>Returns a coherent state for the parameter <code>alpha</code> in a Fock space of size <code>hspace_size</code>. Note that |alpha|^2 is equal to the      photon number of the coherent state. </p><pre><code class="nohighlight hljs"># Examples</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ψ = Snowflake.coherent(2.0,20);

julia&gt; print(ψ)
20-element Ket:
0.13533528323661270231781372785917483270168304443359375 + 0.0im
0.2706705664732254046356274557183496654033660888671875 + 0.0im
0.3827859860416437253261507804308297496944779411605434060697044368322244814859633 + 0.0im
0.4420031841663186705315006220668383887063770056788388080454298547413058719111879 + 0.0im
0.4420031841663186705315006220668383887063770056788388080454298547413058719111879 + 0.0im
0.3953396664268989033516298387998153143981494385130297054512994395645417722835952 + 0.0im
0.3227934859426706749083446895240143309122789082442331409841890434072244670369041 + 0.0im
0.2440089396102658373848913914105868080225858281751344102479261185426274154783478 + 0.0im
0.1725403758685577344434702345068468523504659376126805082402433361167676595291802 + 0.0im
0.1150269172457051562956468230045645682336439584084536721601622240778451063527861 + 0.0im
0.07274941014482606043765122911007029674853133081310976424472247415659623989683902 + 0.0im
0.04386954494001140575894979175461054210856445342112420740912216424244799751166167 + 0.0im
0.02532809358034196997591593372015585816248494654573845414140041049288863525802268 + 0.0im
0.01404949847902665677216550321294394000313011924224810466364209088409881639691112 + 0.0im
0.007509772823502763531724947918871845905858490361570411398782773832262018118359266 + 0.0im
0.003878030010563633897440227516084030465660984499951448370503442999620168228954113 + 0.0im
0.001939015005281816948720113758042015232830492249975724185251721499810084114477056 + 0.0im
0.0009405604325217079112661845386949416195293171394724978755464370121167236584289665 + 0.0im
0.0004433844399679012093293182780011289711800019436937749734346315219336842860352511 + 0.0im
0.0002034387333640481868882144439914691756776463670619686354629916554722074664961924 + 0.0im


julia&gt; Snowflake.expected_value(Snowflake.number_op(20),ψ)
3.999999793648639261230596388008292158320219007459973469036845972185905095821291 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/qobj.jl#L443-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sesolve" href="#Snowflake.sesolve"><code>Snowflake.sesolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.sesolve(H::Operator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)
Snowflake.sesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)</code></pre><p>Solves the Shrodinger equation:</p><p><span>$\frac{d \Psi}{d t}=-i \hat{H}\Psi$</span></p><p><strong>Fields</strong></p><ul><li><code>H</code> – the Hamiltonian operator or a function that returns the Hamiltonian as a function of time.</li><li><code>ψ_0</code> – initital status of a quantum system</li><li><code>t_range</code> – time interval for which the system has to be simulated. </li><li><code>e_ops</code> – list of operators for which the expected value will be returned as a function of time. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/dynamic_system.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.mesolve" href="#Snowflake.mesolve"><code>Snowflake.mesolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Snowflake.mesolve(H::Operator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)
Snowflake.mesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[], kwargs...)</code></pre><p>Solves the Lindblad Master equation:</p><p><span>$\dot{\rho}=-i [H, \rho]+\sum_i \gamma_i\left(L_i \rho L^{\dag}_i - \frac{1}{2}\left\{L^{\dag}_i L_i, \rho\right\}\right)$</span></p><p><strong>Fields</strong></p><ul><li><code>H</code> – the Hamiltonian operator or a function that returns the Hamiltonian as a function of time.</li><li><code>ψ_0</code> – initital status of a quantum system</li><li><code>t_range</code> – time interval for which the system has to be simulated. </li><li><code>e_ops</code> – list of operators for which the expected value will be returned as function of time. </li><li><code>c_ops</code> – list of collapse operators <span>$L_i$</span>&#39;s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/12be6520b7af999ae9087743754f2a4d54f0972c/src/core/dynamic_system.jl#L34-L48">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="qc/basics.html">« Basics</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Thursday 25 August 2022 14:56">Thursday 25 August 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
