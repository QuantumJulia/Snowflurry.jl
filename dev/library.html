<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Snowflake</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Snowflake logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Snowflake</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Quantum Computing With Snowflake</span><ul><li><a class="tocitem" href="qc/basics.html">Basics</a></li></ul></li><li class="is-active"><a class="tocitem" href="library.html">Library</a><ul class="internal"><li><a class="tocitem" href="#Quantum-Circuit"><span>Quantum Circuit</span></a></li><li><a class="tocitem" href="#Quantum-Gates"><span>Quantum Gates</span></a></li><li><a class="tocitem" href="#Quantum-Processing-Unit"><span>Quantum Processing Unit</span></a></li><li><a class="tocitem" href="#Quantum-Toolkit"><span>Quantum Toolkit</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="library.html">Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="library.html">Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/anyonlabs/Snowflake.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Quantum-Circuit"><a class="docs-heading-anchor" href="#Quantum-Circuit">Quantum Circuit</a><a id="Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.QuantumCircuit" href="#Snowflake.QuantumCircuit"><code>Snowflake.QuantumCircuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuantumCircuit(qubit_count)</code></pre><p>A data structure to represent a <em>quantum circuit</em>.  </p><p><strong>Fields</strong></p><ul><li><code>qubit_count::Int</code> – number of qubits (i.e. quantum register size).</li><li><code>gates::Array{Array{Gate}}</code> – the sequence of gates to operate on qubits.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push!(circuit::QuantumCircuit, gate::AbstractGate)
push!(circuit::QuantumCircuit, gates::Array{AbstractGate})</code></pre><p>Pushes a single gate or an array of gates to the <code>circuit</code> gates. This function is mutable. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, [hadamard(1),sigma_x(2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L40-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pop!(circuit::QuantumCircuit)</code></pre><p>Removes the last gate from <code>circuit.gates</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, [hadamard(1),sigma_x(2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; pop!(c)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L297-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.simulate" href="#Snowflake.simulate"><code>Snowflake.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(circuit::QuantumCircuit)</code></pre><p>Simulates and returns the wavefunction of the quantum device after running <code>circuit</code>. </p><p>Employs the approach described in Listing 5 of <a href="https://doi.org/10.22331/q-2021-10-06-559">Suzuki <em>et. al.</em> (2021)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; ket = simulate(c)
4-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L496-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.simulate_shots" href="#Snowflake.simulate_shots"><code>Snowflake.simulate_shots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_shots(c::QuantumCircuit, shots_count::Int = 100)</code></pre><p>Emulates a quantum computer by running a circuit for a given number of shots and returning measurement results.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; simulate_shots(c, 99)
99-element Vector{String}:
 &quot;11&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 ⋮
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L546-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_measurement_probabilities-Tuple{QuantumCircuit}" href="#Snowflake.get_measurement_probabilities-Tuple{QuantumCircuit}"><code>Snowflake.get_measurement_probabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_measurement_probabilities(circuit::QuantumCircuit,
    [target_qubits::Vector{&lt;:Integer}])::AbstractVector{&lt;:Real}</code></pre><p>Returns a vector listing the measurement probabilities for the <code>target_qubits</code> in the <code>circuit</code>.</p><p>If no <code>target_qubits</code> are provided, the probabilities are computed for all the qubits.</p><p>The measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit <code>QuantumCircuit</code>, the probabilities are listed for 00, 01, 10, and 11.</p><p><strong>Examples</strong></p><p>The following example constructs a <code>QuantumCircuit</code> where the probability of measuring 01 is 50% and the probability of measuring 11 is also 50%.</p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count=2);

julia&gt; push!(circuit, [hadamard(1), sigma_x(2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; get_measurement_probabilities(circuit)
4-element Vector{Float64}:
 0.0
 0.4999999999999999
 0.0
 0.4999999999999999
</code></pre><p>For the same <code>circuit</code>, the probability of measuring qubit 2 and finding 1 is 100%.</p><pre><code class="language-julia-repl hljs">julia&gt; target_qubit = [2];

julia&gt; get_measurement_probabilities(circuit, target_qubit)
2-element Vector{Float64}:
 0.0
 0.9999999999999998
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L620-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{QuantumCircuit}" href="#Base.inv-Tuple{QuantumCircuit}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(circuit::QuantumCircuit)</code></pre><p>Return a <code>QuantumCircuit</code> which is the inverse of the input <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, rotation_y(1, pi/4));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Ry(0.7854)────*──
                     |  
q[2]:────────────────X──
                        



julia&gt; inv(c)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──*────Ry(-0.7854)──
       |                 
q[2]:──X─────────────────
                         


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L679-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_gates_per_type" href="#Snowflake.get_num_gates_per_type"><code>Snowflake.get_num_gates_per_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_gates_per_type(circuit::QuantumCircuit)::AbstractDict{&lt;:AbstractString, &lt;:Integer}</code></pre><p>Returns a dictionary listing the number of gates of each type found in the <code>circuit</code>.</p><p>The dictionary keys are the instruction_symbol of the gates while the values are the number of gates found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, [hadamard(1), hadamard(2)]);

julia&gt; push!(c, control_x(1, 2));

julia&gt; push!(c, hadamard(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*───────
                 |       
q[2]:───────H────X────H──
                         



julia&gt; get_num_gates_per_type(c)
Dict{String, Int64} with 2 entries:
  &quot;h&quot;  =&gt; 3
  &quot;cx&quot; =&gt; 1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L722-L753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_gates" href="#Snowflake.get_num_gates"><code>Snowflake.get_num_gates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_gates(circuit::QuantumCircuit)::Integer</code></pre><p>Returns the number of gates in the <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, [hadamard(1), hadamard(2)]);

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────H────X──
                    



julia&gt; get_num_gates(c)
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L767-L792">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.serialize_job" href="#Snowflake.serialize_job"><code>Snowflake.serialize_job</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">serialize_job(circuit::QuantumCircuit,repetitions::Integer)</code></pre><p>Creates a JSON-formatted String containing the circuit configuration to be sent  to a <code>QPU</code> service, along with the number of repetitions requested.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2,gates=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; serialize_job(c,10)
&quot;{\&quot;num_repititions\&quot;:10,\&quot;circuit\&quot;:{\&quot;operations\&quot;:[{\&quot;parameters\&quot;:{},\&quot;type\&quot;:\&quot;x\&quot;,\&quot;qubits\&quot;:[0]}]}}&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/qpu_interface.jl#L106-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.transpile" href="#Snowflake.transpile"><code>Snowflake.transpile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transpile(::CompressSingleQubitGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CompressSingleQubitGatesTranspiler</code> transpiler stage  which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single universal gates in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CompressSingleQubitGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X────Y──
               
q[2]:──────────
               



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y─────────P(1.0472)──
                                 
q[2]:────────────*───────────────
                 |               
q[3]:────────────X───────────────
                                 



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────
                                            
q[2]:────────────────────────────────────*──
                                         |  
q[3]:────────────────────────────────────X──
                                            




julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/transpile.jl#L138-L204">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastSwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastSwapToCZGateTranspiler</code> transpiler stage which expands all Swap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastSwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[swap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──☒──
       |
q[2]:──☒──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────
                |                     |                     |          
q[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──
                                              
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/transpile.jl#L374-L402">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastCXToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastCZToCZGateTranspiler</code> transpiler stage which expands all CX gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastCXToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──*──
       |
q[2]:──X──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2
q[1]:───────*───────
            |
q[2]:──H────Z────H──</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/transpile.jl#L433-L459">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastISwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastISwapToCZGateTranspiler</code> transpiler stage which expands all ISwap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastISwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[iswap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──x──
       |
q[2]:──x──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────
                         |                     |                  
q[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──
                                                                  
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/transpile.jl#L495-L523">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastToffoliToCXGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastToffoliToCXGateTranspiler</code> transpiler stage which expands all Toffoli gates into CX gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; transpiler=Snowflake.CastToffoliToCXGateTranspiler();</p><p>julia&gt; circuit = QuantumCircuit(qubit<em>count = 3, gates=[toffoli(1, 2, 3)]) Quantum Circuit Object:    qubit</em>count: 3 q[1]:──<em>──        | q[2]:──</em>──        | q[3]:──X──</p><p>julia&gt; transpile(transpiler,circuit) Quantum Circuit Object:    qubit_count: 3 Part 1 of 2 q[1]:──────────────────<em>────────────────────</em>──────────────<em>───────                        |                    |              | q[2]:───────</em>──────────|─────────*──────────|────T─────────X───────             |          |         |          | q[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──</p><p>Part 2 of 2 q[1]:──T──────────*──                   | q[2]:───────T†────X──</p><p>q[3]:────────────────```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/transpile.jl#L572-L610">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastToPhaseShiftAndHalfRotationX, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastToPhaseShiftAndHalfRotationX</code> transpiler stage  which converts all single-qubit gates in an input circuit and converts them  into combinations of PhaseShift and RotationX with angle π/2 in an output  circuit. For any gate in the input circuit, the number of gates in the  output varies between zero and 5. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.CastToPhaseShiftAndHalfRotationX();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────X_90────Z────X_m90──
                                                 
q[2]:───────────────────────────
                                                 



julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Y──
          
q[2]:─────
          



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z_90────X_90────Z────X_m90────Z_90──
                                           
q[2]:──────────────────────────────────────
                                           



julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/transpile.jl#L710-L791">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::SimplifyRxGates, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyRxGates</code> transpiler stage  which finds RotationX gates in an input circuit and according to it&#39;s  angle theta, casts them to one of the right-angle RotationX gates,  e.g. SigmaX, X90, or XM90. In the case where theta≈0., the gate is removed. The result of the input and output circuit on any arbitrary state Ket is  unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.SimplifyRxGates();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(1.5708)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(3.1416)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(0.0000)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/transpile.jl#L826-L902">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::PlaceOperationsOnLine, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>PlaceOperationsOnLine</code> transpiler stage  which adds Swap gates around multi-qubit gates so that the  final operator acts on adjacent qubits. The result of the input  and output circuit on any arbitrary state Ket is unchanged  (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.PlaceOperationsOnLine();

julia&gt; circuit = QuantumCircuit(qubit_count = 6, gates=[toffoli(4,6,1)])
Quantum Circuit Object:
   qubit_count: 6 
q[1]:──X──
       |  
q[2]:──|──
       |  
q[3]:──|──
       |  
q[4]:──*──
       |  
q[5]:──|──
       |  
q[6]:──*──
          




julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 6 
q[1]:───────────────────────────X───────────────────────────
                                |                           
q[2]:───────☒───────────────────*───────────────────☒───────
            |                   |                   |       
q[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──
       |                   |         |                   |  
q[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──
                      |                   |                 
q[5]:────────────☒────☒───────────────────☒────☒────────────
                 |                             |            
q[6]:────────────☒─────────────────────────────☒────────────
                                                            



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/transpile.jl#L970-L1024">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.compare_circuits" href="#Snowflake.compare_circuits"><code>Snowflake.compare_circuits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_circuits(c0::QuantumCircuit,c1::QuantumCircuit)::Bool</code></pre><p>Tests for equivalence of two circuits based on their effect on an  arbitrary input state (a Ket). Circuits are equivalent if they both  yield the same output for any input, up to a global phase. Circuits with different ordering of gates that apply on different  targets can also be equivalent.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c0 = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──X────Y──
               



julia&gt; c1 = QuantumCircuit(qubit_count = 1, gates=[phase_shift(1,π)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──P(3.1416)──
                  



julia&gt; compare_circuits(c0,c1)
true            

julia&gt; c0 = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y───────
                    
q[2]:────────────*──
                 |  
q[3]:────────────X──
                    



julia&gt; c1 = QuantumCircuit(qubit_count = 3, gates=[control_x(2,3),sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:───────X────Y──
                    
q[2]:──*────────────
       |            
q[3]:──X────────────
                    



julia&gt; compare_circuits(c0,c1)
true    
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L86-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.circuit_contains_gate_type" href="#Snowflake.circuit_contains_gate_type"><code>Snowflake.circuit_contains_gate_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circuit_contains_gate_type(circuit::QuantumCircuit, gate_type::Type{&lt;:AbstractGate})::Bool</code></pre><p>Determined whether or not a type of gate is present in a circuit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──X────Y──
               
julia&gt; circuit_contains_gate_type(circuit, Snowflake.SigmaX)
true
               
julia&gt; circuit_contains_gate_type(circuit, Snowflake.ControlZ)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_circuit.jl#L169-L187">source</a></section></article><h2 id="Quantum-Gates"><a class="docs-heading-anchor" href="#Quantum-Gates">Quantum Gates</a><a id="Quantum-Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Gates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.AbstractGate" href="#Snowflake.AbstractGate"><code>Snowflake.AbstractGate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGate</code></pre><p>A <code>Gate</code> is an instantiation of an <code>AbstractGate</code>, which can be added to a <code>QuantumCircuit</code> in order to apply an operator to one or more <code>target</code> qubits. <code>AbstractGate</code> is useful to dispatch all <code>Gates</code> to default implementation of functions such as get<em>connected</em>qubits().  Those functions are then specialized for <code>Gates</code> requiring a different implementation. </p><p><code>AbstractGate</code> is an abstract type, which means that it cannot be instantiated.  Instead, each concrete type of <code>Gate</code> is a struct which is a subtype of <code>AbstractGate</code>. Each descendant of <code>AbstractGate</code> must have at least the following fields:</p><ul><li><code>target::Int</code>: the qubit number to which the <code>Gate</code> is applied. Some gates have multiple targets.</li><li><code>parameter::Real</code>: for parameterized gates, determines which operation is applied (e.g. rotation angles), i.e., is used in the construction of the matrix used in the application of its <code>Operator</code>.</li></ul><p><strong>Examples</strong></p><p>A struct must be defined for each new gate type, such as the following X_45 gate which applies a 45° rotation about the X axis:</p><pre><code class="language-julia-repl hljs">julia&gt; struct X45 &lt;: AbstractGate
           target::Int
       end;
</code></pre><p>For convenience, a constructor can be defined:</p><pre><code class="language-julia-repl hljs">julia&gt; x_45(target::Integer) = X45(target);
</code></pre><p>To simulate the effect of the gate in a <code>QuantumCircuit</code> or when applied to a <code>Ket</code>, the function <code>get_operator</code> must be extended.</p><pre><code class="language-julia-repl hljs">julia&gt; Snowflake.get_operator(gate::X45, T::Type{&lt;:Complex}=ComplexF64) = rotation_x(π/4, T);
</code></pre><p>The gate inverse can also be specified by extending the <code>inv</code> function.</p><pre><code class="language-julia-repl hljs">julia&gt; inv(gate::X45) = rotation_x(gate.target, -π/4);
</code></pre><p>An instance of the X_45 gate can now be created:</p><pre><code class="language-julia-repl hljs">julia&gt; x_45_gate = x_45(1)
Gate Object: X45
Connected_qubits	: [1]
Operator:
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im
0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im


julia&gt; inv(x_45_gate)
Gate Object: Snowflake.RotationX
Parameters: 
theta	: -0.7853981633974483

Connected_qubits	: [1]
Operator:
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.9238795325112867 + 0.0im    -0.0 + 0.3826834323650898im
-0.0 + 0.3826834323650898im    0.9238795325112867 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L3-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.eye" href="#Snowflake.eye"><code>Snowflake.eye</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eye()</code></pre><p>Return the identity <code>Operator</code>, which is defined as:</p><p class="math-container">\[I = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L526-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_p" href="#Snowflake.sigma_p"><code>Snowflake.sigma_p</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_p()</code></pre><p>Return the spin-<span>$\frac{1}{2}$</span> raising <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_+ = \begin{bmatrix}
    0 &amp; 1 \\
    0 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L435-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_m" href="#Snowflake.sigma_m"><code>Snowflake.sigma_m</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_m()</code></pre><p>Return the spin-<span>$\frac{1}{2}$</span> lowering <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_- = \begin{bmatrix}
    0 &amp; 0 \\
    1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L448-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_x" href="#Snowflake.sigma_x"><code>Snowflake.sigma_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_x()</code></pre><p>Return the Pauli-X <code>AntiDiagonalOperator</code>, which is defined as:</p><p class="math-container">\[\sigma_x = \begin{bmatrix}
    0 &amp; 1 \\
    1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L396-L406">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_x(target)</code></pre><p>Return the Pauli-X <code>Gate</code>, which applies the <a href="library.html#Snowflake.sigma_x"><code>sigma_x()</code></a> <code>AntiDiagonalOperator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L860-L864">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_y" href="#Snowflake.sigma_y"><code>Snowflake.sigma_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_y()</code></pre><p>Return the Pauli-Y <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_y = \begin{bmatrix}
    0 &amp; -i \\
    i &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L409-L419">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_y(target)</code></pre><p>Return the Pauli-Y <code>Gate</code>, which applies the <a href="library.html#Snowflake.sigma_y"><code>sigma_y()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L891-L895">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sigma_z" href="#Snowflake.sigma_z"><code>Snowflake.sigma_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_z()</code></pre><p>Return the Pauli-Z <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_z = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L422-L432">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_z(target)</code></pre><p>Return the Pauli-Z <code>Gate</code>, which applies the <a href="library.html#Snowflake.sigma_z"><code>sigma_z()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L905-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.hadamard" href="#Snowflake.hadamard"><code>Snowflake.hadamard</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hadamard()</code></pre><p>Return the Hadamard <code>Operator</code>, which is defined as:</p><p class="math-container">\[H = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L461-L471">source</a></section><section><div><pre><code class="nohighlight hljs">hadamard(target)</code></pre><p>Return the Hadamard <code>Gate</code>, which applies the <a href="library.html#Snowflake.hadamard"><code>hadamard()</code></a> <code>Operator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L918-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.phase" href="#Snowflake.phase"><code>Snowflake.phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase()</code></pre><p>Return the phase gate <code>Operator</code>, which is defined as:</p><p class="math-container">\[S = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; i
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L474-L484">source</a></section><section><div><pre><code class="nohighlight hljs">phase(target)</code></pre><p>Return a phase <code>Gate</code> (also known as an <span>$S$</span> <code>Gate</code>), which applies the <a href="library.html#Snowflake.phase"><code>phase()</code></a> <code>DiagonalOperator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L931-L935">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.phase_dagger" href="#Snowflake.phase_dagger"><code>Snowflake.phase_dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase_dagger()</code></pre><p>Return the adjoint phase gate <code>Operator</code>, which is defined as:</p><p class="math-container">\[S^\dagger = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; -i
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L487-L497">source</a></section><section><div><pre><code class="nohighlight hljs">phase_dagger(target)</code></pre><p>Return an adjoint phase <code>Gate</code> (also known as an <span>$S^\dagger$</span> <code>Gate</code>), which applies the <a href="library.html#Snowflake.phase_dagger"><code>phase_dagger()</code></a> <code>DiagonalOperator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L946-L950">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.pi_8" href="#Snowflake.pi_8"><code>Snowflake.pi_8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pi_8()</code></pre><p>Return the <code>Operator</code> for the π/8 gate, which is defined as:</p><p class="math-container">\[T = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\frac{\pi}{4}}
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L500-L510">source</a></section><section><div><pre><code class="nohighlight hljs">pi_8(target)</code></pre><p>Return a π/8 <code>Gate</code> (also known as a <span>$T$</span> <code>Gate</code>), which applies the <a href="library.html#Snowflake.pi_8"><code>pi_8()</code></a> <code>DiagonalOperator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L962-L966">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.pi_8_dagger" href="#Snowflake.pi_8_dagger"><code>Snowflake.pi_8_dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pi_8_dagger()</code></pre><p>Return the adjoint <code>DiagonalOperator</code> of the π/8 gate, which is defined as:</p><p class="math-container">\[T^\dagger = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; e^{-i\frac{\pi}{4}}
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L513-L523">source</a></section><section><div><pre><code class="nohighlight hljs">pi_8_dagger(target)</code></pre><p>Return an adjoint π/8 <code>Gate</code> (also known as a <span>$T^\dagger$</span> <code>Gate</code>), which applies the <a href="library.html#Snowflake.pi_8_dagger"><code>pi_8_dagger()</code></a> <code>Operator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L978-L982">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.x_90" href="#Snowflake.x_90"><code>Snowflake.x_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x_90()</code></pre><p>Return the <code>Operator</code> which applies a π/2 rotation about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; -i \\
    -i &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L556-L568">source</a></section><section><div><pre><code class="nohighlight hljs">x_90(target)</code></pre><p>Return a <code>Gate</code> that applies a 90° rotation about the X axis as defined by the <a href="library.html#Snowflake.x_90"><code>x_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L994-L998">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.x_minus_90" href="#Snowflake.x_minus_90"><code>Snowflake.x_minus_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x_minus_90()</code></pre><p>Return the <code>Operator</code> which applies a -π/2 rotation about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x\left(-\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; i \\
    i &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L571-L583">source</a></section><section><div><pre><code class="nohighlight hljs">x_minus_90(target)</code></pre><p>Return a <code>Gate</code> that applies a -90° rotation about the X axis as defined by the <a href="library.html#Snowflake.x_minus_90"><code>x_minus_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1009-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.y_90" href="#Snowflake.y_90"><code>Snowflake.y_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y_90()</code></pre><p>Return the <code>Operator</code> which applies a π/2 rotation about the Y axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_y\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; -1 \\
    1 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L586-L598">source</a></section><section><div><pre><code class="nohighlight hljs">y_90(target)</code></pre><p>Return a <code>Gate</code> that applies a 90° rotation about the Y axis as defined by the <a href="library.html#Snowflake.y_90"><code>y_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1024-L1028">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.y_minus_90" href="#Snowflake.y_minus_90"><code>Snowflake.y_minus_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y_minus_90()</code></pre><p>Return the <code>Operator</code> which applies a -π/2 rotation about the Y axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_y\left(-\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; 1 \\
    -1 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L601-L613">source</a></section><section><div><pre><code class="nohighlight hljs">y_minus_90(target)</code></pre><p>Return a <code>Gate</code> that applies a -90° rotation about the Y axis as defined by the <a href="library.html#Snowflake.y_minus_90"><code>y_minus_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1039-L1043">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.z_90" href="#Snowflake.z_90"><code>Snowflake.z_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">z_90()</code></pre><p>Return the <code>Operator</code> which applies a π/2 rotation about the Z axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_z\left(\frac{\pi}{2}\right) = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; i
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L616-L628">source</a></section><section><div><pre><code class="nohighlight hljs">z_90(target)</code></pre><p>Return a <code>Gate</code> that applies a 90° rotation about the Z axis as defined by the <a href="library.html#Snowflake.z_90"><code>z_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1054-L1058">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.z_minus_90" href="#Snowflake.z_minus_90"><code>Snowflake.z_minus_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">z_minus_90()</code></pre><p>Return the <code>Operator</code> which applies a -π/2 rotation about the Z axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_z\left(-\frac{\pi}{2}\right) = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; -i
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L631-L643">source</a></section><section><div><pre><code class="nohighlight hljs">z_minus_90(target)</code></pre><p>Return a <code>Gate</code> that applies a -90° rotation about the Z axis as defined by the <a href="library.html#Snowflake.z_minus_90"><code>z_minus_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1069-L1073">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation" href="#Snowflake.rotation"><code>Snowflake.rotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation(theta, phi)</code></pre><p>Return the <code>Operator</code> which applies a rotation <code>theta</code> about the cos(<code>phi</code>)X+sin(<code>phi</code>)Y axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R(\theta, \phi) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -i e^{-i\phi} \mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    -i e^{i\phi} \mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L646-L660">source</a></section><section><div><pre><code class="nohighlight hljs">rotation(target, theta, phi)</code></pre><p>Return a gate that applies a rotation <code>theta</code> to the <code>target</code> qubit about the cos(<code>phi</code>)X+sin(<code>phi</code>)Y axis.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.rotation"><code>rotation(theta, phi)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1085-L1091">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation_x" href="#Snowflake.rotation_x"><code>Snowflake.rotation_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_x(theta)</code></pre><p>Return the <code>Operator</code> which applies a rotation <code>theta</code> about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x(\theta) = \begin{bmatrix}
\mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
    -i\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
-i\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
    \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L666-L680">source</a></section><section><div><pre><code class="nohighlight hljs">rotation_x(target, theta)</code></pre><p>Return a <code>Gate</code> that applies a rotation <code>theta</code> about the X axis of the <code>target</code> qubit.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.rotation_x"><code>rotation_x(theta)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1112-L1118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.rotation_y" href="#Snowflake.rotation_y"><code>Snowflake.rotation_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_y(theta)</code></pre><p>Return the <code>Operator</code> that applies a rotation <code>theta</code> about the Y axis of the <code>target</code> qubit.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_y(\theta) = \begin{bmatrix}
\mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
    -\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
    \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L683-L697">source</a></section><section><div><pre><code class="nohighlight hljs">rotation_y(target, theta)</code></pre><p>Return a <code>Gate</code> that applies a rotation <code>theta</code> about the Y axis of the <code>target</code> qubit.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.rotation_y"><code>rotation_y(theta)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1132-L1138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.phase_shift" href="#Snowflake.phase_shift"><code>Snowflake.phase_shift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase_shift(target, phi)</code></pre><p>Return a <code>Gate</code> that applies a phase shift <code>phi</code> to the <code>target</code> qubit as defined by the <a href="library.html#Snowflake.phase_shift"><code>phase_shift(phi)</code></a> <code>DiagonalOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1152-L1156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.universal" href="#Snowflake.universal"><code>Snowflake.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">universal(theta, phi, lambda)</code></pre><p>Return the <code>Operator</code> which performs a rotation about the angles <code>theta</code>, <code>phi</code>, and <code>lambda</code>. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[U(\theta, \phi, \lambda) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -e^{i\lambda}\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    e^{i\phi}\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        e^{i\left(\phi+\lambda\right)}\mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L716-L731">source</a></section><section><div><pre><code class="nohighlight hljs">universal(target, theta, phi, lambda)</code></pre><p>Return a gate which rotates the <code>target</code> qubit given the angles <code>theta</code>, <code>phi</code>, and <code>lambda</code>. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.universal"><code>universal(theta, phi, lambda)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1170-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.control_z" href="#Snowflake.control_z"><code>Snowflake.control_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control_z()</code></pre><p>Return the controlled-Z <code>Operator</code>, which is defined as:</p><p class="math-container">\[CZ = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L759-L771">source</a></section><section><div><pre><code class="nohighlight hljs">control_z(control_qubit, target_qubit)</code></pre><p>Return a controlled-Z gate given a <code>control_qubit</code> and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.control_z"><code>control_z()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1200-L1206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.control_x" href="#Snowflake.control_x"><code>Snowflake.control_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control_x()</code></pre><p>Return the controlled-X (or controlled NOT) <code>Operator</code>, which is defined as:</p><p class="math-container">\[CX = CNOT = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L737-L749">source</a></section><section><div><pre><code class="nohighlight hljs">control_x(control_qubit, target_qubit)</code></pre><p>Return a controlled-X gate (also known as a controlled NOT gate) given a <code>control_qubit</code> and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.control_x"><code>control_x()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1235-L1241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.iswap" href="#Snowflake.iswap"><code>Snowflake.iswap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswap()</code></pre><p>Return the imaginary swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; i &amp; 0 \\
    0 &amp; i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L781-L793">source</a></section><section><div><pre><code class="nohighlight hljs">iswap(qubit_1, qubit_2)</code></pre><p>Return the imaginary swap <code>Gate</code> which applies the imaginary swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.iswap"><code>iswap()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1256-L1262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.swap" href="#Snowflake.swap"><code>Snowflake.swap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swap()</code></pre><p>Return the swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L798-L810">source</a></section><section><div><pre><code class="nohighlight hljs">swap(qubit_1, qubit_2)</code></pre><p>Return the swap <code>Gate</code> which applies the swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.swap"><code>swap()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1279-L1285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.toffoli" href="#Snowflake.toffoli"><code>Snowflake.toffoli</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">toffoli()</code></pre><p>Return the Toffoli <code>Operator</code>, which is defined as:</p><p class="math-container">\[CCX = CCNOT = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L815-L831">source</a></section><section><div><pre><code class="nohighlight hljs">toffoli(control_qubit_1, control_qubit_2, target_qubit)</code></pre><p>Return a Toffoli gate (also known as a CCNOT gate) given two control qubits and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.toffoli"><code>toffoli()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1300-L1306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.iswap_dagger" href="#Snowflake.iswap_dagger"><code>Snowflake.iswap_dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswap_dagger()</code></pre><p>Return the adjoint of the imaginary swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP^\dagger = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; -i &amp; 0 \\
    0 &amp; -i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L843-L855">source</a></section><section><div><pre><code class="nohighlight hljs">iswap_dagger(qubit_1, qubit_2)</code></pre><p>Return the adjoint imaginary swap <code>Gate</code> which applies the adjoint imaginary swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Snowflake.iswap_dagger"><code>iswap_dagger()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1328-L1334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractGate, Ket}" href="#Base.:*-Tuple{AbstractGate, Ket}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(M::AbstractGate, x::Ket)</code></pre><p>Return a <code>Ket</code> which results from applying <code>Gate</code> <code>M</code> to <code>Ket</code> <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = fock(0, 2)
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ_1 = sigma_x(1)*ψ_0
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1351-L1371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.apply_gate!" href="#Snowflake.apply_gate!"><code>Snowflake.apply_gate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_gate!(state::Ket, gate::Gate)</code></pre><p>Update the <code>state</code> by applying a <code>gate</code> to it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = fock(0, 2)
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; apply_gate!(ψ_0, sigma_x(1))

julia&gt; print(ψ_0)
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L85-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_operator" href="#Snowflake.get_operator"><code>Snowflake.get_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_operator(gate::Gate)</code></pre><p>Returns the <code>Operator</code> which is associated to a <code>Gate</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = sigma_x(1);

julia&gt; get_operator(x)
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L871-L888">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{AbstractGate}" href="#Base.inv-Tuple{AbstractGate}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(gate::AbstractGate)</code></pre><p>Return a <code>Gate</code> which is the inverse of the input <code>gate</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = universal(1, -pi/2, pi/3, pi/4)
Gate Object: Snowflake.Universal
Parameters: 
theta	: -1.5707963267948966
phi	: 1.0471975511965976
lambda	: 0.7853981633974483

Connected_qubits	: [1]
Operator:
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.7071067811865476 + 0.0im    0.5 + 0.4999999999999999im
-0.3535533905932738 - 0.6123724356957945im    -0.18301270189221924 + 0.6830127018922194im


julia&gt; inv(u)
Gate Object: Snowflake.Universal
Parameters: 
theta	: 1.5707963267948966
phi	: -0.7853981633974483
lambda	: -1.0471975511965976

Connected_qubits	: [1]
Operator:
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.7071067811865476 + 0.0im    -0.3535533905932738 + 0.6123724356957945im
0.5 - 0.4999999999999999im    -0.18301270189221924 - 0.6830127018922194im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/quantum_gate.jl#L1380-L1418">source</a></section></article><h2 id="Quantum-Processing-Unit"><a class="docs-heading-anchor" href="#Quantum-Processing-Unit">Quantum Processing Unit</a><a id="Quantum-Processing-Unit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Processing-Unit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Snowflake.AnyonQPU" href="#Snowflake.AnyonQPU"><code>Snowflake.AnyonQPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnyonQPU</code></pre><p>A data structure to represent a Anyon System&#39;s QPU.  </p><p><strong>Fields</strong></p><ul><li><code>client       ::Client</code> – Client to the QPU server.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Client(host=&quot;http://example.anyonsys.com&quot;,user=&quot;test_user&quot;,access_token=&quot;not_a_real_access_token&quot;);
  
julia&gt; qpu=AnyonQPU(c)
Quantum Processing Unit:
   manufacturer:  Anyon Systems Inc.
   generation:    Yukon 
   serial_number: ANYK202201 

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/anyon.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.VirtualQPU" href="#Snowflake.VirtualQPU"><code>Snowflake.VirtualQPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VirtualQPU</code></pre><p>A data structure to represent a Quantum Simulator.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=VirtualQPU()
Quantum Simulator:
   developers:  Anyon Systems Inc.
   package:     Snowflake.jl

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/qpu_interface.jl#L341-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Client" href="#Snowflake.Client"><code>Snowflake.Client</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Client</code></pre><p>A data structure to represent a <em>Client</em> to a QPU service.  </p><p><strong>Fields</strong></p><ul><li><code>host::String</code> – URL of the QPU server.</li><li><code>user::String</code> – Username.</li><li><code>access_token::String</code> – User access token.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Client(host=&quot;http://example.anyonsys.com&quot;,user=&quot;test_user&quot;,access_token=&quot;not_a_real_access_token&quot;)
Client for QPU service:
   host:         http://example.anyonsys.com
   user:         test_user 
 
  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/qpu_interface.jl#L155-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_host" href="#Snowflake.get_host"><code>Snowflake.get_host</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_host(Client)</code></pre><p>Returns host URL of a <code>Client</code> to a <code>QPU</code> service.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Client(host=&quot;http://example.anyonsys.com&quot;,user=&quot;test_user&quot;,access_token=&quot;not_a_real_access_token&quot;);

julia&gt; get_host(c)
&quot;http://example.anyonsys.com&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/qpu_interface.jl#L187-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.submit_circuit" href="#Snowflake.submit_circuit"><code>Snowflake.submit_circuit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">submit_circuit(client::Client,circuit::QuantumCircuit,num_repetitions::Integer)</code></pre><p>Submit a circuit to a <code>Client</code> of <code>QPU</code> service, requesting a number of  repetitions (num_repetitions). Returns circuitID.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/qpu_interface.jl#L205-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_status" href="#Snowflake.get_status"><code>Snowflake.get_status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_status(client::Client,circuitID::String)::Dict{String, String}</code></pre><p>Obtain the status of a circuit computation through a <code>Client</code> of a <code>QPU</code> service. Returns status::Dict containing status[&quot;type&quot;]:      -&quot;queued&quot;   : Computation in queue.     -&quot;running&quot;  : Computation being processed.     -&quot;failed&quot;   : QPU service has returned an error message.     -&quot;succeeded&quot;: Computation is completed, result is available.</p><p>In the case of status[&quot;type&quot;]==&quot;failed&quot;, the server error is contained in status[&quot;message&quot;].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;

julia&gt; get_status(client,circuitID)
Status: succeeded
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/qpu_interface.jl#L238-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_result" href="#Snowflake.get_result"><code>Snowflake.get_result</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_result(client::Client,circuit::String)::Dict{String, Int}</code></pre><p>Get the histogram of a completed circuit calculation, through a <code>Client</code> of a <code>QPU</code> service,  by circuit identifier circuitID.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;

julia&gt; get_status(client,circuitID);

julia&gt; get_result(client,circuitID)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/qpu_interface.jl#L288-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.run_job" href="#Snowflake.run_job"><code>Snowflake.run_job</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_job(qpu::VirtualQPU, circuit::QuantumCircuit,num_repetitions::Integer)</code></pre><p>Run a circuit computation on a <code>QPU</code> simulator, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=VirtualQPU();

julia&gt; run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/qpu_interface.jl#L386-L402">source</a></section><section><div><pre><code class="nohighlight hljs">run_job(qpu::AnyonQPU, circuit::QuantumCircuit,num_repetitions::Integer)</code></pre><p>Run a circuit computation on a <code>QPU</code> service, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations, or an error message.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=AnyonQPU(client);

julia&gt; run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/anyon.jl#L46-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_transpiler" href="#Snowflake.get_transpiler"><code>Snowflake.get_transpiler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_transpiler(qpu::AnyonQPU)::Transpiler</code></pre><p>Returns the transpiler associated with this QPU.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=AnyonQPU(client);

julia&gt; get_transpiler(qpu)
SequentialTranspiler(Transpiler[CastToffoliToCXGateTranspiler(), CastSwapToCZGateTranspiler(), CastCXToCZGateTranspiler(), CastISwapToCZGateTranspiler(), CompressSingleQubitGatesTranspiler(), CastToPhaseShiftAndHalfRotationX(1.0e-6), PlaceOperationsOnLine()])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/anyon/anyon.jl#L103-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.SequentialTranspiler" href="#Snowflake.SequentialTranspiler"><code>Snowflake.SequentialTranspiler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SequentialTranspiler(Vector{&lt;:Transpiler})</code></pre><p>Composite transpiler object which is constructed from an array  of Transpiler stages. Calling      <code>transpile(::SequentialTranspiler,::QuantumCircuit)</code>` will apply each stage in sequence to the input circuit, and return a transpiled output circuit. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=Snowflake.SequentialTranspiler([Snowflake.CompressSingleQubitGatesTranspiler(),Snowflake.CastToPhaseShiftAndHalfRotationX()]);

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),hadamard(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X────H──
               
q[2]:──────────
               



julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────X_90────Z_90────X_m90────Z──
                                                              
q[2]:───────────────────────────────────
                                                              



julia&gt; circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y─────────P(1.0472)──  

q[2]:────────────*───────────────
                 |               
q[3]:────────────X───────────────
                                 



julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──P(-2.0944)───────
                        
q[2]:────────────────*──
                     |  
q[3]:────────────────X──
                        


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/transpile.jl#L8-L67">source</a></section></article><h2 id="Quantum-Toolkit"><a class="docs-heading-anchor" href="#Quantum-Toolkit">Quantum Toolkit</a><a id="Quantum-Toolkit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Toolkit" title="Permalink"></a></h2><h3 id="Basic-Quantum-Objects"><a class="docs-heading-anchor" href="#Basic-Quantum-Objects">Basic Quantum Objects</a><a id="Basic-Quantum-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Quantum-Objects" title="Permalink"></a></h3><p>There are three basic quantum objects in Snowflake to simulate a quantum system. These objects are Ket, Bra, and AbstractOperator.</p><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Ket" href="#Snowflake.Ket"><code>Snowflake.Ket</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Ket represents a <em>quantum wavefunction</em> and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.  </p><p><strong>Examples</strong></p><p>Although NOT the preferred way, one can directly build a Ket object by passing a column vector as the initializer. </p><pre><code class="language-julia-repl hljs">julia&gt; using Snowflake

julia&gt; ψ = Ket([1.0; 0.0; 0.0])
3-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im

</code></pre><p>A better way to initialize a Ket is to use a pre-built basis such as the <code>fock</code> basis. See <a href="library.html#Snowflake.fock"><code>fock</code></a> for further information on this function. </p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(2, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.Bra" href="#Snowflake.Bra"><code>Snowflake.Bra</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a Bra (i.e. a row vector of complex values). A Bra is created as the complex conjugate of a Ket.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(1, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; _ψ = Bra(ψ)
3-element Bra{ComplexF64}:
0.0 - 0.0im
1.0 - 0.0im
0.0 - 0.0im


julia&gt; _ψ * ψ    # A Bra times a Ket is a scalar
1.0 + 0.0im

julia&gt; ψ*_ψ     # A Ket times a Bra is an operator
(3, 3)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L102-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.DiagonalOperator" href="#Snowflake.DiagonalOperator"><code>Snowflake.DiagonalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a diagonal quantum <code>Operator</code> (i.e. a complex matrix, with non-zero elements all lying on the diagonal).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = DiagonalOperator([1.0,-1.0])
(2,2)-element Snowflake.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 0.0im    .
.    -1.0 + 0.0im

julia&gt; z = DiagonalOperator([1.0+im,1.0,1.0,0.0-im])
(4,4)-element Snowflake.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 1.0im    .    .    .
.    1.0 + 0.0im    .    .
.    .    1.0 + 0.0im    .
.    .    .    0.0 - 1.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L227-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.AntiDiagonalOperator" href="#Snowflake.AntiDiagonalOperator"><code>Snowflake.AntiDiagonalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a anti-diagonal quantum <code>Operator</code> (i.e. a complex matrix, with non-zero elements all lying on the cross-diagonal).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; AntiDiagonalOperator([1,2])
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    2.0 + 0.0im    .
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L270-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.DenseOperator" href="#Snowflake.DenseOperator"><code>Snowflake.DenseOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a quantum operator with a full (dense) matrix representation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = DenseOperator([1.0 0.0;0.0 -1.0])
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    -1.0 + 0.0im
</code></pre><p>Alternatively:</p><pre><code class="language-julia-repl hljs">julia&gt; z = rotation(π/2,-π/4)  
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.7071067811865476 + 0.0im    0.4999999999999999 - 0.5im
-0.4999999999999999 - 0.5im    0.7071067811865476 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L151-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.adjoint(x)</code></pre><p>Compute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.is_hermitian" href="#Snowflake.is_hermitian"><code>Snowflake.is_hermitian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_hermitian(A::AbstractOperator)</code></pre><p>Determine if Operator <code>A</code> is Hermitian (i.e. self-adjoint).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = sigma_y()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; is_hermitian(Y)
true

julia&gt; P = sigma_p()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    0.0 + 0.0im    .


julia&gt; is_hermitian(P)
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L334-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{AbstractOperator}" href="#Base.exp-Tuple{AbstractOperator}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(A::AbstractOperator)</code></pre><p>Compute the matrix exponential of <code>Operator</code> <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = sigma_x()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; x_rotation_90_deg = exp(-im*π/4*X)
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.7071067811865475 + 0.0im    0.0 - 0.7071067811865475im
0.0 - 0.7071067811865475im    0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L419-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractOperator, Int64, Int64}" href="#Base.getindex-Tuple{AbstractOperator, Int64, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getindex(A::AbstractOperator, i::Integer, j::Integer)</p><p>Access the element at row i and column j in the matrix corresponding to <code>Operator</code> <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = sigma_y()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; Y[1,1]
0.0 + 0.0im

julia&gt; Y[1,2]
0.0 - 1.0im

julia&gt; Y[2,1]
0.0 + 1.0im

julia&gt; Y[2,2]
0.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L196-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.eigen" href="#LinearAlgebra.eigen"><code>LinearAlgebra.eigen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigen(A::AbstractOperator)</code></pre><p>Compute the eigenvalue decomposition of Operator <code>A</code> and return an <code>Eigen</code> factorization object <code>F</code>. Eigenvalues are found in <code>F.values</code> while eigenvectors are found in the matrix <code>F.vectors</code>. Each column of this matrix corresponds to an eigenvector. The <code>i</code>th eigenvector is extracted by calling <code>F.vectors[:, i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = sigma_x()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

julia&gt; F = eigen(X);

julia&gt; eigenvalues = F.values
2-element Vector{Float64}:
 -1.0
  1.0

julia&gt; eigenvector_1 = F.vectors[:, 1]
2-element Vector{ComplexF64}:
 -0.7071067811865475 + 0.0im
  0.7071067811865475 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L448-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.tr" href="#LinearAlgebra.tr"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tr(A::AbstractOperator)</code></pre><p>Compute the trace of Operator <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; I = eye()
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im


julia&gt; trace = tr(I)
2.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L482-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.expected_value" href="#Snowflake.expected_value"><code>Snowflake.expected_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expected_value(A::AbstractOperator, psi::Ket)</code></pre><p>Compute the expectation value ⟨<code>ψ</code>|<code>A</code>|<code>ψ</code>⟩ given Operator <code>A</code> and Ket |<code>ψ</code>⟩.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([0.0; 1.0])
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; A = sigma_z()
(2,2)-element Snowflake.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 0.0im    .
.    -1.0 + 0.0im


julia&gt; expected_value(A, ψ)
-1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L505-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kron(x, y)</code></pre><p>Compute the Kronecker product of two <a href="library.html#Snowflake.Ket"><code>Kets</code></a> or two  <a href="library.html#Snowflake.DenseOperator"><code>DenseOperator</code></a> , <a href="library.html#Snowflake.DiagonalOperator"><code>DiagonalOperator</code></a>, <a href="library.html#Snowflake.AntiDiagonalOperator"><code>AntiDiagonalOperator</code></a>. More details about the Kronecker product can be found <a href="https://en.wikipedia.org/wiki/Kronecker_product">here</a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = Ket([0.0; 1.0])
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; ψ_1 = Ket([1.0; 0.0])
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ_0_1 = kron(ψ_0, ψ_1)
4-element Ket{ComplexF64}:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; kron(sigma_x(), sigma_y())
(4, 4)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L544-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.MultiBodySystem" href="#Snowflake.MultiBodySystem"><code>Snowflake.MultiBodySystem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a quantum multi-body system.</p><p><strong>Fields</strong></p><ul><li><code>hilbert_space_structure</code> – a vector of integers specifying the local Hilbert space size for each &quot;body&quot; within the multi-body system. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L592-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.commute" href="#Snowflake.commute"><code>Snowflake.commute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">commute(A::AbstractOperator, B::AbstractOperator)</code></pre><p>Returns the commutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = sigma_x()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; σ_y = sigma_y()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; commute(σ_x,σ_y)
(2,2)-element Snowflake.DiagonalOperator:
Underlying data type: ComplexF64:
0.0 + 2.0im    .
.    0.0 - 2.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1230-L1256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.anticommute" href="#Snowflake.anticommute"><code>Snowflake.anticommute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">anticommute(A::AbstractOperator, B::AbstractOperator)</code></pre><p>Returns the anticommutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = sigma_x()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; anticommute(σ_x,σ_x)
(2,2)-element Snowflake.DiagonalOperator:
Underlying data type: ComplexF64:
2.0 + 0.0im    .
.    2.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1260-L1279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize!(x::Ket)</code></pre><p>Normalizes Ket <code>x</code> such that its magnitude becomes unity.</p><pre><code class="language-julia-repl hljs">julia&gt; ψ=Ket([1.,2.,4.])
3-element Ket{ComplexF64}:
1.0 + 0.0im
2.0 + 0.0im
4.0 + 0.0im

julia&gt; normalize!(ψ)
3-element Ket{ComplexF64}:
0.2182178902359924 + 0.0im
0.4364357804719848 + 0.0im
0.8728715609439696 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1051-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T&lt;:Real" href="#Snowflake.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T&lt;:Real"><code>Snowflake.get_measurement_probabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_measurement_probabilities(x::Ket{Complex{T}},
    [target_bodies::Vector{U},
    hspace_size_per_body::Union{U,Vector{U}}=2])::AbstractVector{T}
    where {T&lt;:Real, U&lt;:Integer}</code></pre><p>Returns a vector listing the measurement probabilities of the <code>target_bodies</code> of <code>Ket</code> <code>x</code>.</p><p>The Hilbert space size per body can be specified by providing a <code>Vector</code> of <code>Integer</code> for the <code>hspace_size_per_body</code> argument. The <code>Vector</code> must specify the Hilbert space size for each body. If the space size is uniform, a single <code>Integer</code> can be given instead. If only <code>x</code> is provided, the probabilities are provided for all the bodies.</p><p>The measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit <code>Ket</code>, the probabilities are listed for 00, 01, 10, and 11.</p><p><strong>Examples</strong></p><p>The following example constructs a <code>Ket</code>, where the probability of measuring 00 is 50% and the probability of measuring 10 is also 50%.</p><pre><code class="language-julia-repl hljs">julia&gt; ψ = 1/sqrt(2)*Ket([1, 0, 1, 0])
4-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im
0.0 + 0.0im


julia&gt; get_measurement_probabilities(ψ)
4-element Vector{Float64}:
 0.4999999999999999
 0.0
 0.4999999999999999
 0.0
</code></pre><p>For the same <code>Ket</code>, the probability of measuring qubit 2 and finding 0 is 100%.</p><pre><code class="language-julia-repl hljs">julia&gt; target_qubit = [2];

julia&gt; get_measurement_probabilities(ψ, target_qubit)
2-element Vector{Float64}:
 0.9999999999999998
 0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1077-L1124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.ket2dm" href="#Snowflake.ket2dm"><code>Snowflake.ket2dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ket2dm(ψ::Ket)</code></pre><p>Returns the density matrix corresponding to the pure state ψ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1283-L1287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.fock_dm" href="#Snowflake.fock_dm"><code>Snowflake.fock_dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fock_dm(i::Int64, hspace_size::Int64)</code></pre><p>Returns the density matrix corresponding to the Fock base <code>i</code> defined in a Hilbert space of size <code>hspace_size</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; dm=fock_dm(0,2)
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1292-L1307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.wigner" href="#Snowflake.wigner"><code>Snowflake.wigner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wigner(ρ::AbstractOperator, p::Real, q::Real)</code></pre><p>Computes the Wigner function of the density matrix <code>ρ</code> at the point (<code>p</code>,<code>q</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Printf

julia&gt; alpha = 0.25;

julia&gt; hspace_size = 8;

julia&gt; Ψ = coherent(alpha, hspace_size);

julia&gt; prob = wigner(ket2dm(Ψ), 0, 0);

julia&gt; @printf &quot;prob: %.6f&quot; prob
prob: -0.561815</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1310-L1329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.moyal" href="#Snowflake.moyal"><code>Snowflake.moyal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moyal(m, n)</code></pre><p>Returns the Moyal function <code>w_mn(eta)</code> for Fock states <code>m</code> and <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1346-L1352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.genlaguerre" href="#Snowflake.genlaguerre"><code>Snowflake.genlaguerre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlaguerre(x, alpha, n)</code></pre><p>Returns the generalized Laguerre polynomial of degree <code>n</code> for <code>x</code> using a recursive method. See <a href="https://en.wikipedia.org/wiki/Laguerre_polynomials">https://en.wikipedia.org/wiki/Laguerre_polynomials</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1360-L1365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_embed_operator" href="#Snowflake.get_embed_operator"><code>Snowflake.get_embed_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_embed_operator(op::DenseOperator, target_body_index::Int, system::MultiBodySystem)</code></pre><p>Uses a local operator (<code>op</code>), which is defined for a particular body (e.g. qubit) with index <code>target_body_index</code>, to build the corresponding operator for the Hilbert space of the multi-body system given by <code>system</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; system = MultiBodySystem(3,2)
Snowflake.Multibody system with 3 bodies
   Hilbert space structure:
   [2, 2, 2]

julia&gt; x = sigma_x()
(2,2)-element Snowflake.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

julia&gt; X_1=get_embed_operator(x,1,system)
(8, 8)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L614-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_qubits-Tuple{AbstractOperator}" href="#Snowflake.get_num_qubits-Tuple{AbstractOperator}"><code>Snowflake.get_num_qubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::AbstractOperator)</code></pre><p>Returns the number of qubits associated with an <code>Operator</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = DenseOperator([1. 0.
                     0. 0.])
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im

julia&gt; get_num_qubits(ρ)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L767-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_qubits-Tuple{Union{Bra, Ket}}" href="#Snowflake.get_num_qubits-Tuple{Union{Bra, Ket}}"><code>Snowflake.get_num_qubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::Union{Ket, Bra})</code></pre><p>Returns the number of qubits associated with a <code>Ket</code> or a <code>Bra</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1., 0., 0., 0.])
4-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; get_num_qubits(ψ)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L798-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_bodies" href="#Snowflake.get_num_bodies"><code>Snowflake.get_num_bodies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)</code></pre><p>Returns the number of bodies associated with an <code>Operator</code> given the <code>hilbert_space_size_per_body</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = DenseOperator([1. 0. 0.
                     0. 0. 0.
                     0. 0. 0.])
(3, 3)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

julia&gt; get_num_bodies(ρ, 3)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L826-L846">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.get_num_bodies" href="#Snowflake.get_num_bodies"><code>Snowflake.get_num_bodies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)</code></pre><p>Returns the number of bodies associated with a <code>Ket</code> or a <code>Bra</code> given the <code>hilbert_space_size_per_body</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1., 0., 0., 0., 0., 0., 0., 0., 0.])
9-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; get_num_bodies(ψ, 3)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L860-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.fock" href="#Snowflake.fock"><code>Snowflake.fock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fock(i, hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>i</code>th fock basis of a Hilbert space with size <code>hspace_size</code> as a Ket.</p><p>The Ket contains values of type <code>T</code>, which by default is ComplexF64.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(0, 3)
3-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ = fock(1, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ = fock(1, 3,ComplexF32) # specifying a type other than ComplexF64
3-element Ket{ComplexF32}:
0.0f0 + 0.0f0im
1.0f0 + 0.0f0im
0.0f0 + 0.0f0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L894-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.spin_up" href="#Snowflake.spin_up"><code>Snowflake.spin_up</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spin_up(T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>Ket</code> representation of the spin-up state.</p><p>The <code>Ket</code> stores values of type <code>T</code>, which is <code>ComplexF64</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = spin_up()
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L929-L945">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.spin_down" href="#Snowflake.spin_down"><code>Snowflake.spin_down</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spin_down(T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>Ket</code> representation of the spin-down state.</p><p>The <code>Ket</code> stores values of type <code>T</code>, which is <code>ComplexF64</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = spin_down()
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L948-L964">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.create" href="#Snowflake.create"><code>Snowflake.create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the bosonic creation operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L967-L971">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.destroy" href="#Snowflake.destroy"><code>Snowflake.destroy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">destroy(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the bosonic annhilation operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L980-L984">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.number_op" href="#Snowflake.number_op"><code>Snowflake.number_op</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">number_op(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the number operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L993-L997">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.coherent" href="#Snowflake.coherent"><code>Snowflake.coherent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coherent(alpha, hspace_size)</code></pre><p>Returns a coherent state for the parameter <code>alpha</code> in a Fock space of size <code>hspace_size</code>. Note that |alpha|^2 is equal to the photon number of the coherent state. </p><pre><code class="nohighlight hljs"># Examples</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ψ = coherent(2.0,20)
20-element Ket{ComplexF64}:
0.1353352832366127 + 0.0im
0.2706705664732254 + 0.0im
0.3827859860416437 + 0.0im
0.44200318416631873 + 0.0im
0.44200318416631873 + 0.0im
0.3953396664268989 + 0.0im
0.3227934859426707 + 0.0im
0.24400893961026582 + 0.0im
0.17254037586855772 + 0.0im
0.11502691724570517 + 0.0im
0.07274941014482605 + 0.0im
0.043869544940011405 + 0.0im
0.025328093580341972 + 0.0im
0.014049498479026656 + 0.0im
0.007509772823502764 + 0.0im
0.003878030010563634 + 0.0im
0.001939015005281817 + 0.0im
0.000940560432521708 + 0.0im
0.0004433844399679012 + 0.0im
0.00020343873336404819 + 0.0im


julia&gt; expected_value(number_op(20),ψ)
3.99999979364864 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L1006-L1041">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.sesolve" href="#Snowflake.sesolve"><code>Snowflake.sesolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sesolve(H::AbstractOperator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{AbstractOperator}=(AbstractOperator)[])
sesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{Operator}=(Operator)[])</code></pre><p>Solves the Shrodinger equation:</p><p><span>$\frac{d \Psi}{d t}=-i \hat{H}\Psi$</span></p><p><strong>Fields</strong></p><ul><li><code>H</code> – the Hamiltonian operator or a function that returns the Hamiltonian as a function of time.</li><li><code>ψ_0</code> – initital status of a quantum system</li><li><code>t_range</code> – time interval for which the system has to be simulated. </li><li><code>e_ops</code> – list of operators for which the expected value will be returned as a function of time. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/dynamic_system.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.mesolve" href="#Snowflake.mesolve"><code>Snowflake.mesolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mesolve(H::AbstractOperator, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{AbstractOperator}=(AbstractOperator)[])
mesolve(H::Function, ψ_0::Ket, t_range::StepRangeLen; e_ops::Vector{AbstractOperator}=(AbstractOperator)[])</code></pre><p>Solves the Lindblad Master equation:</p><p><span>$\dot{\rho}=-i [H, \rho]+\sum_i \gamma_i\left(L_i \rho L^{\dag}_i - \frac{1}{2}\left\{L^{\dag}_i L_i, \rho\right\}\right)$</span></p><p><strong>Fields</strong></p><ul><li><code>H</code> – the Hamiltonian operator or a function that returns the Hamiltonian as a function of time.</li><li><code>ψ_0</code> – initital status of a quantum system</li><li><code>t_range</code> – time interval for which the system has to be simulated. </li><li><code>e_ops</code> – list of operators for which the expected value will be returned as function of time. </li><li><code>c_ops</code> – list of collapse operators <span>$L_i$</span>&#39;s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/dynamic_system.jl#L44-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Snowflake.compare_kets" href="#Snowflake.compare_kets"><code>Snowflake.compare_kets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_kets(ψ_0::Ket,ψ_1::Ket)</code></pre><p>Checks for equivalence allowing for a global phase difference between two input kets.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = Ket([1.,2.,3.,4.])
4-element Ket{ComplexF64}:
1.0 + 0.0im
2.0 + 0.0im
3.0 + 0.0im
4.0 + 0.0im


julia&gt; δ=π/3 # phase offset
1.0471975511965976

julia&gt; ψ_1 = exp(im*δ)*ψ_0
4-element Ket{ComplexF64}:
0.5000000000000001 + 0.8660254037844386im
1.0000000000000002 + 1.7320508075688772im
1.5000000000000004 + 2.598076211353316im
2.0000000000000004 + 3.4641016151377544im


julia&gt; compare_kets(ψ_0,ψ_1)
true

julia&gt; apply_gate!(ψ_1,sigma_x(1))

julia&gt; compare_kets(ψ_0,ψ_1) # no longer equivalent after SigmaX gate
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/src/core/qobj.jl#L48-L84">source</a></section></article><h3 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h3><p>The SnowflakePlots package provides multiple tools for visualizing quantum computer calculations.</p><article class="docstring"><header><a class="docstring-binding" id="SnowflakePlots.plot_bloch_sphere-Tuple{QuantumCircuit}" href="#SnowflakePlots.plot_bloch_sphere-Tuple{QuantumCircuit}"><code>SnowflakePlots.plot_bloch_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bloch_sphere(circuit::QuantumCircuit;
    qubit_id::Int = 1,
    bloch_sphere::BlochSphere = BlochSphere())</code></pre><p>Plots the Bloch sphere of qubit <code>qubit_id</code> for the <code>circuit</code>.</p><p>If the <code>circuit</code> contains multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit <code>qubit_id</code>. The appearance of the Bloch sphere can be modified by passing a <a href="library.html#SnowflakePlots.BlochSphere"><code>BlochSphere</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count=2)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:


julia&gt; push!(circuit, [hadamard(1), sigma_x(2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               


</code></pre><pre><code class="nohighlight hljs">julia&gt; plot = plot_bloch_sphere(circuit, qubit_id=2)
</code></pre><p><img src="assets/visualize/plot_bloch_sphere_for_circuit.png" alt="Bloch sphere for circuit"/></p><p>The Bloch sphere can be saved to a file by calling:</p><pre><code class="nohighlight hljs">julia&gt; PlotlyJS.savefig(plot, &quot;bloch_sphere.png&quot;, width=size(plot)[1],
                        height=size(plot)[2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/SnowflakePlots.jl/src/bloch_sphere.jl#L51-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnowflakePlots.plot_bloch_sphere-Tuple{Ket}" href="#SnowflakePlots.plot_bloch_sphere-Tuple{Ket}"><code>SnowflakePlots.plot_bloch_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bloch_sphere(ket::Ket;
    qubit_id::Int = 1,
    bloch_sphere::BlochSphere = BlochSphere())</code></pre><p>Plots the Bloch sphere of qubit <code>qubit_id</code> for the state represented by <code>ket</code>.</p><p>If <code>ket</code> is associated with multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit <code>qubit_id</code>. The appearance of the Bloch sphere can be modified by passing a <a href="library.html#SnowflakePlots.BlochSphere"><code>BlochSphere</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ket = Ket(1/sqrt(2)*[1, 1])
2-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.7071067811865475 + 0.0im


</code></pre><pre><code class="nohighlight hljs">julia&gt; plot = plot_bloch_sphere(ket)
</code></pre><p><img src="assets/visualize/plot_bloch_sphere_for_ket.png" alt="Bloch sphere for ket"/></p><p>The Bloch sphere can be saved to a file by calling:</p><pre><code class="nohighlight hljs">julia&gt; PlotlyJS.savefig(plot, &quot;bloch_sphere.png&quot;, width=size(plot)[1],
                        height=size(plot)[2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/SnowflakePlots.jl/src/bloch_sphere.jl#L104-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnowflakePlots.plot_bloch_sphere-Tuple{AbstractOperator}" href="#SnowflakePlots.plot_bloch_sphere-Tuple{AbstractOperator}"><code>SnowflakePlots.plot_bloch_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bloch_sphere(density_matrix::AbstractOperator;
    qubit_id::Int = 1,
    bloch_sphere::BlochSphere = BlochSphere())</code></pre><p>Plots the Bloch sphere of qubit <code>qubit_id</code> given the <code>density_matrix</code>.</p><p>If the <code>density_matrix</code> is associated with multiple qubits, the Bloch sphere is constructed from the 1-qubit reduced density matrix of qubit <code>qubit_id</code>. The appearance of the Bloch sphere can be modified by passing a <a href="library.html#SnowflakePlots.BlochSphere"><code>BlochSphere</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = DenseOperator([1.0 0.0;
                          0.0 0.0])
(2, 2)-element Snowflake.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im
</code></pre><pre><code class="nohighlight hljs">julia&gt; plot = plot_bloch_sphere(ρ)
</code></pre><p><img src="assets/visualize/plot_bloch_sphere_for_operator.png" alt="Bloch sphere for operator"/></p><p>The Bloch sphere can be saved to a file by calling:</p><pre><code class="nohighlight hljs">julia&gt; PlotlyJS.savefig(plot, &quot;bloch_sphere.png&quot;, width=size(plot)[1],
                        height=size(plot)[2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/SnowflakePlots.jl/src/bloch_sphere.jl#L147-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnowflakePlots.BlochSphere" href="#SnowflakePlots.BlochSphere"><code>SnowflakePlots.BlochSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlochSphere</code></pre><p>Contains fields which affect how a Bloch sphere is generated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ket = Ket(1/sqrt(2)*[1, 1])
2-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.7071067811865475 + 0.0im


julia&gt; bloch_sphere = BlochSphere(vector_color=&quot;green&quot;);
</code></pre><pre><code class="nohighlight hljs">julia&gt; plot = plot_bloch_sphere(ket, bloch_sphere=bloch_sphere)
</code></pre><p><img src="assets/visualize/plot_green_bloch_sphere.png" alt="Bloch sphere for ket"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/SnowflakePlots.jl/src/bloch_sphere.jl#L4-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnowflakePlots.plot_bloch_sphere_animation-Tuple{Array{Ket{T}, 1} where T&lt;:Complex}" href="#SnowflakePlots.plot_bloch_sphere_animation-Tuple{Array{Ket{T}, 1} where T&lt;:Complex}"><code>SnowflakePlots.plot_bloch_sphere_animation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bloch_sphere_animation(ket_list::Vector{Ket{T}} where {T&lt;:Complex};
    qubit_id::Int = 1,
    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())</code></pre><p>Plots a Bloch sphere animation of qubit <code>qubit_id</code> for the states listed in <code>ket_list</code>.</p><p>If <code>ket_list</code> is associated with multiple qubits, the Bloch sphere animation is constructed from the 1-qubit reduced density matrices of qubit <code>qubit_id</code>. Animation settings and the appearance of the Bloch sphere can be modified by passing an <a href="library.html#SnowflakePlots.AnimatedBlochSphere"><code>AnimatedBlochSphere</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ket_list = [Ket([1, 0]), Ket(1/sqrt(2)*[1, 1])];

julia&gt; plot = plot_bloch_sphere_animation(ket_list)
</code></pre><p>The Bloch sphere animation can be saved to an html file by calling:</p><pre><code class="nohighlight hljs">julia&gt; PlotlyJS.savefig(plot, &quot;bloch_sphere_animation.html&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/SnowflakePlots.jl/src/bloch_sphere.jl#L408-L433">source</a></section></article><iframe src="assets/visualize/plot_bloch_sphere_animation_for_ket.html"
style="height:825px;width:100%;">
</iframe><article class="docstring"><header><a class="docstring-binding" id="SnowflakePlots.plot_bloch_sphere_animation-Tuple{Vector{T} where T&lt;:AbstractOperator}" href="#SnowflakePlots.plot_bloch_sphere_animation-Tuple{Vector{T} where T&lt;:AbstractOperator}"><code>SnowflakePlots.plot_bloch_sphere_animation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bloch_sphere_animation(density_matrix_list::Vector{T} where {T&lt;:AbstractOperator};
    qubit_id::Int = 1,
    animated_bloch_sphere::AnimatedBlochSphere = AnimatedBlochSphere())</code></pre><p>Plots a Bloch sphere animation of qubit <code>qubit_id</code> for the states listed in <code>density_matrix_list</code>.</p><p>If <code>density_matrix_list</code> is associated with multiple qubits, the Bloch sphere animation is constructed from the 1-qubit reduced density matrices of qubit <code>qubit_id</code>. Animation settings and the appearance of the Bloch sphere can be modified by passing an <a href="library.html#SnowflakePlots.AnimatedBlochSphere"><code>AnimatedBlochSphere</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ψ_0 = DenseOperator([0.5 0.5; 0.5 0.5]);

julia&gt; ψ_1 = DenseOperator([0.5 -0.5im; 0.5im 0.5]);

julia&gt; plot = plot_bloch_sphere_animation([ψ_0, ψ_1])
</code></pre><p>The Bloch sphere animation can be saved to an html file by calling:</p><pre><code class="nohighlight hljs">julia&gt; PlotlyJS.savefig(plot, &quot;bloch_sphere_animation.html&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/SnowflakePlots.jl/src/bloch_sphere.jl#L442-L470">source</a></section></article><iframe src="assets/visualize/plot_bloch_sphere_animation_for_operator.html"
style="height:825px;width:100%;">
</iframe><article class="docstring"><header><a class="docstring-binding" id="SnowflakePlots.AnimatedBlochSphere" href="#SnowflakePlots.AnimatedBlochSphere"><code>SnowflakePlots.AnimatedBlochSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnimatedBlochSphere</code></pre><p>Contains fields which affect how a Bloch sphere animation is generated.</p><p><strong>Examples</strong></p><p>By default, additional Bloch sphere vectors are generated between each state using interpolation. The number of additional vectors can be changed by passing a value for the keyword <code>num_interpolated_points</code>.</p><pre><code class="nohighlight hljs">julia&gt; ket_list = [Ket([1, 0]), Ket(1/sqrt(2)*[1, 1])];

julia&gt; animated_sphere = AnimatedBlochSphere(num_interpolated_points=0,
        history_line_color=&quot;transparent&quot;, frame_duration=1000);

julia&gt; plot = plot_bloch_sphere_animation(ket_list, animated_bloch_sphere=animated_sphere)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/SnowflakePlots.jl/src/bloch_sphere.jl#L379-L398">source</a></section></article><iframe src="assets/visualize/plot_bloch_sphere_animation_without_interpolation.html"
style="height:825px;width:100%;">
</iframe><article class="docstring"><header><a class="docstring-binding" id="SnowflakePlots.plot_histogram" href="#SnowflakePlots.plot_histogram"><code>SnowflakePlots.plot_histogram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_histogram(circuit::QuantumCircuit, shots_count::Int)</code></pre><p>Plots a histogram showing the measurement output distribution of a <code>circuit</code>.</p><p>The number of shots taken is specified by <code>shots_count</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count=2);

julia&gt; push!(circuit, [hadamard(1), sigma_x(2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──

</code></pre><pre><code class="language-julia hljs">julia&gt; plot = plot_histogram(circuit, 100)
</code></pre><p><img src="assets/visualize/plot_histogram.png" alt="Measurement histogram for circuit"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/SnowflakePlots.jl/src/visualize.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnowflakePlots.viz_wigner" href="#SnowflakePlots.viz_wigner"><code>SnowflakePlots.viz_wigner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">viz_wigner(ρ::AbstractOperator,
    x::Union{AbstractRange{&lt;:Real},AbstractVector{&lt;:Real}},
    y::Union{AbstractRange{&lt;:Real},AbstractVector{&lt;:Real}})</code></pre><p>Generates a contour plot of the Wigner function of the density matrix <code>ρ</code>.</p><p>The range of the plot is specified by the phase-space coordinates <code>x</code> and <code>y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = ket2dm(coherent(0.25, 8));

julia&gt; x = y = -3.0:0.1:3.0;
</code></pre><pre><code class="language-julia hljs">julia&gt; viz_wigner(ρ, x, y)
</code></pre><p><img src="assets/visualize/viz_wigner.png" alt="Wigner function contour plot"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Snowflake.jl/blob/cdcaccad5e2fc479255574ca0da06150fd986d15/SnowflakePlots.jl/src/visualize.jl#L44-L65">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="qc/basics.html">« Basics</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 20 April 2023 22:51">Thursday 20 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
